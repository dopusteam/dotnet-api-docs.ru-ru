<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9bd576ddd6eb1bc0a5ea614cefc399143bb707e7" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58695751" /></Metadata><TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="c2738-101">Представляет асинхронную операцию.</span><span class="sxs-lookup"><span data-stu-id="c2738-101">Represents an asynchronous operation.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <span data-ttu-id="c2738-102"><xref:System.Threading.Tasks.Task> Класса представляет одну операцию, которая не возвращает значение и обычно выполняется асинхронно.</span><span class="sxs-lookup"><span data-stu-id="c2738-102">The <xref:System.Threading.Tasks.Task> class represents a single operation that does not return a value and that usually executes asynchronously.</span></span> <span data-ttu-id="c2738-103"><xref:System.Threading.Tasks.Task> объекты являются одним из основных составляющих [асинхронную модель на основе задач](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) впервые появилась в .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="c2738-103"><xref:System.Threading.Tasks.Task> objects are one of the central components of the  [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) first introduced in the .NET Framework 4.</span></span> <span data-ttu-id="c2738-104">Поскольку работа выполняется по <xref:System.Threading.Tasks.Task> объект обычно выполняется асинхронно в потоке пула потоков, а не синхронно в потоке основного приложения, можно использовать <xref:System.Threading.Tasks.Task.Status%2A> свойства, а также <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, и <xref:System.Threading.Tasks.Task.IsFaulted%2A> свойства, чтобы определить состояние задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-104">Because the work performed by a <xref:System.Threading.Tasks.Task> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <xref:System.Threading.Tasks.Task.Status%2A> property, as well as the <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, and <xref:System.Threading.Tasks.Task.IsFaulted%2A> properties, to determine the   state of a task.</span></span> <span data-ttu-id="c2738-105">Чаще всего лямбда-выражение используется для указания ожидаемого задачи для выполнения работы.</span><span class="sxs-lookup"><span data-stu-id="c2738-105">Most commonly, a lambda expression is used to specify the work that the task is to perform.</span></span>  
  
 <span data-ttu-id="c2738-106">Для операций, возвращающих значения, используйте <xref:System.Threading.Tasks.Task%601> класса.</span><span class="sxs-lookup"><span data-stu-id="c2738-106">For operations that return values, you use the <xref:System.Threading.Tasks.Task%601> class.</span></span>  
  
 <span data-ttu-id="c2738-107">Содержание</span><span class="sxs-lookup"><span data-stu-id="c2738-107">In this section:</span></span>  
  
 <span data-ttu-id="c2738-108">[Примеры создания экземпляра задачи](#Instant) </span><span class="sxs-lookup"><span data-stu-id="c2738-108">[Task instantiation examples](#Instant) </span></span>  
 <span data-ttu-id="c2738-109">[Создание и выполнение задачи](#Creating) </span><span class="sxs-lookup"><span data-stu-id="c2738-109">[Creating and executing a task](#Creating) </span></span>  
 <span data-ttu-id="c2738-110">[Разделение задач создания и выполнения](#Separating) </span><span class="sxs-lookup"><span data-stu-id="c2738-110">[Separating task creation and execution](#Separating) </span></span>  
 <span data-ttu-id="c2738-111">[Ожидание завершения одного или нескольких задач](#WaitingForOne) </span><span class="sxs-lookup"><span data-stu-id="c2738-111">[Waiting for one or more tasks to complete](#WaitingForOne) </span></span>  
 <span data-ttu-id="c2738-112">[Задачи и языка и региональных параметров](#Culture) </span><span class="sxs-lookup"><span data-stu-id="c2738-112">[Tasks and culture](#Culture) </span></span>  
 [<span data-ttu-id="c2738-113">Для разработчиков отладчика</span><span class="sxs-lookup"><span data-stu-id="c2738-113">For debugger developers</span></span>](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a><span data-ttu-id="c2738-114">При создании экземпляра задачи</span><span class="sxs-lookup"><span data-stu-id="c2738-114">Task instantiation</span></span>  
 <span data-ttu-id="c2738-115">Следующий пример создает и выполняет четыре задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-115">The following example creates and executes four tasks.</span></span> <span data-ttu-id="c2738-116">Выполнить три задачи <xref:System.Action%601> делегат с именем `action`, который принимает аргумент типа <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="c2738-116">Three tasks execute an <xref:System.Action%601> delegate named `action`, which accepts an argument of type <xref:System.Object>.</span></span> <span data-ttu-id="c2738-117">Четвертый задача выполняет лямбда-выражения ( <xref:System.Action> делегировать) то есть определенный встроенным в вызове метода создания задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-117">A fourth task executes a lambda expression (an <xref:System.Action> delegate) that is defined inline in the call to the task creation method.</span></span> <span data-ttu-id="c2738-118">Каждая задача создается и выполнения по-разному:</span><span class="sxs-lookup"><span data-stu-id="c2738-118">Each task is instantiated and run in a different way:</span></span>  
  
-   <span data-ttu-id="c2738-119">Задача `t1` создается путем вызова конструктора класса задачи, но начатую посредством вызова его <xref:System.Threading.Tasks.Task.Start> метод только после задачи `t2` запущена.</span><span class="sxs-lookup"><span data-stu-id="c2738-119">Task `t1` is instantiated by calling a Task class constructor, but is started by calling its <xref:System.Threading.Tasks.Task.Start> method only after task `t2` has started.</span></span>  
  
-   <span data-ttu-id="c2738-120">Задача `t2` создается и запустить в одном вызове метода, вызвав командлет <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-120">Task `t2` is instantiated and started in a single method call by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="c2738-121">Задача `t3` создается и запустить в одном вызове метода, вызвав командлет <xref:System.Threading.Tasks.Task.Run%28System.Action%29> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-121">Task `t3` is instantiated and started in a single method call by calling the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span>  
  
-   <span data-ttu-id="c2738-122">Задача `t4` выполняется синхронно в основном потоке, вызвав <xref:System.Threading.Tasks.Task.RunSynchronously> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-122">Task `t4` is executed synchronously on the main thread by calling the <xref:System.Threading.Tasks.Task.RunSynchronously> method.</span></span>  
  
 <span data-ttu-id="c2738-123">Так как задача `t4` выполняется синхронно, оно выполняется в потоке основного приложения.</span><span class="sxs-lookup"><span data-stu-id="c2738-123">Because task `t4` executes synchronously, it executes on the main application thread.</span></span> <span data-ttu-id="c2738-124">Остальные задачи обычно асинхронного выполнения в одной или нескольких потоках пула потоков.</span><span class="sxs-lookup"><span data-stu-id="c2738-124">The remaining tasks execute asynchronously typically on one or more thread pool threads.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a><span data-ttu-id="c2738-125">Создание и выполнение задачи</span><span class="sxs-lookup"><span data-stu-id="c2738-125">Creating and executing a task</span></span>  
 <span data-ttu-id="c2738-126"><xref:System.Threading.Tasks.Task> экземпляры могут создаваться разными способами.</span><span class="sxs-lookup"><span data-stu-id="c2738-126"><xref:System.Threading.Tasks.Task> instances may be created in a variety of ways.</span></span> <span data-ttu-id="c2738-127">Наиболее распространенным подходом, который доступен, начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], заключается в вызове статического <xref:System.Threading.Tasks.Task.Run%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-127">The most common approach, which is available starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], is to call the static <xref:System.Threading.Tasks.Task.Run%2A> method.</span></span> <span data-ttu-id="c2738-128"><xref:System.Threading.Tasks.Task.Run%2A> Метод предоставляет простой способ запуска задачи, используя значения по умолчанию и не требует дополнительных параметров.</span><span class="sxs-lookup"><span data-stu-id="c2738-128">The <xref:System.Threading.Tasks.Task.Run%2A> method provides a simple way to start a task using default values and without requiring additional parameters.</span></span> <span data-ttu-id="c2738-129">В следующем примере используется <xref:System.Threading.Tasks.Task.Run%28System.Action%29> метод, чтобы запустить задачу, которая выполняет цикл, а затем отображает количество итераций цикла:</span><span class="sxs-lookup"><span data-stu-id="c2738-129">The following example uses the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method to start a task that loops and then displays the number of loop iterations:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 <span data-ttu-id="c2738-130">Альтернативы и наиболее распространенный метод для запуска задачи в [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], является статическим <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-130">An alternative, and the most common method to start a task in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], is the static <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-131"><xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> Возвращает <xref:System.Threading.Tasks.TaskFactory> объекта.</span><span class="sxs-lookup"><span data-stu-id="c2738-131">The <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> property returns a <xref:System.Threading.Tasks.TaskFactory> object.</span></span> <span data-ttu-id="c2738-132">Перегруженные версии <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод позволяет задавать параметры для передачи параметры создания задач и планировщик задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-132">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method let you specify parameters to pass to the task creation options and a task scheduler.</span></span> <span data-ttu-id="c2738-133">В следующем примере используется <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод для запуска задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-133">The following example uses the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to start a task.</span></span> <span data-ttu-id="c2738-134">Это функционально эквивалентно кода в предыдущем примере.</span><span class="sxs-lookup"><span data-stu-id="c2738-134">It is functionally equivalent to the code in the previous example.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 <span data-ttu-id="c2738-135">Более полные примеры см. в разделе [Task-based асинхронное программирование](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-135">For more complete examples, see [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).</span></span>  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a><span data-ttu-id="c2738-136">Разделение задач создания и выполнения</span><span class="sxs-lookup"><span data-stu-id="c2738-136">Separating task creation and execution</span></span>  
 <span data-ttu-id="c2738-137"><xref:System.Threading.Tasks.Task> Класс также предоставляет конструкторы, которые инициализируют задачу, но не запланировать его выполнение.</span><span class="sxs-lookup"><span data-stu-id="c2738-137">The <xref:System.Threading.Tasks.Task> class also provides constructors that initialize the task but that do not schedule it for execution.</span></span> <span data-ttu-id="c2738-138">Для повышения производительности <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> или <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод — предпочтительный механизм для создания и планирования вычислительных задач, но для сценариев, где должны быть разделены Создание и планирование, можно использовать конструкторы и затем вызвать <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> метод для планирования задачи для выполнения в дальнейшем.</span><span class="sxs-lookup"><span data-stu-id="c2738-138">For performance reasons, the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method is the preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation and scheduling must be separated, you can use the constructors and then call the <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> method to schedule the task for execution at a later time.</span></span>  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a><span data-ttu-id="c2738-139">Ожидание завершения одного или нескольких задач</span><span class="sxs-lookup"><span data-stu-id="c2738-139">Waiting for one or more tasks to complete</span></span>  
 <span data-ttu-id="c2738-140">Поскольку задачи обычно выполняются асинхронно в потоке пула потоков, потока, который создает и запускает задачу продолжает выполнение сразу же после создания экземпляра задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-140">Because tasks typically run asynchronously on a thread pool thread, the thread that creates and starts the task continues execution as soon as the task has been instantiated.</span></span> <span data-ttu-id="c2738-141">В некоторых случаях, когда вызывающий поток является потоком основного приложения, приложение может завершиться перед любым задачи фактически начинает выполнение.</span><span class="sxs-lookup"><span data-stu-id="c2738-141">In some cases, when the calling thread is the main application thread, the app may terminate before any the task actually begins execution.</span></span> <span data-ttu-id="c2738-142">В других случаях логику приложения может потребоваться, что вызывающему потоку продолжить выполнение только в том случае, если один или несколько задач было выполнено.</span><span class="sxs-lookup"><span data-stu-id="c2738-142">In others,   your application's logic may require that the calling thread continue execution only when one or more tasks has completed execution.</span></span> <span data-ttu-id="c2738-143">Вы можете синхронизировать выполнение вызывающего потока и асинхронной задачи он запускает путем вызова `Wait` метод для ожидания завершения одной или нескольких задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-143">You can synchronize the execution of the calling thread and the asynchronous tasks it launches by calling a `Wait` method to wait for one or more tasks to complete.</span></span>  
  
 <span data-ttu-id="c2738-144">Чтобы дождаться завершения выполнения одной задачи, можно вызвать его <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-144">To wait for a single task to complete, you can call its <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-145">Вызов <xref:System.Threading.Tasks.Task.Wait%2A> метод блокирует вызывающий поток до завершения выполнения экземпляра одного класса.</span><span class="sxs-lookup"><span data-stu-id="c2738-145">A call to the  <xref:System.Threading.Tasks.Task.Wait%2A> method blocks the calling thread until the single class instance has completed execution.</span></span>  
  
 <span data-ttu-id="c2738-146">В следующем примере вызывается без параметров <xref:System.Threading.Tasks.Task.Wait> метод безусловно ожидания до завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-146">The following example calls the parameterless <xref:System.Threading.Tasks.Task.Wait> method to wait unconditionally until a task completes.</span></span> <span data-ttu-id="c2738-147">Задача имитирует работы путем вызова <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод в спящий режим на две секунды.</span><span class="sxs-lookup"><span data-stu-id="c2738-147">The task simulates work by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to sleep for two seconds.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 <span data-ttu-id="c2738-148">Условно также можно дождаться завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-148">You can also conditionally wait for a task to complete.</span></span> <span data-ttu-id="c2738-149"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> И <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> методы блокирует вызывающий поток до завершения задачи или истечет время ожидания, какое событие произойдет первым.</span><span class="sxs-lookup"><span data-stu-id="c2738-149">The <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> and <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> methods block the calling thread until the task finishes or a timeout interval elapses, whichever comes first.</span></span> <span data-ttu-id="c2738-150">Так, как следующий пример запускает задачу, которая определяет значение времени ожидания одну секунду, а вызывающий поток блокируется, пока не истечет время ожидания, но бездействует в течение двух секунд и до завершения выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-150">Since the following example launches a task that sleeps for two seconds but defines a one-second timeout value, the calling thread blocks until the timeout expires and before the task has completed execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 <span data-ttu-id="c2738-151">Также можно использовать токен отмены, путем вызова <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> и <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> методы.</span><span class="sxs-lookup"><span data-stu-id="c2738-151">You can also supply a cancellation token by calling the <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> and  <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> methods.</span></span> <span data-ttu-id="c2738-152">Если токен <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> свойство `true` или становится `true` хотя <xref:System.Threading.Tasks.Task.Wait%2A> выполняется метод, этот метод вызывает <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="c2738-152">If the  token's <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true` or becomes `true` while the <xref:System.Threading.Tasks.Task.Wait%2A> method is executing, the method throws an <xref:System.OperationCanceledException>.</span></span>  
  
 <span data-ttu-id="c2738-153">В некоторых случаях может потребоваться подождать для первого ряда выполнение задач для завершения, но не является осторожностью, что задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-153">In some cases, you may want to wait for the first of a series of executing tasks to complete, but don't care which task it is.</span></span>  <span data-ttu-id="c2738-154">Для этой цели, вы можете вызвать один из перегруженных версий <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-154">For this purpose, you can call one of the overloads of the <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="c2738-155">В следующем примере создается три задачи, каждая из которых находится в спящем режиме, для определяют интервал с генератором случайных чисел.</span><span class="sxs-lookup"><span data-stu-id="c2738-155">The following example creates three tasks, each of which sleeps for an interval determine by a random number generator.</span></span> <span data-ttu-id="c2738-156"><xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> Метод ожидает завершения первой задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-156">The <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> method waits for the first task to complete.</span></span> <span data-ttu-id="c2738-157">Затем пример отображает сведения о состоянии всех трех задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-157">The example then displays information about the status of all three tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 <span data-ttu-id="c2738-158">Также можно отложить для каждого ряда задач, которые необходимо завершить путем вызова <xref:System.Threading.Tasks.Task.WaitAll%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-158">You can also wait for all of a series of tasks to complete by calling the <xref:System.Threading.Tasks.Task.WaitAll%2A> method.</span></span> <span data-ttu-id="c2738-159">Следующий пример создает десять задач, ожидает в течение всех десяти для завершения, а затем отображает их состояние.</span><span class="sxs-lookup"><span data-stu-id="c2738-159">The following example creates ten tasks, waits for all ten to complete, and then displays their status.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 <span data-ttu-id="c2738-160">Обратите внимание, что при ожидании завершения одного или нескольких задач, все исключения, возникшие в выполняющихся задач распространяются на поток, вызывающий `Wait` метода, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="c2738-160">Note that when you wait for one or more tasks to complete, any exceptions thrown in the running tasks are propagated on the thread that calls the `Wait` method, as the following example shows.</span></span> <span data-ttu-id="c2738-161">Она запускает 12 задачи, три из которых нормально завершен и три из которых выдал исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-161">It launches 12 tasks, three of which complete normally and three of which throw an exception.</span></span> <span data-ttu-id="c2738-162">Из оставшихся шести задач три будут отменены до ее начала, и три отменяются при их выполнении.</span><span class="sxs-lookup"><span data-stu-id="c2738-162">Of the remaining six tasks, three are cancelled before the start, and three are cancelled while they executing.</span></span> <span data-ttu-id="c2738-163">Исключения, возникшие в <xref:System.Threading.Tasks.Task.WaitAll%2A> вызов метода на них обрабатываются `try` / `catch` блока.</span><span class="sxs-lookup"><span data-stu-id="c2738-163">Exceptions are thrown in the <xref:System.Threading.Tasks.Task.WaitAll%2A> method call and are handled by a `try`/`catch` block.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 <span data-ttu-id="c2738-164">Дополнительные сведения об обработке исключений в асинхронных операций на основе задач, см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-164">For more information on exception handling in task-based asynchronous operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a><span data-ttu-id="c2738-165">Задачи и языка и региональных параметров</span><span class="sxs-lookup"><span data-stu-id="c2738-165">Tasks and culture</span></span>  
 <span data-ttu-id="c2738-166">Начиная с настольных приложений, предназначенных [!INCLUDE[net_v46](~/includes/net-v46-md.md)], язык и региональные параметры потока, который создает и вызывает задачу становится частью контекст потока.</span><span class="sxs-lookup"><span data-stu-id="c2738-166">Starting with desktop apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the thread that creates and invokes a task becomes part of the thread's context.</span></span> <span data-ttu-id="c2738-167">Независимо от текущего потока, на котором выполняется задача, текущий язык и региональные параметры задачи является язык и региональные параметры вызывающего потока.</span><span class="sxs-lookup"><span data-stu-id="c2738-167">That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</span></span> <span data-ttu-id="c2738-168">Для приложений, предназначенных для версий платформы .NET Framework до версии [!INCLUDE[net_v46](~/includes/net-v46-md.md)], язык и региональные параметры задачи — это язык и региональные параметры потока, на котором выполняется задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-168">For apps that target versions of the .NET Framework prior to the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the task is the culture of the thread on which the task executes.</span></span> <span data-ttu-id="c2738-169">Дополнительные сведения см. в разделе «Язык и региональные параметры и асинхронные операции на основе задач» в <xref:System.Globalization.CultureInfo> разделе.</span><span class="sxs-lookup"><span data-stu-id="c2738-169">For more information, see the "Culture and task-based asynchronous operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c2738-170">Приложения Store придерживаются среды выполнения Windows в установку и получение культуры по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="c2738-170">Store apps follow the Windows Runtime in setting and getting the default culture.</span></span>  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a><span data-ttu-id="c2738-171">Для разработчиков отладчика</span><span class="sxs-lookup"><span data-stu-id="c2738-171">For debugger developers</span></span>  
 <span data-ttu-id="c2738-172">Для разработчиков, реализации пользовательских отладчиков несколько членов с внутренним и закрытым задачи можно использовать (они могут изменяться от выпуска к выпуску).</span><span class="sxs-lookup"><span data-stu-id="c2738-172">For developers implementing custom debuggers, several internal and private members of task may be useful (these may change from release to release).</span></span> <span data-ttu-id="c2738-173">`m_taskId` Поле выступает в качестве резервного хранилища для <xref:System.Threading.Tasks.Task.Id%2A> свойства, однако доступ к это поле прямо из отладчика может быть более эффективным, чем к доступу и то же значение с помощью метода чтения данного свойства ( `s_taskIdCounter` счетчик используется для извлечения следующий доступный идентификатор задачи).</span><span class="sxs-lookup"><span data-stu-id="c2738-173">The `m_taskId` field serves as the backing store for the <xref:System.Threading.Tasks.Task.Id%2A> property, however accessing this field directly from a debugger may be more efficient than accessing the same value through the property's getter method (the `s_taskIdCounter` counter is used to retrieve the next available ID for a task).</span></span> <span data-ttu-id="c2738-174">Аналогичным образом `m_stateFlags` поле хранятся сведения о текущем этапе жизненного цикла задачи, сведения также доступны через <xref:System.Threading.Tasks.Task.Status%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="c2738-174">Similarly, the `m_stateFlags` field stores information about the current lifecycle stage of the task, information also accessible through the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="c2738-175">`m_action` Поле хранит ссылку на делегат задачи и `m_stateObject` поле хранит состояние асинхронной, переданных в задачу разработчиком.</span><span class="sxs-lookup"><span data-stu-id="c2738-175">The `m_action` field stores a reference to the task's delegate, and the `m_stateObject` field stores the async state passed to the task by the developer.</span></span> <span data-ttu-id="c2738-176">Наконец, чтобы отладчики, выполняющие синтаксический анализ кадров стека `InternalWait` метод служит потенциальным для при вводит операции ожидания задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-176">Finally, for debuggers that parse stack frames, the `InternalWait` method serves a potential marker for when a task is entering a wait operation.</span></span>   
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="c2738-177">Все члены <see cref="T:System.Threading.Tasks.Task" />, за исключением <see cref="M:System.Threading.Tasks.Task.Dispose" />, являются потокобезопасными и могут быть использованы из нескольких потоков одновременно.</span><span class="sxs-lookup"><span data-stu-id="c2738-177">All members of <see cref="T:System.Threading.Tasks.Task" />, except for <see cref="M:System.Threading.Tasks.Task.Dispose" />, are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="c2738-178">Библиотека параллельных задач (TPL)</span><span class="sxs-lookup"><span data-stu-id="c2738-178">Task Parallel Library (TPL)</span></span></related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="c2738-179">Асинхронное программирование на основе задач</span><span class="sxs-lookup"><span data-stu-id="c2738-179">Task-based Asynchronous Programming</span></span></related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364"><span data-ttu-id="c2738-180">Примеры параллельного программирования в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="c2738-180">Samples for Parallel Programming with the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-181">Инициализирует новый объект <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-181">Initializes a new <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="c2738-182">Делегат, который представляет код, выполняемый в рамках задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-182">The delegate that represents the code to execute in the task.</span></span></param>
        <summary><span data-ttu-id="c2738-183">Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданным действием.</span><span class="sxs-lookup"><span data-stu-id="c2738-183">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-184">Этот конструктор следует использовать только в сложных сценариях, когда он необходим отделяется создания и запуска задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-184">This constructor should only be used in advanced scenarios where it is required that the creation and starting of the task is separated.</span></span>  
  
 <span data-ttu-id="c2738-185">Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> или <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-185">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c2738-186">Если задача, не выполняя никаких действий для ситуация каким-то await, необходима только для потребителей API <xref:System.Threading.Tasks.TaskCompletionSource%601> следует использовать.</span><span class="sxs-lookup"><span data-stu-id="c2738-186">If a task with no action is needed just for the consumer of an API to have something to await, a <xref:System.Threading.Tasks.TaskCompletionSource%601> should be used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-187">В следующем примере используется <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> конструктор для создания задачи, которые получают имена файлов в указанных каталогах.</span><span class="sxs-lookup"><span data-stu-id="c2738-187">The following example uses the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor to create tasks that retrieve the filenames in specified directories.</span></span> <span data-ttu-id="c2738-188">Все задачи записи имен файлов к одному <xref:System.Collections.Concurrent.ConcurrentBag%601> объекта.</span><span class="sxs-lookup"><span data-stu-id="c2738-188">All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span> <span data-ttu-id="c2738-189">Затем в примере вызывается <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> метод, чтобы гарантировать, что все задачи завершены, а затем отображает количество общее количество имен файлов, записываемый <xref:System.Collections.Concurrent.ConcurrentBag%601> объекта.</span><span class="sxs-lookup"><span data-stu-id="c2738-189">The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 <span data-ttu-id="c2738-190">Следующий пример идентичен, за исключением того, чтобы его использовать <xref:System.Threading.Tasks.Task.Run%28System.Action%29> метод для создания экземпляра и запуска задачи в рамках одной операции.</span><span class="sxs-lookup"><span data-stu-id="c2738-190">The following example is identical, except that it used the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method to instantiate and run the task in a single operation.</span></span> <span data-ttu-id="c2738-191">Этот метод возвращает <xref:System.Threading.Tasks.Task> объект, представляющий задачу.</span><span class="sxs-lookup"><span data-stu-id="c2738-191">The method returns the <xref:System.Threading.Tasks.Task> object that represents the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-192">Аргумент <paramref name="action" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-192">The <paramref name="action" /> argument is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="c2738-193">Делегат, который представляет код, выполняемый в рамках задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-193">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-194">Маркер <see cref="T:System.Threading.CancellationToken" />, который будет контролироваться новой задачей.</span><span class="sxs-lookup"><span data-stu-id="c2738-194">The <see cref="T:System.Threading.CancellationToken" /> that the new  task will observe.</span></span></param>
        <summary><span data-ttu-id="c2738-195">Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием и токеном <see cref="T:System.Threading.CancellationToken" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-195">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and <see cref="T:System.Threading.CancellationToken" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-196">Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> и <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> методы.</span><span class="sxs-lookup"><span data-stu-id="c2738-196">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="c2738-197">Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-197">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 <span data-ttu-id="c2738-198">Дополнительные сведения см. в разделе [параллелизм задач (библиотека параллельных задач)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) и [Отмена в управляемых потоках](~/docs/standard/threading/cancellation-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-198">For more information, see [Task Parallelism (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-199">В следующем примере вызывается <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> конструктор, чтобы создать задачу, которая выполняет итерацию файлы в каталог C:\Windows\System32.</span><span class="sxs-lookup"><span data-stu-id="c2738-199">The following example calls the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> constructor to create a task that iterates the files in the C:\Windows\System32 directory.</span></span> <span data-ttu-id="c2738-200">Лямбда-выражение вызывает <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> метод, чтобы добавить информацию о каждом файле, чтобы <xref:System.Collections.Generic.List%601> объекта.</span><span class="sxs-lookup"><span data-stu-id="c2738-200">The lambda expression calls the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to add information about each  file to a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="c2738-201">Каждый отсоединенной вложенной задачей, вызываемых <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> цикл проверяет состояние токена отмены и если запрос на отмену вызывает <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-201">Each detached nested task invoked by the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop checks the state of the cancellation token and, if cancellation is requested, calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-202"><xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Вызывает метод <xref:System.OperationCanceledException> исключение, которое обрабатывается в `catch` заблокировать, если вызывающий поток вызывает <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-202">The <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method throws an <xref:System.OperationCanceledException> exception that is handled in a `catch` block when the calling thread calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="c2738-203"><xref:System.Threading.Tasks.Task.Start%2A> Затем вызывается метод для запуска задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-203">The <xref:System.Threading.Tasks.Task.Start%2A> method is then called to start the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-204">Предоставленный объект <see cref="T:System.Threading.CancellationToken" /> уже был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-204">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-205">Аргумент <paramref name="action" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-205">The <paramref name="action" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="c2738-206">Делегат, который представляет код, выполняемый в рамках задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-206">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="c2738-207">Объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, который используется для настройки поведения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-207">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="c2738-208">Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием и параметрами создания.</span><span class="sxs-lookup"><span data-stu-id="c2738-208">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-209">Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-209">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-210">Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-210">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-211">Аргумент <paramref name="action" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-211">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-212">Аргумент <paramref name="creationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-212">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="c2738-213">Делегат, который представляет код, выполняемый в рамках задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-213">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-214">Объект, который представляет данные, используемые действием.</span><span class="sxs-lookup"><span data-stu-id="c2738-214">An object representing data to be used by the action.</span></span></param>
        <summary><span data-ttu-id="c2738-215">Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием и состоянием.</span><span class="sxs-lookup"><span data-stu-id="c2738-215">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-216">Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-216">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-217">Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-217">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-218">В следующем примере определяется массив слов 6 букв.</span><span class="sxs-lookup"><span data-stu-id="c2738-218">The following example defines an array of 6-letter words.</span></span> <span data-ttu-id="c2738-219">Каждое слово затем передается в качестве аргумента для <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> конструктор, которого <xref:System.Action%601> делегат кодирует символы в слове, а затем отображает исходного слова и ее скремблированных версии.</span><span class="sxs-lookup"><span data-stu-id="c2738-219">Each word is then passed as an argument to the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> constructor, whose <xref:System.Action%601> delegate scrambles the characters in the word, then displays the original word and its scrambled version.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-220">Аргумент <paramref name="action" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-220">The <paramref name="action" /> argument is null.</span></span></exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="c2738-221">Делегат, который представляет код, выполняемый в рамках задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-221">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-222">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет контролироваться новой задачей.</span><span class="sxs-lookup"><span data-stu-id="c2738-222">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="c2738-223">Объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, который используется для настройки поведения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-223">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="c2738-224">Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием и параметрами создания.</span><span class="sxs-lookup"><span data-stu-id="c2738-224">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-225">Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-225">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-226">Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-226">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 <span data-ttu-id="c2738-227">Дополнительные сведения см. в разделе [параллелизм задач (библиотека параллельных задач)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) и [Отмена задач](~/docs/standard/parallel-programming/task-cancellation.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-227">For more information, see [Task Parallelism (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Task Cancellation](~/docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-228">Класс <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, уже удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-228">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-229">Аргумент <paramref name="action" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-229">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-230">Аргумент <paramref name="creationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-230">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="c2738-231">Делегат, который представляет код, выполняемый в рамках задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-231">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-232">Объект, который представляет данные, используемые действием.</span><span class="sxs-lookup"><span data-stu-id="c2738-232">An object representing data to be used by the action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-233">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет контролироваться новой задачей.</span><span class="sxs-lookup"><span data-stu-id="c2738-233">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <summary><span data-ttu-id="c2738-234">Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием, состоянием и параметрами.</span><span class="sxs-lookup"><span data-stu-id="c2738-234">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-235">Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-235">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-236">Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-236">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-237">Класс <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, уже удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-237">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-238">Аргумент <paramref name="action" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-238">The <paramref name="action" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="c2738-239">Делегат, который представляет код, выполняемый в рамках задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-239">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-240">Объект, который представляет данные, используемые действием.</span><span class="sxs-lookup"><span data-stu-id="c2738-240">An object representing data to be used by the action.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="c2738-241">Объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, который используется для настройки поведения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-241">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="c2738-242">Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием, состоянием и параметрами.</span><span class="sxs-lookup"><span data-stu-id="c2738-242">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-243">Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-243">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-244">Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-244">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-245">Аргумент <paramref name="action" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-245">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-246">Аргумент <paramref name="creationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-246">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="c2738-247">Делегат, который представляет код, выполняемый в рамках задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-247">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-248">Объект, который представляет данные, используемые действием.</span><span class="sxs-lookup"><span data-stu-id="c2738-248">An object representing data to be used by the action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-249">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет контролироваться новой задачей.</span><span class="sxs-lookup"><span data-stu-id="c2738-249">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="c2738-250">Объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, который используется для настройки поведения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-250">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="c2738-251">Инициализирует новую задачу <see cref="T:System.Threading.Tasks.Task" /> с заданными действием, состоянием и параметрами.</span><span class="sxs-lookup"><span data-stu-id="c2738-251">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-252">Вместо вызова этого конструктора, наиболее распространенным способом для создания экземпляра <xref:System.Threading.Tasks.Task> объекта и запуск задачи — путем вызова статического <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-252">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-253">Только преимущества, предлагаемые этим конструктором является то, что при создании объектов быть отделены от вызова задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-253">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-254">Класс <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, уже удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-254">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-255">Аргумент <paramref name="action" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-255">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-256">Аргумент <paramref name="creationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-256">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-257">Получает объект состояния, предоставленный при создании задачи <see cref="T:System.Threading.Tasks.Task" />, или значение null, если объект не предоставлен.</span><span class="sxs-lookup"><span data-stu-id="c2738-257">Gets the state object supplied when the <see cref="T:System.Threading.Tasks.Task" /> was created, or null if none was supplied.</span></span></summary>
        <value><span data-ttu-id="c2738-258">Объект <see cref="T:System.Object" />, представляющий данные о состоянии, переданные задаче на этапе создания.</span><span class="sxs-lookup"><span data-stu-id="c2738-258">An <see cref="T:System.Object" /> that represents the state data that was passed in to the task when it was created.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-259">Приведите объект обратно к исходному типу для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="c2738-259">Cast the object back to the original type to retrieve its data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-260">Возвращает задачу, которая уже завершилась успешно.</span><span class="sxs-lookup"><span data-stu-id="c2738-260">Gets a task that has already completed successfully.</span></span></summary>
        <value><span data-ttu-id="c2738-261">Успешно завершенная задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-261">The successfully completed task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-262">Это свойство Возвращает задачу, <xref:System.Threading.Tasks.Task.Status%2A> свойству <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span><span class="sxs-lookup"><span data-stu-id="c2738-262">This property returns a task whose <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span></span> <span data-ttu-id="c2738-263">Чтобы создать задачу, которая возвращает значение и выполняется до завершения, вызовите <xref:System.Threading.Tasks.Task.FromResult%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-263">To create task that returns a value and runs to completion, call the <xref:System.Threading.Tasks.Task.FromResult%2A> method.</span></span>  
  
 <span data-ttu-id="c2738-264">Повторные попытки получить значение этого свойства может не всегда возвращать тот же экземпляр.</span><span class="sxs-lookup"><span data-stu-id="c2738-264">Repeated attempts to retrieve this property value may not always return the same instance.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext"><span data-ttu-id="c2738-265">Значение <see langword="true" />, чтобы попытаться выполнить маршалинг продолжения обратно в исходный захваченный контекст; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-265"><see langword="true" /> to attempt to marshal the continuation back to the original context captured; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="c2738-266">Настраивает объект типа awaiter, используемый для данного объекта <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-266">Configures an awaiter used to await this <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <returns><span data-ttu-id="c2738-267">Объект, используемый для ожидания данной задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-267">An object used to await this task.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-268">Создает продолжение, которое выполняется асинхронно после завершения выполнения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-268">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c2738-269">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-269">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-270">При запуске делегата завершенная задача будет передана ему в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="c2738-270">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="c2738-271">Создает продолжение, которое выполняется асинхронно после завершения выполнения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-271">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c2738-272">Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-272">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-273">Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-273">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-274">В следующем примере определяется задача, которая заполняет массив, содержащий 100 случайных значений даты и времени.</span><span class="sxs-lookup"><span data-stu-id="c2738-274">The following example defines a task that populates an array with 100 random date and time values.</span></span> <span data-ttu-id="c2738-275">Она использует <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> метод для выбора самой ранней и последние значения даты, когда массив заполняется полностью.</span><span class="sxs-lookup"><span data-stu-id="c2738-275">It uses the <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> method to select the earliest and the latest date values once the array is fully populated.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 <span data-ttu-id="c2738-276">Так как консольное приложение может завершиться до задача продолжения выполняется, <xref:System.Threading.Tasks.Task.Wait> вызывается метод, чтобы убедиться, что продолжение завершается выполнение до окончания этого примера.</span><span class="sxs-lookup"><span data-stu-id="c2738-276">Because a console application may terminate before the continuation task executes, the <xref:System.Threading.Tasks.Task.Wait> method is called to ensure that the continuation finishes executing before the example ends.</span></span>  
  
 <span data-ttu-id="c2738-277">Дополнительный пример см. в разделе [создание цепочки задач с помощью задач продолжения](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-277">For an additional example, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-278">Аргумент <paramref name="continuationAction" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-278">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c2738-279">Действие, которое необходимо выполнить после завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-279">An action to run when the task completes.</span></span> <span data-ttu-id="c2738-280">При запуске делегату передается в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-280">When run, the delegate is passed the completed task and a caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-281">Объект, который представляет данные, используемые действием продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-281">An object representing data to be used by the continuation action.</span></span></param>
        <summary><span data-ttu-id="c2738-282">Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии и которое выполняется после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-282">Creates a continuation that receives caller-supplied state information and executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c2738-283">Новая задача продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-283">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-284">Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или выход из раньше, из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-284">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to cancellation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-285">Аргумент <paramref name="continuationAction" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-285">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c2738-286">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-286">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-287">При запуске делегата завершенная задача будет передана ему в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="c2738-287">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-288">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет назначен новой задаче продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-288">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="c2738-289">Создает продолжение, которое получает маркер отмены и которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-289">Creates a continuation that receives a cancellation token and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c2738-290">Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-290">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-291">Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-291">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-292"><see cref="T:System.Threading.CancellationTokenSource" />, создавший уже освобожденный токен.</span><span class="sxs-lookup"><span data-stu-id="c2738-292">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-293">Аргумент <paramref name="continuationAction" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-293">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c2738-294">Действие для запуска в соответствии с заданными <paramref name="continuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-294">An action to run according to the specified <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="c2738-295">При запуске делегата завершенная задача будет передана ему в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="c2738-295">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c2738-296">Параметры, определяющие запланированное время продолжения и его поведение.</span><span class="sxs-lookup"><span data-stu-id="c2738-296">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c2738-297">Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-297">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="c2738-298">Создает продолжение, которое выполняется после завершения целевой задачи в соответствии с заданными параметрами <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-298">Creates a continuation that executes when the target task completes according to the specified <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="c2738-299">Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-299">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-300">Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-300">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="c2738-301">Если указать критерии продолжения с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.</span><span class="sxs-lookup"><span data-stu-id="c2738-301">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-302">В следующем примере показано использование <xref:System.Threading.Tasks.TaskContinuationOptions> для указания, что задача продолжения должна выполняться синхронно при завершении предыдущей задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-302">The following example demonstrates using <xref:System.Threading.Tasks.TaskContinuationOptions> to specify that a continuation task should run synchronously when the antecedent task completes.</span></span> <span data-ttu-id="c2738-303">(Если указанная задача уже завершена, когда <xref:System.Threading.Tasks.Task.ContinueWith%2A> вызове синхронных продолжение будет выполняться в потоке вызывающего <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)</span><span class="sxs-lookup"><span data-stu-id="c2738-303">(If the specified task has already completed by the time <xref:System.Threading.Tasks.Task.ContinueWith%2A> is called, the synchronous continuation will run on the thread calling <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)</span></span>  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-304">Аргумент <paramref name="continuationAction" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-304">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-305">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-305">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c2738-306">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-306">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-307">При запуске делегата завершенная задача будет передана ему в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="c2738-307">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c2738-308">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-308">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c2738-309">Создает продолжение, которое выполняется асинхронно после завершения выполнения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-309">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-310">Продолжение использует указанный планировщик.</span><span class="sxs-lookup"><span data-stu-id="c2738-310">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="c2738-311">Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-311">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-312">Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-312">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-313">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-313">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-314">Аргумент <paramref name="continuationAction" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-314">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c2738-315">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-315">-or-</span></span> 
<span data-ttu-id="c2738-316">Аргумент <paramref name="scheduler" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-316">The <paramref name="scheduler" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c2738-317">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-317">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-318">При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-318">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-319">Объект, который представляет данные, используемые действием продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-319">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-320">Токен <see cref="T:System.Threading.CancellationToken" />, который будет назначен новой задаче продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-320">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="c2738-321">Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии и маркер отмены и которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-321">Creates a continuation that receives caller-supplied state information and a cancellation token and that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="c2738-322">Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-322">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-323">Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-323">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-324">Аргумент <paramref name="continuationAction" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-324">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-325">Предоставленный объект <see cref="T:System.Threading.CancellationToken" /> уже был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-325">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c2738-326">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-326">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-327">При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-327">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-328">Объект, который представляет данные, используемые действием продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-328">An object representing data to be used by the continuation action.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c2738-329">Параметры, определяющие запланированное время продолжения и его поведение.</span><span class="sxs-lookup"><span data-stu-id="c2738-329">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c2738-330">Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-330">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="c2738-331">Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии и которое выполняется после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-331">Creates a continuation that receives caller-supplied state information and executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-332">Продолжение выполняется на основе набора указанных условий.</span><span class="sxs-lookup"><span data-stu-id="c2738-332">The continuation executes based on a set of specified conditions.</span></span></summary>
        <returns><span data-ttu-id="c2738-333">Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-333">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-334">Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-334">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="c2738-335">Если указать критерии продолжения с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.</span><span class="sxs-lookup"><span data-stu-id="c2738-335">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-336">Аргумент <paramref name="continuationAction" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-336">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-337">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-337">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c2738-338">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-338">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span>  <span data-ttu-id="c2738-339">При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-339">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-340">Объект, который представляет данные, используемые действием продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-340">An object representing data to be used by the continuation action.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c2738-341">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-341">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c2738-342">Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии и выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-342">Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-343">Продолжение использует указанный планировщик.</span><span class="sxs-lookup"><span data-stu-id="c2738-343">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="c2738-344">Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-344">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-345">Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-345">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-346">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-346">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c2738-347">Действие для запуска в соответствии с заданными <paramref name="continuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-347">An action to run according to the specified <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="c2738-348">При запуске делегата завершенная задача будет передана ему в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="c2738-348">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-349">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет назначен новой задаче продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-349">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c2738-350">Параметры, определяющие запланированное время продолжения и его поведение.</span><span class="sxs-lookup"><span data-stu-id="c2738-350">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c2738-351">Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-351">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c2738-352">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-352">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c2738-353">Создает продолжение, которое выполняется после завершения целевой задачи в соответствии с заданными параметрами <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-353">Creates a continuation that executes when the target task competes according to the specified <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span> <span data-ttu-id="c2738-354">Продолжение получает маркер отмены и использует указанный планировщик.</span><span class="sxs-lookup"><span data-stu-id="c2738-354">The continuation receives a cancellation token and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="c2738-355">Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-355">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-356">Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-356">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="c2738-357">Если указать критерии с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.</span><span class="sxs-lookup"><span data-stu-id="c2738-357">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-358">Ниже приведен пример использования ContinueWith для выполнения работы в фоновом режиме и пользователем, потоки интерфейса.</span><span class="sxs-lookup"><span data-stu-id="c2738-358">The following is an example of using ContinueWith to run work both in the background and on the user interface threads.</span></span>  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-359"><see cref="T:System.Threading.CancellationTokenSource" />, создавший уже освобожденный токен.</span><span class="sxs-lookup"><span data-stu-id="c2738-359">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-360">Аргумент <paramref name="continuationAction" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-360">The <paramref name="continuationAction" /> argument is null.</span></span>  
  
<span data-ttu-id="c2738-361">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-361">-or-</span></span> 
<span data-ttu-id="c2738-362">Аргумент <paramref name="scheduler" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-362">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-363">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-363">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="c2738-364">Действие, которое необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-364">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-365">При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-365">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-366">Объект, который представляет данные, используемые действием продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-366">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-367">Токен <see cref="T:System.Threading.CancellationToken" />, который будет назначен новой задаче продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-367">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c2738-368">Параметры, определяющие запланированное время продолжения и его поведение.</span><span class="sxs-lookup"><span data-stu-id="c2738-368">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c2738-369">Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-369">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c2738-370">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который связывается с задачей продолжения для ее запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-370">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="c2738-371">Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии и маркер отмены и которое выполняется после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-371">Creates a continuation that receives caller-supplied state information and a cancellation token and that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-372">Продолжение выполняется на основе набора указанных условий и использует указанный планировщик.</span><span class="sxs-lookup"><span data-stu-id="c2738-372">The continuation executes based on a set of specified conditions and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="c2738-373">Новое продолжение <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-373">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-374">Возвращенный <xref:System.Threading.Tasks.Task> не планируется для выполнения до завершения текущей задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-374">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="c2738-375">Если указать критерии с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.</span><span class="sxs-lookup"><span data-stu-id="c2738-375">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-376">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-376">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-377">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-377">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-378">Предоставленный объект <see cref="T:System.Threading.CancellationToken" /> уже был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-378">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-379">Тип результата, созданного продолжением.</span><span class="sxs-lookup"><span data-stu-id="c2738-379">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c2738-380">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-380">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="c2738-381">При запуске делегата завершенная задача будет передана ему в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="c2738-381">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="c2738-382">Создает продолжение, которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task`1" /> и которое возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-382">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes and returns a value.</span></span></summary>
        <returns><span data-ttu-id="c2738-383">Новая задача продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-383">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-384">Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-384">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-385">Приведенный ниже показано, как использовать метод ContinueWith на значениях:</span><span class="sxs-lookup"><span data-stu-id="c2738-385">The following example shows how to use the ContinueWith method:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-386">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-386">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-387">Аргумент <paramref name="continuationFunction" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-387">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-388">Тип результата, созданного продолжением.</span><span class="sxs-lookup"><span data-stu-id="c2738-388">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c2738-389">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-389">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-390">При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-390">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-391">Объект, который представляет данные, используемые функцией продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-391">An object representing data to be used by the continuation function.</span></span></param>
        <summary><span data-ttu-id="c2738-392">Создает продолжение, которое получает предоставленные вызывающей стороной сведения о состоянии, выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" /> и возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-392">Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span></summary>
        <returns><span data-ttu-id="c2738-393">Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-393">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-394">Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-394">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-395">Аргумент <paramref name="continuationFunction" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-395">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-396">Тип результата, созданного продолжением.</span><span class="sxs-lookup"><span data-stu-id="c2738-396">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c2738-397">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-397">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-398">При запуске делегата завершенная задача будет передана ему в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="c2738-398">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-399">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет назначен новой задаче продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-399">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="c2738-400">Создает продолжение, которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" /> и возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-400">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="c2738-401">Продолжение получает маркер отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-401">The continuation receives a cancellation token.</span></span></summary>
        <returns><span data-ttu-id="c2738-402">Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-402">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-403">Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-403">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-404">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-404">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span>  
  
<span data-ttu-id="c2738-405">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-405">-or-</span></span> 
<span data-ttu-id="c2738-406"><see cref="T:System.Threading.CancellationTokenSource" />, создавший уже освобожденный токен.</span><span class="sxs-lookup"><span data-stu-id="c2738-406">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-407">Аргумент <paramref name="continuationFunction" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-407">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-408">Тип результата, созданного продолжением.</span><span class="sxs-lookup"><span data-stu-id="c2738-408">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c2738-409">Функция для запуска в соответствии с заданным условием в <paramref name="continuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-409">A function to run according to the condition specified in <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="c2738-410">При запуске делегата завершенная задача будет передана ему в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="c2738-410">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c2738-411">Параметры, определяющие запланированное время продолжения и его поведение.</span><span class="sxs-lookup"><span data-stu-id="c2738-411">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c2738-412">Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-412">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="c2738-413">Создает продолжение, которое выполняется в соответствии с заданными параметрами и которое возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-413">Creates a continuation that executes according to the specified continuation options and returns a value.</span></span></summary>
        <returns><span data-ttu-id="c2738-414">Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-414">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-415">Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-415">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="c2738-416">Если указать критерии продолжения с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.</span><span class="sxs-lookup"><span data-stu-id="c2738-416">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-417">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-417">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-418">Аргумент <paramref name="continuationFunction" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-418">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-419">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-419">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-420">Тип результата, созданного продолжением.</span><span class="sxs-lookup"><span data-stu-id="c2738-420">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c2738-421">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-421">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-422">При запуске делегата завершенная задача будет передана ему в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="c2738-422">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c2738-423">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-423">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c2738-424">Создает продолжение, которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" /> и возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-424">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="c2738-425">Продолжение использует указанный планировщик.</span><span class="sxs-lookup"><span data-stu-id="c2738-425">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="c2738-426">Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-426">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-427">Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-427">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-428">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-428">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-429">Аргумент <paramref name="continuationFunction" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-429">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
<span data-ttu-id="c2738-430">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-430">-or-</span></span> 
<span data-ttu-id="c2738-431">Аргумент <paramref name="scheduler" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-431">The <paramref name="scheduler" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-432">Тип результата, созданного продолжением.</span><span class="sxs-lookup"><span data-stu-id="c2738-432">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c2738-433">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-433">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-434">При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-434">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-435">Объект, который представляет данные, используемые функцией продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-435">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-436">Токен <see cref="T:System.Threading.CancellationToken" />, который будет назначен новой задаче продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-436">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="c2738-437">Создает продолжение, которое выполняется асинхронно после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" /> и возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-437">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="c2738-438">Продолжение получает предоставленные вызывающей стороной сведения и маркер отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-438">The continuation receives caller-supplied state information and a cancellation token.</span></span></summary>
        <returns><span data-ttu-id="c2738-439">Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-439">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-440">Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-440">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-441">Аргумент <paramref name="continuationFunction" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-441">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-442">Предоставленный объект <see cref="T:System.Threading.CancellationToken" /> уже был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-442">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-443">Тип результата, созданного продолжением.</span><span class="sxs-lookup"><span data-stu-id="c2738-443">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c2738-444">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-444">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-445">При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-445">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-446">Объект, который представляет данные, используемые функцией продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-446">An object representing data to be used by the continuation function.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c2738-447">Параметры, определяющие запланированное время продолжения и его поведение.</span><span class="sxs-lookup"><span data-stu-id="c2738-447">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c2738-448">Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-448">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="c2738-449">Создает продолжение, которое выполняется на основе указанных параметров продолжения задачи после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-449">Creates a continuation that executes based on the specified task continuation options when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-450">Продолжение получает предоставленные вызывающей стороной сведения.</span><span class="sxs-lookup"><span data-stu-id="c2738-450">The continuation receives caller-supplied state information.</span></span></summary>
        <returns><span data-ttu-id="c2738-451">Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-451">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-452">Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-452">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="c2738-453">Если указать критерии продолжения с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.</span><span class="sxs-lookup"><span data-stu-id="c2738-453">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-454">Аргумент <paramref name="continuationFunction" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-454">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-455">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-455">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-456">Тип результата, созданного продолжением.</span><span class="sxs-lookup"><span data-stu-id="c2738-456">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c2738-457">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-457">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span>  <span data-ttu-id="c2738-458">При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-458">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-459">Объект, который представляет данные, используемые функцией продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-459">An object representing data to be used by the continuation function.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c2738-460">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-460">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c2738-461">Создает продолжение, которое выполняется асинхронно после завершения выполнения целевой задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-461">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-462">Продолжение получает предоставленные вызывающей стороной сведения и использует указанный планировщик.</span><span class="sxs-lookup"><span data-stu-id="c2738-462">The continuation receives caller-supplied state information and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="c2738-463">Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-463">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-464">Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи, она завершается из-за выполнение успешно, завершение со сбоем из-за необработанного исключения или преждевременного из-за отмены ли.</span><span class="sxs-lookup"><span data-stu-id="c2738-464">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-465">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-465">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-466">Тип результата, созданного продолжением.</span><span class="sxs-lookup"><span data-stu-id="c2738-466">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c2738-467">Функция для запуска в соответствии с заданными параметрами <c>continuationOptions</c>.</span><span class="sxs-lookup"><span data-stu-id="c2738-467">A function to run according to the specified <c>continuationOptions.</c></span></span> <span data-ttu-id="c2738-468">При запуске делегата завершенная задача будет передана ему в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="c2738-468">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-469">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который будет назначен новой задаче продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-469">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c2738-470">Параметры, определяющие запланированное время продолжения и его поведение.</span><span class="sxs-lookup"><span data-stu-id="c2738-470">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c2738-471">Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-471">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c2738-472">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который следует связать с задачей продолжения и использовать для ее запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-472">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="c2738-473">Создает продолжение, которое выполняется в соответствии с заданными параметрами и которое возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-473">Creates a continuation that executes according to the specified continuation options and returns a value.</span></span> <span data-ttu-id="c2738-474">Продолжение получает маркер отмены и использует указанный планировщик.</span><span class="sxs-lookup"><span data-stu-id="c2738-474">The continuation is passed a cancellation token and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="c2738-475">Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-475">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-476">Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-476">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="c2738-477">Если указать критерии с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.</span><span class="sxs-lookup"><span data-stu-id="c2738-477">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-478">Приведенный ниже показано, как использовать метод ContinueWith с параметры продолжения:</span><span class="sxs-lookup"><span data-stu-id="c2738-478">The following example shows how to use the ContinueWith method with continuation options:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-479">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-479">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span>  
  
<span data-ttu-id="c2738-480">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-480">-or-</span></span> 
<span data-ttu-id="c2738-481"><see cref="T:System.Threading.CancellationTokenSource" />, создавший уже освобожденный токен.</span><span class="sxs-lookup"><span data-stu-id="c2738-481">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-482">Аргумент <paramref name="continuationFunction" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-482">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
<span data-ttu-id="c2738-483">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-483">-or-</span></span> 
<span data-ttu-id="c2738-484">Аргумент <paramref name="scheduler" /> имеет значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-484">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-485">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-485">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-486">Тип результата, созданного продолжением.</span><span class="sxs-lookup"><span data-stu-id="c2738-486">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="c2738-487">Функция, которую необходимо выполнить после завершения <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-487">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="c2738-488">При запуске делегату будут переданы в качестве аргументов завершенная задача и предоставленный вызывающей стороной объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-488">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="c2738-489">Объект, который представляет данные, используемые функцией продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-489">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-490">Токен <see cref="T:System.Threading.CancellationToken" />, который будет назначен новой задаче продолжения.</span><span class="sxs-lookup"><span data-stu-id="c2738-490">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="c2738-491">Параметры, определяющие запланированное время продолжения и его поведение.</span><span class="sxs-lookup"><span data-stu-id="c2738-491">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="c2738-492">Включаются критерии, такие как <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, а также параметры выполнения, например <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-492">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="c2738-493">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, который связывается с задачей продолжения для ее запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-493">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="c2738-494">Создает продолжение, которое выполняется на основе указанных параметров продолжения задачи после завершения целевой задачи <see cref="T:System.Threading.Tasks.Task" /> и которое возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-494">Creates a continuation that executes based on the specified task continuation options when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="c2738-495">Продолжение получает предоставленные вызывающей стороной сведения и маркер отмены, а также использует указанный планировщик.</span><span class="sxs-lookup"><span data-stu-id="c2738-495">The continuation receives caller-supplied state information and a cancellation token and uses the specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="c2738-496">Новое продолжение <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-496">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-497">Возвращенный <xref:System.Threading.Tasks.Task%601> не планируется для выполнения до завершения текущей задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-497">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="c2738-498">Если указать критерии с помощью `continuationOptions` параметра не выполняются, задача продолжения будет отменена а не запланировано.</span><span class="sxs-lookup"><span data-stu-id="c2738-498">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-499">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-499">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-500">Аргумент <paramref name="continuationOptions" /> задает недопустимое значение для <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-500">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-501">Предоставленный объект <see cref="T:System.Threading.CancellationToken" /> уже был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-501">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-502">Возвращает объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, используемый для создания данной задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-502">Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to create this task.</span></span></summary>
        <value><span data-ttu-id="c2738-503">Объект <see cref="T:System.Threading.Tasks.TaskCreationOptions" />, используемый для создания данной задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-503">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to create this task.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-504">Возвращает идентификатор выполняющейся в настоящее время задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-504">Returns the ID of the currently executing <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <value><span data-ttu-id="c2738-505">Целое число, присвоенное системой выполняемой в настоящее время задаче.</span><span class="sxs-lookup"><span data-stu-id="c2738-505">An integer that was assigned by the system to the currently-executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-506"><xref:System.Threading.Tasks.Task.CurrentId%2A> — `static` (`Shared` в Visual Basic) свойство, которое позволяет получить идентификатор текущей выполняемой задачи из кода, который выполняется задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-506"><xref:System.Threading.Tasks.Task.CurrentId%2A> is a `static` (`Shared` in Visual Basic) property that is used to get the identifier of the currently executing task from the code that the task is executing.</span></span> <span data-ttu-id="c2738-507">Он отличается от <xref:System.Threading.Tasks.Task.Id%2A> свойство, которое возвращает идентификатор конкретного <xref:System.Threading.Tasks.Task> экземпляра.</span><span class="sxs-lookup"><span data-stu-id="c2738-507">It differs from the <xref:System.Threading.Tasks.Task.Id%2A> property, which returns the identifier of a particular <xref:System.Threading.Tasks.Task> instance.</span></span> <span data-ttu-id="c2738-508">При попытке получить <xref:System.Threading.Tasks.Task.CurrentId%2A> свойство возвращает значение из вне кода, выполняющего задачу `null`.</span><span class="sxs-lookup"><span data-stu-id="c2738-508">If you attempt to retrieve the <xref:System.Threading.Tasks.Task.CurrentId%2A> value from outside the code that a task is executing, the property returns `null`.</span></span>  
  
 <span data-ttu-id="c2738-509">Обратите внимание, что несмотря на то, что конфликты очень редки, задача не гарантируется, что идентификаторы должны быть уникальными.</span><span class="sxs-lookup"><span data-stu-id="c2738-509">Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-510">Создает задачу, которая будет выполнена после некоторой временной задержки.</span><span class="sxs-lookup"><span data-stu-id="c2738-510">Creates a task that will complete after a time delay.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay"><span data-ttu-id="c2738-511">Время в миллисекундах, в течение которого ожидается завершение возвращаемой задачи, или -1 для неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-511">The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c2738-512">Создает задачу, которая завершается через заданное количество миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="c2738-512">Creates a task that completes after a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="c2738-513">Задача, представляющая временную задержку.</span><span class="sxs-lookup"><span data-stu-id="c2738-513">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-514"><xref:System.Threading.Tasks.Task.Delay%2A> Метод обычно используется для задержка операции всех или части задачи на указанный интервал времени.</span><span class="sxs-lookup"><span data-stu-id="c2738-514">The <xref:System.Threading.Tasks.Task.Delay%2A> method is typically used to delay the operation of all or part of a task for a specified time interval.</span></span> <span data-ttu-id="c2738-515">Чаще всего вводится время задержки:</span><span class="sxs-lookup"><span data-stu-id="c2738-515">Most commonly, the time delay is introduced:</span></span>  
  
-   <span data-ttu-id="c2738-516">AT показано начало задачи, как в примере ниже.</span><span class="sxs-lookup"><span data-stu-id="c2738-516">At the beginning of the task, as the following example shows.</span></span>  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   <span data-ttu-id="c2738-517">Некоторое время, пока выполняется задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-517">Sometime while the task is executing.</span></span> <span data-ttu-id="c2738-518">В этом случае вызов <xref:System.Threading.Tasks.Task.Delay%2A> метод выполняется как дочерняя задача в задаче, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="c2738-518">In this case, the call to the <xref:System.Threading.Tasks.Task.Delay%2A> method executes as a child task within a task, as the following example shows.</span></span> <span data-ttu-id="c2738-519">Обратите внимание, что с момента задачи, который вызывает <xref:System.Threading.Tasks.Task.Delay%2A> метод выполняется асинхронно, в родительскую задачу, дождитесь ее завершения с помощью `await` ключевое слово.</span><span class="sxs-lookup"><span data-stu-id="c2738-519">Note that since the task that calls the <xref:System.Threading.Tasks.Task.Delay%2A> method executes asynchronously, the parent task must wait for it to complete by using the `await` keyword.</span></span>  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 <span data-ttu-id="c2738-520">После указанного времени задержки, задача завершается в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние.</span><span class="sxs-lookup"><span data-stu-id="c2738-520">After the specified time delay, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="c2738-521">Этот метод зависит от системных часов.</span><span class="sxs-lookup"><span data-stu-id="c2738-521">This method depends on the system clock.</span></span> <span data-ttu-id="c2738-522">Это означает, что время задержки будет примерно равны разрешение системных часов Если `millisecondsDelay` аргумент меньше, чем разрешение системных часов, который составляет приблизительно 15 миллисекунд в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="c2738-522">This means that the time delay will approximately equal the resolution of the system clock if the `millisecondsDelay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-523">В следующем примере показано простое использование <xref:System.Threading.Tasks.Task.Delay%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-523">The following example shows a simple use of the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-524">Аргумент <paramref name="millisecondsDelay" /> меньше –1.</span><span class="sxs-lookup"><span data-stu-id="c2738-524">The <paramref name="millisecondsDelay" /> argument is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay"><span data-ttu-id="c2738-525">Время, в течение которого ожидается завершение возвращаемой задачи, или <see langword="TimeSpan.FromMilliseconds(-1)" /> для неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-525">The time span to wait before completing the returned task, or <see langword="TimeSpan.FromMilliseconds(-1)" /> to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c2738-526">Создает задачу, которая завершается через заданное время.</span><span class="sxs-lookup"><span data-stu-id="c2738-526">Creates a task that completes after a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="c2738-527">Задача, представляющая временную задержку.</span><span class="sxs-lookup"><span data-stu-id="c2738-527">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-528">После указанного времени задержки, задача завершается в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние.</span><span class="sxs-lookup"><span data-stu-id="c2738-528">After the specified time delay, the task is completed in <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="c2738-529">Сценарии использования и Дополнительные примеры см. в документации по <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> перегрузки.</span><span class="sxs-lookup"><span data-stu-id="c2738-529">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="c2738-530">Этот метод зависит от системных часов.</span><span class="sxs-lookup"><span data-stu-id="c2738-530">This method depends on the system clock.</span></span> <span data-ttu-id="c2738-531">Это означает, что время задержки будет примерно равны разрешение системных часов Если `delay` аргумент меньше, чем разрешение системных часов, который составляет приблизительно 15 миллисекунд в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="c2738-531">This means that the time delay will approximately equal the resolution of the system clock if the `delay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-532">В следующем примере показано простое использование <xref:System.Threading.Tasks.Task.Delay%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-532">The following example shows a simple use of the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-533"><paramref name="delay" /> представляет отрицательный интервал времени, отличный от <see langword="TimeSpan.FromMillseconds(-1)" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-533"><paramref name="delay" /> represents a negative time interval other than <see langword="TimeSpan.FromMillseconds(-1)" />.</span></span>  
  
<span data-ttu-id="c2738-534">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-534">-or-</span></span> 
<span data-ttu-id="c2738-535">Свойство <see cref="P:System.TimeSpan.TotalMilliseconds" /> аргумента <paramref name="delay" /> больше, чем <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-535">The <paramref name="delay" /> argument's <see cref="P:System.TimeSpan.TotalMilliseconds" /> property is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay"><span data-ttu-id="c2738-536">Время в миллисекундах, в течение которого ожидается завершение возвращаемой задачи, или -1 для неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-536">The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-537">Токен отмены, который нужно контролировать во время ожидания выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-537">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="c2738-538">Создает отменяемую задачу, которая завершается через заданное количество миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="c2738-538">Creates a cancellable task that completes after a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="c2738-539">Задача, представляющая временную задержку.</span><span class="sxs-lookup"><span data-stu-id="c2738-539">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-540">Если токен отмены получает сигнал до указанного времени задержки, <xref:System.Threading.Tasks.TaskCanceledException> результаты исключения, а задача завершается в <xref:System.Threading.Tasks.TaskStatus.Canceled> состояние.</span><span class="sxs-lookup"><span data-stu-id="c2738-540">If the cancellation token is signaled before the specified time delay, a <xref:System.Threading.Tasks.TaskCanceledException> exception results, and the task is completed in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  <span data-ttu-id="c2738-541">В противном случае задача завершается в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние после истечения указанного времени задержки.</span><span class="sxs-lookup"><span data-stu-id="c2738-541">Otherwise, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state once the specified time delay has elapsed.</span></span>  
  
 <span data-ttu-id="c2738-542">Сценарии использования и Дополнительные примеры см. в документации по <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> перегрузки.</span><span class="sxs-lookup"><span data-stu-id="c2738-542">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="c2738-543">Этот метод зависит от системных часов.</span><span class="sxs-lookup"><span data-stu-id="c2738-543">This method depends on the system clock.</span></span> <span data-ttu-id="c2738-544">Это означает, что время задержки будет примерно равны разрешение системных часов Если `millisecondsDelay` аргумент меньше, чем разрешение системных часов, который составляет приблизительно 15 миллисекунд в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="c2738-544">This means that the time delay will approximately equal the resolution of the system clock if the `millisecondsDelay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-545">Следующий пример запускает задачу, которая включает вызов <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> метод с одной секунда.</span><span class="sxs-lookup"><span data-stu-id="c2738-545">The following example launches a task that includes a call to the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> method with a one second delay.</span></span> <span data-ttu-id="c2738-546">До истечения интервала задержки, токена отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-546">Before the delay interval elapses, the token is cancelled.</span></span> <span data-ttu-id="c2738-547">Выходные данные примера показано, что, в результате, <xref:System.Threading.Tasks.TaskCanceledException> возникает исключение и задач <xref:System.Threading.Tasks.Task.Status%2A> свойству <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span><span class="sxs-lookup"><span data-stu-id="c2738-547">The output from the example shows that, as a result, a <xref:System.Threading.Tasks.TaskCanceledException> is thrown, and the tasks' <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-548">Аргумент <paramref name="millisecondsDelay" /> меньше –1.</span><span class="sxs-lookup"><span data-stu-id="c2738-548">The <paramref name="millisecondsDelay" /> argument is less than -1.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="c2738-549">Задача была отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-549">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-550">Предоставленный объект <paramref name="cancellationToken" /> уже был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-550">The provided <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay"><span data-ttu-id="c2738-551">Время, в течение которого ожидается завершение возвращаемой задачи, или <see langword="TimeSpan.FromMilliseconds(-1)" /> для неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-551">The time span to wait before completing the returned task, or <see langword="TimeSpan.FromMilliseconds(-1)" /> to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-552">Токен отмены, который нужно контролировать во время ожидания выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-552">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="c2738-553">Создает отменяемую задачу, которая завершается через заданное время.</span><span class="sxs-lookup"><span data-stu-id="c2738-553">Creates a cancellable task that completes after a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="c2738-554">Задача, представляющая временную задержку.</span><span class="sxs-lookup"><span data-stu-id="c2738-554">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-555">Если токен отмены получает сигнал до указанного времени задержки, <xref:System.Threading.Tasks.TaskCanceledException> результаты исключения, а задача завершается в <xref:System.Threading.Tasks.TaskStatus.Canceled> состояние.</span><span class="sxs-lookup"><span data-stu-id="c2738-555">If the cancellation token is signaled before the specified time delay, a <xref:System.Threading.Tasks.TaskCanceledException> exception results, and the task is completed in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  <span data-ttu-id="c2738-556">В противном случае задача завершается в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние после истечения указанного времени задержки.</span><span class="sxs-lookup"><span data-stu-id="c2738-556">Otherwise, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state once the specified time delay has elapsed.</span></span>  
  
 <span data-ttu-id="c2738-557">Сценарии использования и Дополнительные примеры см. в документации по <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> перегрузки.</span><span class="sxs-lookup"><span data-stu-id="c2738-557">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="c2738-558">Этот метод зависит от системных часов.</span><span class="sxs-lookup"><span data-stu-id="c2738-558">This method depends on the system clock.</span></span> <span data-ttu-id="c2738-559">Это означает, что время задержки будет примерно равны разрешение системных часов Если `delay` аргумент меньше, чем разрешение системных часов, который составляет приблизительно 15 миллисекунд в системах Windows.</span><span class="sxs-lookup"><span data-stu-id="c2738-559">This means that the time delay will approximately equal the resolution of the system clock if the `delay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-560">Следующий пример запускает задачу, которая включает вызов <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> метод с 1,5 секунда.</span><span class="sxs-lookup"><span data-stu-id="c2738-560">The following example launches a task that includes a call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method with a 1.5 second delay.</span></span> <span data-ttu-id="c2738-561">До истечения интервала задержки, токена отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-561">Before the delay interval elapses, the token is cancelled.</span></span> <span data-ttu-id="c2738-562">Выходные данные примера показано, что, в результате, <xref:System.Threading.Tasks.TaskCanceledException> возникает исключение и задач <xref:System.Threading.Tasks.Task.Status%2A> свойству <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span><span class="sxs-lookup"><span data-stu-id="c2738-562">The output from the example shows that, as a result, a <xref:System.Threading.Tasks.TaskCanceledException> is thrown, and the tasks' <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 <span data-ttu-id="c2738-563">Обратите внимание, что в этом примере включает потенциальный конфликт: она зависит от задачи асинхронно выполнение задержки, когда токен отменяется.</span><span class="sxs-lookup"><span data-stu-id="c2738-563">Note that this example includes a potential race condition: it depends on the task asynchronously executing the delay when the token is cancelled.</span></span> <span data-ttu-id="c2738-564">Несмотря на то, что задержка 1,5 секунды из вызова <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> метод допущения, скорее всего, тем не менее возможно, вызов <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> метод может вернуть значение до токена отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-564">Although the 1.5 second delay from the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method makes that assumption likely, it is nevertheless possible that the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method could return before the token is cancelled.</span></span> <span data-ttu-id="c2738-565">В этом случае пример выводит следующие результаты:</span><span class="sxs-lookup"><span data-stu-id="c2738-565">In that case, the example produces the following output:</span></span>  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-566"><paramref name="delay" /> представляет отрицательный интервал времени, отличный от <see langword="TimeSpan.FromMillseconds(-1)" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-566"><paramref name="delay" /> represents a negative time interval other than <see langword="TimeSpan.FromMillseconds(-1)" />.</span></span>  
  
<span data-ttu-id="c2738-567">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-567">-or-</span></span> 
<span data-ttu-id="c2738-568">Свойство <see cref="P:System.TimeSpan.TotalMilliseconds" /> аргумента <paramref name="delay" /> больше, чем <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-568">The <paramref name="delay" /> argument's <see cref="P:System.TimeSpan.TotalMilliseconds" /> property is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="c2738-569">Задача была отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-569">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-570">Предоставленный объект <paramref name="cancellationToken" /> уже был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-570">The provided <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-571">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-571">Releases all resources used by the current instance of the <see cref="T:System.Threading.Tasks.Task" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2738-572">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-572">Releases all resources used by the current instance of the <see cref="T:System.Threading.Tasks.Task" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-573"><xref:System.Threading.Tasks.Task> Класс реализует <xref:System.IDisposable> интерфейс, так как внутренне он использует ресурсы, которые также реализуют <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="c2738-573">The <xref:System.Threading.Tasks.Task> class implements the <xref:System.IDisposable> interface because internally it uses resources that also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="c2738-574">Тем не менее особенно в том случае, если ваше приложение предназначено [!INCLUDE[net_v45](~/includes/net-v45-md.md)] или более поздней версии, нет необходимости вызывать <xref:System.Threading.Tasks.Task.Dispose%2A> Если производительность или масштабируемость тестирование показывает, что, на основе использования шаблонов, удалив задач будет улучшена производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="c2738-574">However, particularly if your app targets the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or later, there is no need to call <xref:System.Threading.Tasks.Task.Dispose%2A> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</span></span> <span data-ttu-id="c2738-575">Дополнительные сведения см. в разделе [нужно избавиться от задач?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) в параллельному программированию в блоге .NET.</span><span class="sxs-lookup"><span data-stu-id="c2738-575">For more information, see [Do I need to dispose of Tasks?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c2738-576">Задача не находится в одном из окончательных состояний: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> или <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-576">The task is not in one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="c2738-577">Логическое значение, указывающее, вызывается ли данный метод из-за вызова метода <see cref="M:System.Threading.Tasks.Task.Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-577">A Boolean value that indicates whether this method is being called due to a call to <see cref="M:System.Threading.Tasks.Task.Dispose" />.</span></span></param>
        <summary><span data-ttu-id="c2738-578">Удаляет задачу <see cref="T:System.Threading.Tasks.Task" />, освобождая все используемые ею неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="c2738-578">Disposes the <see cref="T:System.Threading.Tasks.Task" />, releasing all of its unmanaged resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-579"><xref:System.Threading.Tasks.Task> Класс реализует <xref:System.IDisposable> интерфейс, так как внутренне он использует ресурсы, которые также реализуют <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="c2738-579">The <xref:System.Threading.Tasks.Task> class implements the <xref:System.IDisposable> interface because internally it uses resources that also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="c2738-580">Тем не менее особенно в том случае, если ваше приложение предназначено [!INCLUDE[net_v45](~/includes/net-v45-md.md)] или более поздней версии, нет необходимости вызывать <xref:System.Threading.Tasks.Task.Dispose%2A> Если производительность или масштабируемость тестирование показывает, что, на основе использования шаблонов, удалив задач будет улучшена производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="c2738-580">However, particularly if your app targets the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or later, there is no need to call <xref:System.Threading.Tasks.Task.Dispose%2A> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</span></span> <span data-ttu-id="c2738-581">Дополнительные сведения см. в разделе [нужно избавиться от задач?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) в параллельному программированию в блоге .NET.</span><span class="sxs-lookup"><span data-stu-id="c2738-581">For more information, see [Do I need to dispose of Tasks?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c2738-582">Задача не находится в одном из окончательных состояний: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> или <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-582">The task is not in one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span></span></exception>
        <threadsafe><span data-ttu-id="c2738-583">В отличие от большинства элементов <see cref="T:System.Threading.Tasks.Task" /> класса, этот метод не является потокобезопасным.</span><span class="sxs-lookup"><span data-stu-id="c2738-583">Unlike most of the members of the <see cref="T:System.Threading.Tasks.Task" /> class, this method is not thread-safe.</span></span></threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-584">Получает объект <see cref="T:System.AggregateException" />, который привел к преждевременному завершению задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-584">Gets the <see cref="T:System.AggregateException" /> that caused the <see cref="T:System.Threading.Tasks.Task" /> to end prematurely.</span></span> <span data-ttu-id="c2738-585">Если задача <see cref="T:System.Threading.Tasks.Task" /> завершилась успешно или еще не создала ни одного исключения, возвращает значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-585">If the <see cref="T:System.Threading.Tasks.Task" /> completed successfully or has not yet thrown any exceptions, this will return <see langword="null" />.</span></span></summary>
        <value><span data-ttu-id="c2738-586">Объект <see cref="T:System.AggregateException" />, который привел к преждевременному завершению задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-586">The <see cref="T:System.AggregateException" /> that caused the <see cref="T:System.Threading.Tasks.Task" /> to end prematurely.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-587">Задачи, которые вызывает необработанные исключения хранения результирующее исключение и передать их в оболочку <xref:System.AggregateException> в вызовах <xref:System.Threading.Tasks.Task.Wait%2A> или в доступе к <xref:System.Threading.Tasks.Task.Exception%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="c2738-587">Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <xref:System.AggregateException> in calls to <xref:System.Threading.Tasks.Task.Wait%2A> or in accesses to the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span> <span data-ttu-id="c2738-588">Любые исключения, не наблюдается, когда экземпляр задачи удаляется сборщиком мусора распространяется на поток метода завершения.</span><span class="sxs-lookup"><span data-stu-id="c2738-588">Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread.</span></span> <span data-ttu-id="c2738-589">Дополнительные сведения и пример см. в разделе [обработка исключений (библиотека параллельных задач)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-589">For more information and an example, see [Exception Handling (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-590">Предоставляет доступ к фабричным методам для создания и настройки экземпляров <see cref="T:System.Threading.Tasks.Task" /> и <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-590">Provides access to factory methods for creating and configuring <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> instances.</span></span></summary>
        <value><span data-ttu-id="c2738-591">Объект фабрики, который может создавать разнообразные объекты <see cref="T:System.Threading.Tasks.Task" /> и <see cref="T:System.Threading.Tasks.Task`1" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-591">A factory object that can create a variety of <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-592">Это свойство возвращает экземпляр по умолчанию <xref:System.Threading.Tasks.TaskFactory> класс, созданный при вызове без параметров идентичный <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> конструктор.</span><span class="sxs-lookup"><span data-stu-id="c2738-592">This property returns a default instance of the <xref:System.Threading.Tasks.TaskFactory> class that is identical to the one created by calling the parameterless <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="c2738-593">Он имеет следующие значения свойств:</span><span class="sxs-lookup"><span data-stu-id="c2738-593">It has the following property values:</span></span>  
  
|<span data-ttu-id="c2738-594">Свойство.</span><span class="sxs-lookup"><span data-stu-id="c2738-594">Property</span></span>|<span data-ttu-id="c2738-595">Значение</span><span class="sxs-lookup"><span data-stu-id="c2738-595">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|<span data-ttu-id="c2738-596">`null`, или <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="c2738-596">`null`, or <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span></span>|  
  
 <span data-ttu-id="c2738-597">Чаще всего это свойство используется для создания и запуска новой задачи в рамках одного вызова <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-597">The most common use of this property is to create and start a new task in a single call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c2738-598">Начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> метод предоставляет самый простой способ создать <xref:System.Threading.Tasks.Task> объекта значения конфигурации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="c2738-598">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method provides the easiest way to create a <xref:System.Threading.Tasks.Task> object with default configuration values.</span></span>  
  
 <span data-ttu-id="c2738-599">В следующем примере используется статический <xref:System.Threading.Tasks.Task.Factory%2A> свойства два вызова <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-599">The following example uses the static <xref:System.Threading.Tasks.Task.Factory%2A> property to make two calls to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-600">Первый заполняет массив, содержащий имена файлов в каталоге Мои документы пользователя, пока второй заполняет массив имен подкаталогов каталога Мои документы пользователя.</span><span class="sxs-lookup"><span data-stu-id="c2738-600">The first populates an array with the names of files in the user's MyDocuments directory, while the second populates an array with the names of subdirectories of the user's MyDocuments directory.</span></span> <span data-ttu-id="c2738-601">Затем он вызывает <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> метод, который отображает сведения о количестве файлов и каталогов в двух массивах, после выполнения первых двух задачах.</span><span class="sxs-lookup"><span data-stu-id="c2738-601">It then calls the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> method, which displays information about the number of files and directories in the two arrays after the first two tasks have completed execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="c2738-602">Маркер отмены, с которым завершается задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-602">The cancellation token with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="c2738-603">Создает задачу <see cref="T:System.Threading.Tasks.Task" />, которая завершилась из-за отмены с помощью указанного маркера отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-603">Creates a <see cref="T:System.Threading.Tasks.Task" /> that's completed due to cancellation with a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="c2738-604">Отменяемая задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-604">The canceled task.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-605">Не запрошена отмена для параметра <paramref name="cancellationToken" />; его свойство <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-605">Cancellation has not been requested for <paramref name="cancellationToken" />; its <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-606">Тип результата, возвращенного задачей.</span><span class="sxs-lookup"><span data-stu-id="c2738-606">The type of the result returned by the task.</span></span></typeparam>
        <param name="cancellationToken"><span data-ttu-id="c2738-607">Маркер отмены, с которым завершается задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-607">The cancellation token with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="c2738-608">Создает задачу <see cref="T:System.Threading.Tasks.Task`1" />, которая завершилась из-за отмены с помощью указанного маркера отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-608">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed due to cancellation with a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="c2738-609">Отменяемая задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-609">The canceled task.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-610">Не запрошена отмена для параметра <paramref name="cancellationToken" />; его свойство <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> имеет значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-610">Cancellation has not been requested for <paramref name="cancellationToken" />; its <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="exception"><span data-ttu-id="c2738-611">Исключение, с которым завершается задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-611">The exception with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="c2738-612">Создает задачу <see cref="T:System.Threading.Tasks.Task" />, которая завершилась с указанным исключением.</span><span class="sxs-lookup"><span data-stu-id="c2738-612">Creates a <see cref="T:System.Threading.Tasks.Task" /> that has completed with a specified exception.</span></span></summary>
        <returns><span data-ttu-id="c2738-613">Задача, завершившаяся сбоем.</span><span class="sxs-lookup"><span data-stu-id="c2738-613">The faulted task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-614">Этот метод создает <xref:System.Threading.Tasks.Task> которого <xref:System.Threading.Tasks.Task.Status%2A> свойство <xref:System.Threading.Tasks.TaskStatus.Faulted> и которого <xref:System.Threading.Tasks.Task.Exception%2A> свойство содержит `exception`.</span><span class="sxs-lookup"><span data-stu-id="c2738-614">This method creates a <xref:System.Threading.Tasks.Task> object whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.Faulted> and whose <xref:System.Threading.Tasks.Task.Exception%2A> property contains `exception`.</span></span> <span data-ttu-id="c2738-615">Метод обычно используется, когда вы немедленно узнаете, что работы, выполняемой задачей будет выдано исключение перед выполнением более длинный путь кода.</span><span class="sxs-lookup"><span data-stu-id="c2738-615">The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</span></span> <span data-ttu-id="c2738-616">Например, см. в разделе <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> перегрузки.</span><span class="sxs-lookup"><span data-stu-id="c2738-616">For an example, see the <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-617">Тип результата, возвращенного задачей.</span><span class="sxs-lookup"><span data-stu-id="c2738-617">The type of the result returned by the task.</span></span></typeparam>
        <param name="exception"><span data-ttu-id="c2738-618">Исключение, с которым завершается задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-618">The exception with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="c2738-619">Создает задачу <see cref="T:System.Threading.Tasks.Task`1" />, которая завершилась с указанным исключением.</span><span class="sxs-lookup"><span data-stu-id="c2738-619">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed with a specified exception.</span></span></summary>
        <returns><span data-ttu-id="c2738-620">Задача, завершившаяся сбоем.</span><span class="sxs-lookup"><span data-stu-id="c2738-620">The faulted task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-621">Этот метод создает <xref:System.Threading.Tasks.Task%601> которого <xref:System.Threading.Tasks.Task.Status%2A> свойство <xref:System.Threading.Tasks.TaskStatus.Faulted> и которого <xref:System.Threading.Tasks.Task.Exception%2A> свойство содержит `exception`.</span><span class="sxs-lookup"><span data-stu-id="c2738-621">This method creates a <xref:System.Threading.Tasks.Task%601> object whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.Faulted> and whose <xref:System.Threading.Tasks.Task.Exception%2A> property contains `exception`.</span></span> <span data-ttu-id="c2738-622">Метод обычно используется, когда вы немедленно узнаете, что работы, выполняемой задачей будет выдано исключение перед выполнением более длинный путь кода.</span><span class="sxs-lookup"><span data-stu-id="c2738-622">The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</span></span> <span data-ttu-id="c2738-623">Иллюстрация приведена в примере.</span><span class="sxs-lookup"><span data-stu-id="c2738-623">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-624">Следующий пример — программа командной строки, которая вычисляет число байтов в файлах в каждом каталоге, имя которого передано в качестве аргумента командной строки.</span><span class="sxs-lookup"><span data-stu-id="c2738-624">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="c2738-625">Вместо того, чтобы выполнение более длинный путь кода, который создает экземпляры <xref:System.IO.FileInfo> объекта и возвращает значение его <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> свойство для каждого файла в каталоге, в примере просто вызывается <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> метод для создания задачи, если определенный вложенный каталог не существует.</span><span class="sxs-lookup"><span data-stu-id="c2738-625">Rather than executing a longer code path that instantiates a <xref:System.IO.FileInfo> object and retrieves the value of its <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> property for each file in the directory, the example simply calls the <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> method to create a faulted task if a particular subdirectory does not exist.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-626">Тип результата, возвращенного задачей.</span><span class="sxs-lookup"><span data-stu-id="c2738-626">The type of the result returned by the task.</span></span></typeparam>
        <param name="result"><span data-ttu-id="c2738-627">Результат, сохраняемый в завершенную задачу.</span><span class="sxs-lookup"><span data-stu-id="c2738-627">The result to store into the completed task.</span></span></param>
        <summary><span data-ttu-id="c2738-628">Создает <see cref="T:System.Threading.Tasks.Task`1" />, которая завершается удачно с указанным результатом.</span><span class="sxs-lookup"><span data-stu-id="c2738-628">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed successfully with the specified result.</span></span></summary>
        <returns><span data-ttu-id="c2738-629">Успешно завершенная задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-629">The successfully completed task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-630">Этот метод создает <xref:System.Threading.Tasks.Task%601> которого <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> свойство `result` и которого <xref:System.Threading.Tasks.Task.Status%2A> свойство <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span><span class="sxs-lookup"><span data-stu-id="c2738-630">This method creates a <xref:System.Threading.Tasks.Task%601> object whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is `result` and whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span></span> <span data-ttu-id="c2738-631">Метод обычно используется, если возвращаемое значение задачи сразу же известно, выполняя более длинный путь кода.</span><span class="sxs-lookup"><span data-stu-id="c2738-631">The method is commonly used when the return value of a task is immediately known without executing a longer code path.</span></span> <span data-ttu-id="c2738-632">Иллюстрация приведена в примере.</span><span class="sxs-lookup"><span data-stu-id="c2738-632">The example provides an illustration.</span></span>  
  
 <span data-ttu-id="c2738-633">Чтобы создать объект задачи, которая не возвращает значение, получить объект задачи из <xref:System.Threading.Tasks.Task.CompletedTask%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="c2738-633">To create a Task object that does not return a value, retrieve the Task object from the <xref:System.Threading.Tasks.Task.CompletedTask%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-634">Следующий пример — программа командной строки, которая вычисляет число байтов в файлах в каждом каталоге, имя которого передано в качестве аргумента командной строки.</span><span class="sxs-lookup"><span data-stu-id="c2738-634">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="c2738-635">Вместо того, чтобы выполнение более длинный путь кода, который создает экземпляры <xref:System.IO.FileStream> объекта и возвращает значение его <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> свойство для каждого файла в каталоге, в примере просто вызывается <xref:System.Threading.Tasks.Task.FromResult%2A> метод для создания задачи которого <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> свойство равно нулю (0), если каталог не содержит файлов.</span><span class="sxs-lookup"><span data-stu-id="c2738-635">Rather than executing a longer code path that instantiates a <xref:System.IO.FileStream> object and retrieves the value of its <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> property for each file in the directory, the example simply calls the <xref:System.Threading.Tasks.Task.FromResult%2A> method to create a task whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is zero (0) if a directory has no files.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2738-636">Получает объект типа awaiter, используемый для данного объекта <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-636">Gets an awaiter used to await this <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <returns><span data-ttu-id="c2738-637">Экземпляр объекта типа awaiter.</span><span class="sxs-lookup"><span data-stu-id="c2738-637">An awaiter instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-638">Этот метод предназначен для внутреннего использования компиляторами, а не для использования в прикладном коде.</span><span class="sxs-lookup"><span data-stu-id="c2738-638">This method is intended for compiler use rather than for use in application code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-639">Возвращает идентификатор указанного экземпляра <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-639">Gets an ID for this <see cref="T:System.Threading.Tasks.Task" /> instance.</span></span></summary>
        <value><span data-ttu-id="c2738-640">Идентификатор, присвоенный системой данному экземпляру <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-640">The identifier that is assigned by the system to this <see cref="T:System.Threading.Tasks.Task" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-641">Идентификаторы задач назначаются по запросу и не обязательно представляют порядок, в какую задачу создаются экземпляры.</span><span class="sxs-lookup"><span data-stu-id="c2738-641">Task IDs are assigned on-demand and do not necessarily represent the order in which task instances are created.</span></span> <span data-ttu-id="c2738-642">Обратите внимание, что несмотря на то, что конфликты очень редки, задача не гарантируется, что идентификаторы должны быть уникальными.</span><span class="sxs-lookup"><span data-stu-id="c2738-642">Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</span></span>  
  
 <span data-ttu-id="c2738-643">Чтобы получить идентификатор задачи текущей выполняемой задачи из кода эта задача выполняется, используйте <xref:System.Threading.Tasks.Task.CurrentId%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="c2738-643">To get the task ID of the currently executing task from within code that task is executing, use the <xref:System.Threading.Tasks.Task.CurrentId%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-644">Получает значение, указывающее, завершилось ли выполнение данного экземпляра <see cref="T:System.Threading.Tasks.Task" /> из-за отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-644">Gets whether this <see cref="T:System.Threading.Tasks.Task" /> instance has completed execution due to being canceled.</span></span></summary>
        <value><span data-ttu-id="c2738-645">Значение <see langword="true" />, если задача была завершена из-за отмены; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-645"><see langword="true" /> if the task has completed due to being canceled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-646">Объект <xref:System.Threading.Tasks.Task> завершится в <xref:System.Threading.Tasks.TaskStatus.Canceled> состояния выполняется любое из следующих условий:</span><span class="sxs-lookup"><span data-stu-id="c2738-646">A <xref:System.Threading.Tasks.Task> will complete in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="c2738-647">Его <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> был помечен для отмены до начала выполнения, задачи</span><span class="sxs-lookup"><span data-stu-id="c2738-647">Its <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> was marked for cancellation before the task started executing,</span></span>  
  
-   <span data-ttu-id="c2738-648">Задача приняла запрос на отмену на уже сигнальное <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> , выдав <xref:System.OperationCanceledException> предпоследнюю же <xref:System.Threading.CancellationToken>.</span><span class="sxs-lookup"><span data-stu-id="c2738-648">The task acknowledged the cancellation request on its already signaled <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> by throwing an <xref:System.OperationCanceledException> that bears the same <xref:System.Threading.CancellationToken>.</span></span>  
  
-   <span data-ttu-id="c2738-649">Задача приняла запрос на отмену на уже сигнальное <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> путем вызова <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> метод <xref:System.Threading.CancellationToken>.</span><span class="sxs-lookup"><span data-stu-id="c2738-649">The task acknowledged the cancellation request on its already signaled <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> by calling the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> method on the <xref:System.Threading.CancellationToken>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c2738-650">Получение значения <xref:System.Threading.Tasks.Task.IsCanceled%2A> свойство не блокирует вызывающий поток до завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-650">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsCanceled%2A> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-651">Получает значение, указывающее, завершена ли задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-651">Gets a value that indicates whether the task has completed.</span></span></summary>
        <value><span data-ttu-id="c2738-652"><see langword="true" /> Если задача была завершена (то есть задача находится в одном из трех конечных состояний: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, или <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />); в противном случае <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-652"><see langword="true" /> if the task has completed (that is, the task is in one of the three final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />); otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="c2738-653">Получение значения <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> свойство не блокирует вызывающий поток до завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-653">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-654">Получает значение, указывающее, завершилась ли задача <see cref="T:System.Threading.Tasks.Task" /> из-за необработанного исключения.</span><span class="sxs-lookup"><span data-stu-id="c2738-654">Gets whether the <see cref="T:System.Threading.Tasks.Task" /> completed due to an unhandled exception.</span></span></summary>
        <value><span data-ttu-id="c2738-655">Значение <see langword="true" />, если задача создала необрабатываемое исключение; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-655"><see langword="true" /> if the task has thrown an unhandled exception; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-656">Если <xref:System.Threading.Tasks.Task.IsFaulted%2A> — `true`, задачи <xref:System.Threading.Tasks.Task.Status%2A> равен <xref:System.Threading.Tasks.TaskStatus.Faulted>и его <xref:System.Threading.Tasks.Task.Exception%2A> свойство будет иметь значение null.</span><span class="sxs-lookup"><span data-stu-id="c2738-656">If <xref:System.Threading.Tasks.Task.IsFaulted%2A> is `true`, the task's <xref:System.Threading.Tasks.Task.Status%2A> is equal to <xref:System.Threading.Tasks.TaskStatus.Faulted>, and its <xref:System.Threading.Tasks.Task.Exception%2A> property will be non-null.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c2738-657">Получение значения <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> свойство не блокирует вызывающий поток до завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-657">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-658">Ставит в очередь заданную работу для запуска в ThreadPool и возвращает задачу или дескриптор <see cref="T:System.Threading.Tasks.Task`1" /> для этой работы.</span><span class="sxs-lookup"><span data-stu-id="c2738-658">Queues the specified work to run on the ThreadPool and returns a task or <see cref="T:System.Threading.Tasks.Task`1" /> handle for that work.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-659"><xref:System.Threading.Tasks.Task.Run%2A> Метод предоставляет набор перегрузки, которые позволяют легко запустить задачу со значениями по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="c2738-659">The <xref:System.Threading.Tasks.Task.Run%2A> method provides a set of overloads that make it easy to start a task by using default values.</span></span> <span data-ttu-id="c2738-660">Это упрощенная альтернатива <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> перегрузки.</span><span class="sxs-lookup"><span data-stu-id="c2738-660">It is a lightweight alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> overloads.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="c2738-661">Работа для асинхронного выполнения</span><span class="sxs-lookup"><span data-stu-id="c2738-661">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="c2738-662">Ставит в очередь заданную работу для запуска в пуле потоков и возвращает объект <see cref="T:System.Threading.Tasks.Task" />, представляющий эту работу.</span><span class="sxs-lookup"><span data-stu-id="c2738-662">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task" /> object that represents that work.</span></span></summary>
        <returns><span data-ttu-id="c2738-663">Задача, которая представляет работу в очереди на выполнение в ThreadPool.</span><span class="sxs-lookup"><span data-stu-id="c2738-663">A task that represents the work queued to execute in the ThreadPool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-664"><xref:System.Threading.Tasks.Task.Run%2A> Метод позволяет создавать и выполнять задачи в одном методе и является более простой альтернативой <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-664">The <xref:System.Threading.Tasks.Task.Run%2A> method allows you to create and execute a task in a single method call and is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method.</span></span> <span data-ttu-id="c2738-665">Он создает задачу, со следующими значениями по умолчанию:</span><span class="sxs-lookup"><span data-stu-id="c2738-665">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="c2738-666">Ее токен отмены <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c2738-666">Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c2738-667">Его <xref:System.Threading.Tasks.Task.CreationOptions%2A> свойство имеет значение <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c2738-667">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c2738-668">Она использует планировщик задач по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="c2738-668">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="c2738-669">Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-669">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-670">В следующем примере определяется `ShowThreadInfo` метод, отображающий <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> текущего потока.</span><span class="sxs-lookup"><span data-stu-id="c2738-670">The following example defines a `ShowThreadInfo` method  that displays the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> of the current thread.</span></span> <span data-ttu-id="c2738-671">Он вызывается напрямую из потока приложения и вызывается из <xref:System.Action> делегат, переданный <xref:System.Threading.Tasks.Task.Run%28System.Action%29> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-671">It is called directly from the application thread, and is called from the <xref:System.Action> delegate passed to the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 <span data-ttu-id="c2738-672">Следующий пример аналогичен предыдущему, за исключением того, что лямбда-выражения используются для определения кода, которая будет выполнена задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-672">The following example is similar to the previous one, except that it uses a lambda expression to define the code that the task is to execute.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 <span data-ttu-id="c2738-673">В примерах показано, что асинхронная задача выполняется в потоке, отличном от основного потока приложения.</span><span class="sxs-lookup"><span data-stu-id="c2738-673">The examples show that the asynchronous task executes on a different thread than the main application thread.</span></span>  
  
 <span data-ttu-id="c2738-674">Вызов <xref:System.Threading.Tasks.Task.Wait%2A> метод гарантирует, что задача завершается и отображение его выходных данных до окончания работы приложения.</span><span class="sxs-lookup"><span data-stu-id="c2738-674">The call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that the task completes and displays its output before the application ends.</span></span> <span data-ttu-id="c2738-675">В противном случае возможна ситуация, `Main` метод будет выполнена до завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-675">Otherwise, it is possible that the `Main` method will complete before the task finishes.</span></span>  
  
 <span data-ttu-id="c2738-676">В следующем примере показано <xref:System.Threading.Tasks.Task.Run%28System.Action%29> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-676">The following example illustrates the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span> <span data-ttu-id="c2738-677">Он определяет массив имен каталогов и запускает отдельную задачу, чтобы получить имена файлов в каждом каталоге.</span><span class="sxs-lookup"><span data-stu-id="c2738-677">It defines an array of directory names and starts a separate task to retrieve the file names in each directory.</span></span> <span data-ttu-id="c2738-678">Все задачи записи имен файлов к одному <xref:System.Collections.Concurrent.ConcurrentBag%601> объекта.</span><span class="sxs-lookup"><span data-stu-id="c2738-678">All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span> <span data-ttu-id="c2738-679">Затем в примере вызывается <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> метод, чтобы гарантировать, что все задачи завершены, а затем отображает количество общее количество имен файлов, записываемый <xref:System.Collections.Concurrent.ConcurrentBag%601> объекта.</span><span class="sxs-lookup"><span data-stu-id="c2738-679">The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-680">Параметр <paramref name="action" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-680">The <paramref name="action" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-681">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-681">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="c2738-682">Работа для асинхронного выполнения</span><span class="sxs-lookup"><span data-stu-id="c2738-682">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="c2738-683">Ставит в очередь указанную работу для запуска в пуле потоков и возвращает прокси для задачи, возвращаемой функцией <paramref name="function" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-683">Queues the specified work to run on the thread pool and returns a proxy for the  task returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="c2738-684">Задача, которая представляет прокси для задачи, возвращаемой <paramref name="function" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-684">A task that represents a proxy for the task returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-685">Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-685">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-686">Параметр <paramref name="function" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-686">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-687">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-687">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="c2738-688">Работа для асинхронного выполнения</span><span class="sxs-lookup"><span data-stu-id="c2738-688">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-689">Маркер отмены, который может использоваться для отмены работы.</span><span class="sxs-lookup"><span data-stu-id="c2738-689">A cancellation token that can be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="c2738-690">Ставит в очередь заданную работу для запуска в пуле потоков и возвращает объект <see cref="T:System.Threading.Tasks.Task" />, представляющий эту работу.</span><span class="sxs-lookup"><span data-stu-id="c2738-690">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task" /> object that represents that work.</span></span> <span data-ttu-id="c2738-691">Маркер отмены позволяет отменить работу.</span><span class="sxs-lookup"><span data-stu-id="c2738-691">A cancellation token allows the work to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="c2738-692">Задача, которая представляет работу в очереди на выполнение в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="c2738-692">A task that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-693">Если Отмена запрашивается до ее начала выполнения, задача не выполняется.</span><span class="sxs-lookup"><span data-stu-id="c2738-693">If cancellation is requested before the task begins execution, the task does not execute.</span></span> <span data-ttu-id="c2738-694">Вместо этого он становится равным <xref:System.Threading.Tasks.TaskStatus.Canceled> состояние и выдает исключение <xref:System.Threading.Tasks.TaskCanceledException> исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-694">Instead it is set to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state and throws a <xref:System.Threading.Tasks.TaskCanceledException> exception.</span></span>  
  
 <span data-ttu-id="c2738-695"><xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> Метод является более простой альтернативой <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-695">The <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-696">Он создает задачу, со следующими значениями по умолчанию:</span><span class="sxs-lookup"><span data-stu-id="c2738-696">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="c2738-697">Его <xref:System.Threading.Tasks.Task.CreationOptions%2A> свойство имеет значение <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c2738-697">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c2738-698">Она использует планировщик задач по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="c2738-698">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="c2738-699">Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-699">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-700">В следующем примере вызывается <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> метод, чтобы создать задачу, которая выполняет итерацию файлы в каталог C:\Windows\System32.</span><span class="sxs-lookup"><span data-stu-id="c2738-700">The following example calls the <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> method to create a task that iterates the files in the C:\Windows\System32 directory.</span></span> <span data-ttu-id="c2738-701">Лямбда-выражение вызывает <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> метод, чтобы добавить информацию о каждом файле, чтобы <xref:System.Collections.Generic.List%601> объекта.</span><span class="sxs-lookup"><span data-stu-id="c2738-701">The lambda expression calls the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to add information about each  file to a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="c2738-702">Каждый отсоединенной вложенной задачей, вызываемых <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> цикл проверяет состояние токена отмены и если запрос на отмену вызывает <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-702">Each detached nested task invoked by the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop checks the state of the cancellation token and, if cancellation is requested, calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-703"><xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Вызывает метод <xref:System.OperationCanceledException> исключение, которое обрабатывается в `catch` заблокировать, если вызывающий поток вызывает <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-703">The <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method throws an <xref:System.OperationCanceledException> exception that is handled in a `catch` block when the calling thread calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-704">Параметр <paramref name="action" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-704">The <paramref name="action" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="c2738-705">Задача была отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-705">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-706">Объект <see cref="T:System.Threading.CancellationTokenSource" />, связанный с <paramref name="cancellationToken" />, был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-706">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-707">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-707">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="c2738-708">Работа для асинхронного выполнения.</span><span class="sxs-lookup"><span data-stu-id="c2738-708">The work to execute asynchronously.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-709">Маркер отмены, который должен использоваться для отмены работы.</span><span class="sxs-lookup"><span data-stu-id="c2738-709">A cancellation token that should be used to cancel the work.</span></span></param>
        <summary><span data-ttu-id="c2738-710">Ставит в очередь указанную работу для запуска в пуле потоков и возвращает прокси для задачи, возвращаемой функцией <paramref name="function" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-710">Queues the specified work to run on the thread pool and returns a proxy for the task returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="c2738-711">Задача, которая представляет прокси для задачи, возвращаемой <paramref name="function" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-711">A task that represents a proxy for the task returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-712">Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-712">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-713">Параметр <paramref name="function" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-713">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="c2738-714">Задача была отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-714">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-715">Объект <see cref="T:System.Threading.CancellationTokenSource" />, связанный с <paramref name="cancellationToken" />, был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-715">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="c2738-716">Отмена задач</span><span class="sxs-lookup"><span data-stu-id="c2738-716">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-717">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-717">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-718">Тип результата, возвращенного задачей прокси-сервера.</span><span class="sxs-lookup"><span data-stu-id="c2738-718">The type of the result returned by the proxy task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="c2738-719">Работа для асинхронного выполнения</span><span class="sxs-lookup"><span data-stu-id="c2738-719">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="c2738-720">Ставит в очередь заданную работу для запуска в пуле потоков и возвращает прокси для задачи <see langword="Task(TResult)" />, возвращаемой <paramref name="function" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-720">Queues the specified work to run on the thread pool and returns a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="c2738-721">Объект <see langword="Task(TResult)" />, представляющий прокси для объекта <see langword="Task(TResult)" />, возвращаемого <paramref name="function" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-721">A <see langword="Task(TResult)" /> that represents a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-722">Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-722">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-723">Параметр <paramref name="function" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-723">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-724">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-724">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-725">Тип возвращаемого значения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-725">The return type of the task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="c2738-726">Работа для асинхронного выполнения.</span><span class="sxs-lookup"><span data-stu-id="c2738-726">The work to execute asynchronously.</span></span></param>
        <summary><span data-ttu-id="c2738-727">Ставит в очередь заданную работу для запуска в пуле потоков и возвращает объект <see cref="T:System.Threading.Tasks.Task`1" />, представляющий эту работу.</span><span class="sxs-lookup"><span data-stu-id="c2738-727">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task`1" /> object that represents that work.</span></span></summary>
        <returns><span data-ttu-id="c2738-728">Объект задачи, представляющий работу в очереди на выполнение в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="c2738-728">A task object that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-729"><xref:System.Threading.Tasks.Task.Run%2A> Метод является более простой альтернативой <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-729">The <xref:System.Threading.Tasks.Task.Run%2A> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c2738-730">Он создает задачу, со следующими значениями по умолчанию:</span><span class="sxs-lookup"><span data-stu-id="c2738-730">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="c2738-731">Ее токен отмены <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c2738-731">Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c2738-732">Его <xref:System.Threading.Tasks.Task.CreationOptions%2A> свойство имеет значение <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c2738-732">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c2738-733">Она использует планировщик задач по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="c2738-733">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="c2738-734">Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-734">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-735">В следующем примере подсчитывается приблизительное количество слов в текстовых файлах, которые представляют опубликованных бюллетеней.</span><span class="sxs-lookup"><span data-stu-id="c2738-735">The following example counts the approximate number of words in text files that represent published books.</span></span> <span data-ttu-id="c2738-736">Каждая задача отвечает за открытие файла, асинхронного чтения все его содержимое и подсчет слов с помощью регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="c2738-736">Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</span></span> <span data-ttu-id="c2738-737"><xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Вызывается метод, чтобы убедиться, что все задачи завершены перед отображением подсчета слов каждую книгу в консоль.</span><span class="sxs-lookup"><span data-stu-id="c2738-737">The <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method is called to ensure that all tasks have completed before  displaying the word count of each book to the console.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 <span data-ttu-id="c2738-738">Регулярное выражение `\p{P}*\s+` заменяет ноль, один или несколько знаков пунктуации, за которыми следует один или несколько символов пробела.</span><span class="sxs-lookup"><span data-stu-id="c2738-738">The regular expression `\p{P}*\s+` matches zero, one, or more punctuation characters followed by one or more white-space characters.</span></span> <span data-ttu-id="c2738-739">Предполагается, что общее количество совпадений равна приблизительно Статистика.</span><span class="sxs-lookup"><span data-stu-id="c2738-739">It assumes that the total number of matches equals the approximate word count.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-740">Параметр <paramref name="function" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-740">The <paramref name="function" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-741">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-741">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-742">Тип результата, возвращенного задачей прокси-сервера.</span><span class="sxs-lookup"><span data-stu-id="c2738-742">The type of the result returned by the proxy task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="c2738-743">Работа для асинхронного выполнения</span><span class="sxs-lookup"><span data-stu-id="c2738-743">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-744">Токен отмены, который должен использоваться для отмены работы</span><span class="sxs-lookup"><span data-stu-id="c2738-744">A cancellation token that should be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="c2738-745">Ставит в очередь заданную работу для запуска в пуле потоков и возвращает прокси для задачи <see langword="Task(TResult)" />, возвращаемой <paramref name="function" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-745">Queues the specified work to run on the thread pool and returns a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="c2738-746">Объект <see langword="Task(TResult)" />, представляющий прокси для объекта <see langword="Task(TResult)" />, возвращаемого <paramref name="function" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-746">A <see langword="Task(TResult)" /> that represents a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-747">Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-747">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-748">Параметр <paramref name="function" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-748">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="c2738-749">Задача была отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-749">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-750">Объект <see cref="T:System.Threading.CancellationTokenSource" />, связанный с <paramref name="cancellationToken" />, был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-750">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="c2738-751">Отмена задач</span><span class="sxs-lookup"><span data-stu-id="c2738-751">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-752">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-752">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-753">Тип результата задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-753">The result type of the task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="c2738-754">Работа для асинхронного выполнения</span><span class="sxs-lookup"><span data-stu-id="c2738-754">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-755">Токен отмены, который должен использоваться для отмены работы</span><span class="sxs-lookup"><span data-stu-id="c2738-755">A cancellation token that should be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="c2738-756">Ставит в очередь заданную работу для запуска в пуле потоков и возвращает объект <see langword="Task(TResult)" />, представляющий эту работу.</span><span class="sxs-lookup"><span data-stu-id="c2738-756">Queues the specified work to run on the thread pool and returns a <see langword="Task(TResult)" /> object that represents that work.</span></span> <span data-ttu-id="c2738-757">Маркер отмены позволяет отменить работу.</span><span class="sxs-lookup"><span data-stu-id="c2738-757">A cancellation token allows the work to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="c2738-758">Задача <see langword="Task(TResult)" />, которая представляет работу в очереди на выполнение в пуле потоков.</span><span class="sxs-lookup"><span data-stu-id="c2738-758">A <see langword="Task(TResult)" /> that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-759">Если Отмена запрашивается до ее начала выполнения, задача не выполняется.</span><span class="sxs-lookup"><span data-stu-id="c2738-759">If cancellation is requested before the task begins execution, the task does not execute.</span></span> <span data-ttu-id="c2738-760">Вместо этого он становится равным <xref:System.Threading.Tasks.TaskStatus.Canceled> состояние и выдает исключение <xref:System.Threading.Tasks.TaskCanceledException> исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-760">Instead it is set to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state and throws a <xref:System.Threading.Tasks.TaskCanceledException> exception.</span></span>  
  
 <span data-ttu-id="c2738-761"><xref:System.Threading.Tasks.Task.Run%2A> Метод является более простой альтернативой <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-761">The <xref:System.Threading.Tasks.Task.Run%2A> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method.</span></span> <span data-ttu-id="c2738-762">Он создает задачу, со следующими значениями по умолчанию:</span><span class="sxs-lookup"><span data-stu-id="c2738-762">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="c2738-763">Его <xref:System.Threading.Tasks.Task.CreationOptions%2A> свойство имеет значение <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c2738-763">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c2738-764">Она использует планировщик задач по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="c2738-764">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="c2738-765">Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-765">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-766">В следующем примере создается 20 задачи, которые будут цикл, пока значение счетчика увеличивается значение 2 млн.</span><span class="sxs-lookup"><span data-stu-id="c2738-766">The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</span></span> <span data-ttu-id="c2738-767">По достижении 2 миллиона первые 10 задач токен отмены отменяется и будут отменены все задачи, в которых счетчики не достигли 2 млн.</span><span class="sxs-lookup"><span data-stu-id="c2738-767">When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</span></span> <span data-ttu-id="c2738-768">В примере возможного выхода.</span><span class="sxs-lookup"><span data-stu-id="c2738-768">The example shows possible output.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 <span data-ttu-id="c2738-769">Вместо использования <xref:System.AggregateException.InnerExceptions%2A> свойство для проверки исключений, приведенный пример проходит все задачи, чтобы определить, который успешно выполнены и которого были отменены.</span><span class="sxs-lookup"><span data-stu-id="c2738-769">Instead of using the <xref:System.AggregateException.InnerExceptions%2A> property to   examine exceptions, the example iterates all tasks to determine which have completed successfully and which have been cancelled.</span></span> <span data-ttu-id="c2738-770">Для тех, которые были завершены отображается значение, возвращенного задачей.</span><span class="sxs-lookup"><span data-stu-id="c2738-770">For those that have completed, it displays the value returned by the task.</span></span>  
  
 <span data-ttu-id="c2738-771">Так как Отмена выполняется совместно, каждой задачи можно решить, как реагировать на отмену.</span><span class="sxs-lookup"><span data-stu-id="c2738-771">Because cancellation is cooperative, each task can decide how to respond to cancellation.</span></span> <span data-ttu-id="c2738-772">Следующий пример аналогичен первой, за исключением того, что после токена отмены задач возвращают число итераций, они завершили работу, а не к возникновению исключения.</span><span class="sxs-lookup"><span data-stu-id="c2738-772">The following example is like the first, except that, once the token is cancelled, tasks return the number of iterations they've completed rather than throw an exception.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 <span data-ttu-id="c2738-773">Пример по-прежнему должны обрабатывать <xref:System.AggregateException> исключение, так как все задачи, которые еще не начали при запросе отмены по-прежнему исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-773">The example still must handle the <xref:System.AggregateException> exception,   since any tasks that have not started when cancellation is requested still throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-774">Параметр <paramref name="function" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-774">The <paramref name="function" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="c2738-775">Задача была отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-775">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-776">Объект <see cref="T:System.Threading.CancellationTokenSource" />, связанный с <paramref name="cancellationToken" />, был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-776">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="c2738-777">Отмена задач</span><span class="sxs-lookup"><span data-stu-id="c2738-777">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-778">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-778">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-779">Синхронно выполняет задачу <see cref="T:System.Threading.Tasks.Task" /> в текущем планировщике <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-779">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2738-780">Синхронно выполняет задачу <see cref="T:System.Threading.Tasks.Task" /> в текущем планировщике <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-780">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-781">Обычно задачи выполняются асинхронно в потоке пула потоков и не блокируют вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="c2738-781">Ordinarily, tasks are executed asynchronously on a thread pool thread and do not block the calling thread.</span></span> <span data-ttu-id="c2738-782">Задачи, выполняется путем вызова <xref:System.Threading.Tasks.Task.RunSynchronously> метод связаны с текущим <xref:System.Threading.Tasks.TaskScheduler> и выполняются в вызывающем потоке.</span><span class="sxs-lookup"><span data-stu-id="c2738-782">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously> method are associated with the current <xref:System.Threading.Tasks.TaskScheduler> and are run on the calling thread.</span></span> <span data-ttu-id="c2738-783">Если целевой планировщик не поддерживает выполнение этой задачи в вызывающем потоке, задача будет планироваться выполнение в планировщике, и вызывающий поток будет заблокирован до завершения выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-783">If the target scheduler does not support running this task on the calling thread, the task will be scheduled for execution on the scheduler, and the calling thread will block until the task has completed execution.</span></span> <span data-ttu-id="c2738-784">Несмотря на то, что задача выполняется синхронно, вызывающий поток по-прежнему должны вызывать <xref:System.Threading.Tasks.Task.Wait%2A> для обработки исключений, которые могут создавать задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-784">Even though the task runs synchronously, the calling thread should still call <xref:System.Threading.Tasks.Task.Wait%2A> to handle any exceptions that the task might throw.</span></span>  <span data-ttu-id="c2738-785">Дополнительные сведения об обработке исключений см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-785">For more information on exception handling, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 <span data-ttu-id="c2738-786">Задачи, выполняется путем вызова <xref:System.Threading.Tasks.Task.RunSynchronously%2A> метод создаются путем вызова <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601> конструктора класса.</span><span class="sxs-lookup"><span data-stu-id="c2738-786">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method are instantiated by calling a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> class constructor.</span></span> <span data-ttu-id="c2738-787">Задание для синхронного выполнения должно быть в <xref:System.Threading.Tasks.TaskStatus.Created> состояние.</span><span class="sxs-lookup"><span data-stu-id="c2738-787">The task to be run synchronously must be in the <xref:System.Threading.Tasks.TaskStatus.Created> state.</span></span> <span data-ttu-id="c2738-788">Задача может запускаются и выполняются только один раз.</span><span class="sxs-lookup"><span data-stu-id="c2738-788">A task may be started and run only once.</span></span> <span data-ttu-id="c2738-789">Любые попытки запланировать задачу, второй раз приведет к исключению.</span><span class="sxs-lookup"><span data-stu-id="c2738-789">Any attempts to schedule a task a second time results in an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-790">В следующем примере сравниваются задачи выполняется путем вызова <xref:System.Threading.Tasks.Task.RunSynchronously%2A> метод с одним-выражение выполняется асинхронно.</span><span class="sxs-lookup"><span data-stu-id="c2738-790">The following example compares a task executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method with one executed asynchronously.</span></span> <span data-ttu-id="c2738-791">В обоих случаях выполняться задачи одинаковыми лямбда-выражениями, которые отображают идентификатор задачи и идентификатор потока, на котором запущена задача.</span><span class="sxs-lookup"><span data-stu-id="c2738-791">In both cases, the tasks execute identical lambda expressions that display the task ID and the ID of the thread on which the task is running.</span></span> <span data-ttu-id="c2738-792">Задача вычисляет сумму целые числа от 1 до 1 000 000.</span><span class="sxs-lookup"><span data-stu-id="c2738-792">The task calculates the sum of the integers between 1 and 1,000,000.</span></span> <span data-ttu-id="c2738-793">Как видно из примера, задача выполняется путем вызова <xref:System.Threading.Tasks.Task.RunSynchronously%2A> метод выполняется в потоке приложения, а асинхронная задача — нет.</span><span class="sxs-lookup"><span data-stu-id="c2738-793">As the output from the example shows, the task executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method runs on the application thread, while the asynchronous task does not.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-794">Экземпляр <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-794">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c2738-795">Задача <see cref="T:System.Threading.Tasks.Task" /> не находится в допустимом состоянии для запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-795">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="c2738-796">Возможно, она уже запущена, выполнена или отменена, или она была создана способом, не поддерживающим прямое планирование.</span><span class="sxs-lookup"><span data-stu-id="c2738-796">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-797">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-797">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><span data-ttu-id="c2738-798">Планировщик, в котором следует попытаться выполнить задачу.</span><span class="sxs-lookup"><span data-stu-id="c2738-798">The scheduler on which to attempt to run this task inline.</span></span></param>
        <summary><span data-ttu-id="c2738-799">Синхронно выполняет задачу <see cref="T:System.Threading.Tasks.Task" /> в предоставленном планировщике <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-799">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the <see cref="T:System.Threading.Tasks.TaskScheduler" /> provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-800">Задачи, выполняется путем вызова <xref:System.Threading.Tasks.Task.RunSynchronously%2A> метод создаются путем вызова <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601> конструктора класса.</span><span class="sxs-lookup"><span data-stu-id="c2738-800">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method are instantiated by calling a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> class constructor.</span></span> <span data-ttu-id="c2738-801">Задание для синхронного выполнения должно быть в <xref:System.Threading.Tasks.TaskStatus.Created> состояние.</span><span class="sxs-lookup"><span data-stu-id="c2738-801">The task to be run synchronously must be in the <xref:System.Threading.Tasks.TaskStatus.Created> state.</span></span> <span data-ttu-id="c2738-802">Задача может запускаются и выполняются только один раз.</span><span class="sxs-lookup"><span data-stu-id="c2738-802">A task may be started and run only once.</span></span> <span data-ttu-id="c2738-803">Любые попытки запланировать задачу, второй раз приведет к исключению.</span><span class="sxs-lookup"><span data-stu-id="c2738-803">Any attempts to schedule a task a second time results in an exception.</span></span>  
  
 <span data-ttu-id="c2738-804">Если целевой планировщик не поддерживает выполнение этой задачи в текущем потоке, задача будет планироваться выполнение в планировщике, а текущий поток будет заблокирован до завершения выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-804">If the target scheduler does not support running this task on the current thread, the task will be scheduled for execution on the scheduler, and the current thread will block until the task has completed execution.</span></span> <span data-ttu-id="c2738-805">По этой причине вызывающий поток не нужно вызывать метод, например <xref:System.Threading.Tasks.Task.Wait%2A> чтобы убедиться, что задача завершила выполнение.</span><span class="sxs-lookup"><span data-stu-id="c2738-805">Because of this, the calling thread does not need to call a method such as <xref:System.Threading.Tasks.Task.Wait%2A> to ensure that the task has completed execution.</span></span> <span data-ttu-id="c2738-806">Дополнительные сведения о обработчика исключений для операции задачи, см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-806">For more information on exception handling for task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-807">Экземпляр <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-807">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-808">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-808">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c2738-809">Задача <see cref="T:System.Threading.Tasks.Task" /> не находится в допустимом состоянии для запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-809">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="c2738-810">Возможно, она уже запущена, выполнена или отменена, или она была создана способом, не поддерживающим прямое планирование.</span><span class="sxs-lookup"><span data-stu-id="c2738-810">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-811">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-811">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-812">Запускает <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-812">Starts the <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2738-813">Запускает задачу <see cref="T:System.Threading.Tasks.Task" />, планируя ее выполнение в текущем планировщике <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-813">Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-814">Задача может запускаются и выполняются только один раз.</span><span class="sxs-lookup"><span data-stu-id="c2738-814">A task may be started and run only once.</span></span> <span data-ttu-id="c2738-815">Любые попытки запланировать задачу во второй раз приведет к исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-815">Any attempts to schedule a task a second time will result in an exception.</span></span>  
  
 <span data-ttu-id="c2738-816"><xref:System.Threading.Tasks.Task.Start%2A> Позволяет выполнять задачу, которая будет создана путем вызова одного из <xref:System.Threading.Tasks.Task> конструкторы.</span><span class="sxs-lookup"><span data-stu-id="c2738-816">The <xref:System.Threading.Tasks.Task.Start%2A> is used to execute a task that has been created by calling one of the <xref:System.Threading.Tasks.Task> constructors.</span></span> <span data-ttu-id="c2738-817">Как правило это делается, если вам нужно отделить Создание задачи от ее выполнения, например когда позволяет выполнять задачи, которые вы создали.</span><span class="sxs-lookup"><span data-stu-id="c2738-817">Typically, you do this when you need to separate the task's creation from its execution, such as when you conditionally execute tasks that you've created.</span></span> <span data-ttu-id="c2738-818">Для более распространенный случай, в котором не требуется разделения задач при создании экземпляра выполнения, рекомендуется вызывать перегрузку <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> или <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-818">For the more common case in which you don't need to separate  task instantiation from execution, we recommend that you call an overload of the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c2738-819">Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-819">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-820">В следующем примере вызывается <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> конструктор для создания нового <xref:System.Threading.Tasks.Task> объект, который отображает свою задачу, идентификатор и идентификатор управляемого потока, а затем выполняет цикл.</span><span class="sxs-lookup"><span data-stu-id="c2738-820">The following example calls the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor to instantiate a new <xref:System.Threading.Tasks.Task> object that displays its task ID and managed thread ID and then executes a loop.</span></span> <span data-ttu-id="c2738-821">Затем он вызывает <xref:System.Threading.Tasks.Task.Start%2A> метод для выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-821">It then calls the <xref:System.Threading.Tasks.Task.Start%2A> method to execute the task.</span></span>  <span data-ttu-id="c2738-822">Так как это консольное приложение, вызов <xref:System.Threading.Tasks.Task.Wait%2A> метод необходим запретить приложению завершение работы до завершения выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-822">Since this is a console app, the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method is necessary to prevent the app from terminating before the task finishes execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-823">Экземпляр <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-823">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c2738-824">Задача <see cref="T:System.Threading.Tasks.Task" /> не находится в допустимом состоянии для запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-824">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="c2738-825">Возможно, она уже запущена, выполнена или отменена, или она была создана способом, не поддерживающим прямое планирование.</span><span class="sxs-lookup"><span data-stu-id="c2738-825">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-826">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-826">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><span data-ttu-id="c2738-827">Планировщик <see cref="T:System.Threading.Tasks.TaskScheduler" />, с которым нужно связать и в котором нужно выполнить данную задачу.</span><span class="sxs-lookup"><span data-stu-id="c2738-827">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> with which to associate and execute this task.</span></span></param>
        <summary><span data-ttu-id="c2738-828">Запускает задачу <see cref="T:System.Threading.Tasks.Task" />, планируя ее выполнение в заданном планировщике <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-828">Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the specified <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-829">Задача может только запускаются и выполняются только один раз.</span><span class="sxs-lookup"><span data-stu-id="c2738-829">A task may only be started and run only once.</span></span> <span data-ttu-id="c2738-830">Любые попытки запланировать задачу во второй раз приведет к исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-830">Any attempts to schedule a task a second time will result in an exception.</span></span>  
  
 <span data-ttu-id="c2738-831">Дополнительные сведения об обработке исключений, создаваемых операциями задач см. в разделе [обработка исключений](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-831">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-832">Аргумент <paramref name="scheduler" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-832">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c2738-833">Задача <see cref="T:System.Threading.Tasks.Task" /> не находится в допустимом состоянии для запуска.</span><span class="sxs-lookup"><span data-stu-id="c2738-833">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="c2738-834">Возможно, она уже запущена, выполнена или отменена, или она была создана способом, не поддерживающим прямое планирование.</span><span class="sxs-lookup"><span data-stu-id="c2738-834">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-835">Экземпляр <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-835">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException"><span data-ttu-id="c2738-836">Планировщику не удалось поставить эту задачу в очередь.</span><span class="sxs-lookup"><span data-stu-id="c2738-836">The scheduler was unable to queue this task.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="c2738-837">Обработка исключений (библиотека параллельных задач)</span><span class="sxs-lookup"><span data-stu-id="c2738-837">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-838">Получает состояние <see cref="T:System.Threading.Tasks.TaskStatus" /> данной задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-838">Gets the <see cref="T:System.Threading.Tasks.TaskStatus" /> of this task.</span></span></summary>
        <value><span data-ttu-id="c2738-839">Текущее состояние <see cref="T:System.Threading.Tasks.TaskStatus" /> данного экземпляра задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-839">The current <see cref="T:System.Threading.Tasks.TaskStatus" /> of this task instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-840">Получение значения <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> свойство не блокирует вызывающий поток до завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-840">Retrieving the value of the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 <span data-ttu-id="c2738-841">Дополнительные сведения и пример см. в разделе [создание цепочки задач с помощью задач продолжения](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) и [как: Отмена задачи и ее дочерних элементов](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-841">For more information and an example, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) and [How to: Cancel a Task and Its Children](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-842">В следующем примере создается 20 задачи, которые будут цикл, пока значение счетчика увеличивается значение 2 млн.</span><span class="sxs-lookup"><span data-stu-id="c2738-842">The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</span></span> <span data-ttu-id="c2738-843">По достижении 2 миллиона первые 10 задач токен отмены отменяется и будут отменены все задачи, в которых счетчики не достигли 2 млн.</span><span class="sxs-lookup"><span data-stu-id="c2738-843">When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</span></span> <span data-ttu-id="c2738-844">Пример затем просматривает <xref:System.Threading.Tasks.Task.Status%2A> свойства каждой задачи, чтобы указать ли она завершилась успешно, или была отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-844">The example then examines the <xref:System.Threading.Tasks.Task.Status%2A> property of each task to indicate whether it completed successfully or was cancelled.</span></span> <span data-ttu-id="c2738-845">Для тех, которые выполнены отображается значение, возвращенного задачей.</span><span class="sxs-lookup"><span data-stu-id="c2738-845">For those that completed, it displays the value returned by the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-846">Возвращает дескриптор <see cref="T:System.Threading.WaitHandle" />, который можно использовать для ожидания завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-846">Gets a <see cref="T:System.Threading.WaitHandle" /> that can be used to wait for the task to complete.</span></span></summary>
        <value><span data-ttu-id="c2738-847">Дескриптор <see cref="T:System.Threading.WaitHandle" />, который можно использовать для ожидания завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-847">A <see cref="T:System.Threading.WaitHandle" /> that can be used to wait for the task to complete.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-848">С помощью ожидания функциональных возможностях, предоставляемых <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> предпочтительнее использования <xref:System.IAsyncResult.AsyncWaitHandle%2A> аналогичными функциональными возможностями.</span><span class="sxs-lookup"><span data-stu-id="c2738-848">Using the wait functionality provided by <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> is preferable to using <xref:System.IAsyncResult.AsyncWaitHandle%2A> for similar functionality.</span></span> <span data-ttu-id="c2738-849">Дополнительные сведения см. в разделе «Ожидание на задачи» в [Task-based асинхронное программирование](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) и [с помощью библиотеки параллельных задач с другие асинхронные шаблоны](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).</span><span class="sxs-lookup"><span data-stu-id="c2738-849">For more information, see the "Waiting on Tasks" section in [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Using TPL with Other Asynchronous Patterns](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-850">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-850">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c2738-851">Получает значение, указывающее, синхронно ли выполнена операция.</span><span class="sxs-lookup"><span data-stu-id="c2738-851">Gets an indication of whether the operation completed synchronously.</span></span></summary>
        <value><span data-ttu-id="c2738-852">Значение <see langword="true" />, если операция завершилась синхронно, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-852"><see langword="true" /> if the operation completed synchronously; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-853">Ожидает завершения выполнения задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-853">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2738-854">Ожидает завершения выполнения задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-854">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-855"><xref:System.Threading.Tasks.Task.Wait%2A> — Это метод синхронизации, который вызывающий поток до завершения текущей задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-855"><xref:System.Threading.Tasks.Task.Wait%2A> is a synchronization method that causes the calling thread to wait until the current task has completed.</span></span> <span data-ttu-id="c2738-856">Если текущая задача еще не началось выполнение, метода Wait пытается удалить задание из планировщика и выполните его, встроенные в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="c2738-856">If the current task has not started execution, the Wait method attempts to remove the task from the scheduler and execute it inline on the current thread.</span></span> <span data-ttu-id="c2738-857">Если не удается это сделать, или если выполнения текущей задачи уже начался, он блокирует вызывающий поток до завершения выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-857">If it is unable to do that, or if the current task has already started execution, it blocks the calling thread until the task completes.</span></span> <span data-ttu-id="c2738-858">Дополнительные сведения см. в разделе [Task.Wait и «Встраивание»](https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/) в параллельному программированию в блоге .NET.</span><span class="sxs-lookup"><span data-stu-id="c2738-858">For more information, see [Task.Wait and "Inlining"](https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/) in the Parallel Programming with .NET blog.</span></span>   
  
## Examples  
 <span data-ttu-id="c2738-859">В следующем примере запускается задача, которая создает один миллион случайных целых чисел от 0 до 100 и вычисляет их среднее значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-859">The following example starts a task that generates one million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="c2738-860">В примере используется <xref:System.Threading.Tasks.Task.Wait%2A> метод, чтобы гарантировать, что задача будет завершена, прежде чем приложение завершит работу.</span><span class="sxs-lookup"><span data-stu-id="c2738-860">The example uses the <xref:System.Threading.Tasks.Task.Wait%2A> method to ensure that the task completes before the application terminates.</span></span> <span data-ttu-id="c2738-861">В противном случае — так как это консольное приложение, пример завершает работу до задачи можно вычислить и отобразить среднее значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-861">Otherwise, because this is a console application, the example would terminate before the task can compute and display the mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-862">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-862">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c2738-863">Задача отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-863">The task was canceled.</span></span> <span data-ttu-id="c2738-864">Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит объект <see cref="T:System.Threading.Tasks.TaskCanceledException" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-864">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="c2738-865">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-865">-or-</span></span> 
<span data-ttu-id="c2738-866">Во время выполнения задачи возникло исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-866">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="c2738-867">Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит сведения об исключении или исключениях.</span><span class="sxs-lookup"><span data-stu-id="c2738-867">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
        <related type="ExternalDocumentation" href="https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/"><span data-ttu-id="c2738-868">Task.Wait и «Встраивания»</span><span class="sxs-lookup"><span data-stu-id="c2738-868">Task.Wait and "Inlining"</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="c2738-869">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-869">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c2738-870">Ожидает завершения задачи <see cref="T:System.Threading.Tasks.Task" /> в течение указанного числа миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="c2738-870">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="c2738-871">Значение <see langword="true" />, если <see cref="T:System.Threading.Tasks.Task" /> завершил выполнение в течение отведенного времени; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-871"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-872"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> — Это метод синхронизации, который вызывающий поток ожидания для текущего экземпляра задачи завершения, пока не произойдет одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="c2738-872"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="c2738-873">Задача завершается успешно.</span><span class="sxs-lookup"><span data-stu-id="c2738-873">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="c2738-874">Сама задача отменяется или создает исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-874">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="c2738-875">В этом случае вы обрабатываете <xref:System.AggregateException> исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-875">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="c2738-876"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Свойство содержит сведения об исключении или исключениях.</span><span class="sxs-lookup"><span data-stu-id="c2738-876">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="c2738-877">Интервал, заданный `millisecondsTimeout` пройдет указанное время.</span><span class="sxs-lookup"><span data-stu-id="c2738-877">The interval defined by `millisecondsTimeout` elapses.</span></span> <span data-ttu-id="c2738-878">В этом случае текущий поток возобновляет выполнение, а метод возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="c2738-878">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-879">В следующем примере запускается задача, которая создает пять миллионов случайных целых чисел от 0 до 100 и вычисляет их среднее значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-879">The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="c2738-880">В примере используется <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> метод для ожидания в миллисекундах 150 приложения.</span><span class="sxs-lookup"><span data-stu-id="c2738-880">The example uses the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> method to wait for the application to complete within 150 milliseconds.</span></span> <span data-ttu-id="c2738-881">Если приложение обычно завершает, задача отображается сумма и среднее значение случайных чисел, он сформирован.</span><span class="sxs-lookup"><span data-stu-id="c2738-881">If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</span></span> <span data-ttu-id="c2738-882">Если истек интервал времени ожидания, выводится сообщение перед завершением.</span><span class="sxs-lookup"><span data-stu-id="c2738-882">If the timeout interval has elapsed, the example displays a message before it terminates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-883">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-883">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-884">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-884"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c2738-885">Задача отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-885">The task was canceled.</span></span> <span data-ttu-id="c2738-886">Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит объект <see cref="T:System.Threading.Tasks.TaskCanceledException" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-886">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="c2738-887">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-887">-or-</span></span> 
<span data-ttu-id="c2738-888">Во время выполнения задачи возникло исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-888">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="c2738-889">Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит сведения об исключении или исключениях.</span><span class="sxs-lookup"><span data-stu-id="c2738-889">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="c2738-890">Токен отмены, который нужно контролировать во время ожидания выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-890">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="c2738-891">Ожидает завершения выполнения задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-891">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span> <span data-ttu-id="c2738-892">Ожидание завершается, если токен отмены отменяется до завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-892">The wait terminates if a cancellation token is canceled before the task completes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-893"><xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> Метод создает отменяемого ожидания, то есть вызывает текущий поток может ожидать, пока не произойдет одно из следующих событий:</span><span class="sxs-lookup"><span data-stu-id="c2738-893">The <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> method creates a cancelable wait; that is, it causes the current thread to wait until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="c2738-894">Задача будет завершена.</span><span class="sxs-lookup"><span data-stu-id="c2738-894">The task completes.</span></span>  
  
-   <span data-ttu-id="c2738-895">Токен отмены отменяется.</span><span class="sxs-lookup"><span data-stu-id="c2738-895">The cancellation token is canceled.</span></span> <span data-ttu-id="c2738-896">В этом случае вызов <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> вызывает метод <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="c2738-896">In this case, the call to the <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> method throws an <xref:System.OperationCanceledException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c2738-897">Отмена `cancellationToken` токен отмены никак не влияет на выполняемая задача, если он также был передан токен отмены и подготовиться к обработке отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-897">Canceling the `cancellationToken` cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</span></span> <span data-ttu-id="c2738-898">Передача `cancellationToken` в этот метод позволяет просто ожидания отменяется.</span><span class="sxs-lookup"><span data-stu-id="c2738-898">Passing the `cancellationToken` object to this method simply allows the wait to be canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-899">В следующем примере использует токен отмены для отмены ожидания завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-899">The following example illustrates the simple use of a cancellation token to cancel waiting for a task's completion.</span></span> <span data-ttu-id="c2738-900">Задача запускается, вызывает <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> метод отменить любую из токенов отмены Источник токена, а затем задержки в течение пяти секунд.</span><span class="sxs-lookup"><span data-stu-id="c2738-900">A task is launched, calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to cancel any of the token source's cancellation tokens, and then delays for five seconds.</span></span> <span data-ttu-id="c2738-901">Обратите внимание, что сама задача не был передан токен отмены и не может быть отменен.</span><span class="sxs-lookup"><span data-stu-id="c2738-901">Note that the task itself has not been passed the cancellation token and is not cancelable.</span></span> <span data-ttu-id="c2738-902">Поток приложения вызывает задачи <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> метод для ожидания завершения задачи, но время ожидания отменяется после отмены токена отмены и <xref:System.OperationCanceledException> возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-902">The application thread calls the task's <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the task to complete, but the wait is canceled once the cancellation token is cancelled and an <xref:System.OperationCanceledException> is thrown.</span></span> <span data-ttu-id="c2738-903">Обработчик исключений сообщает исключение и затем бездействует в течение шести секунд.</span><span class="sxs-lookup"><span data-stu-id="c2738-903">The exception handler reports the exception and then sleeps for six seconds.</span></span> <span data-ttu-id="c2738-904">Как видно из примера, что задержка позволяет задаче для выполнения в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние.</span><span class="sxs-lookup"><span data-stu-id="c2738-904">As the output from the example shows, that delay allows the task to complete in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="c2738-905">Объект <paramref name="cancellationToken" /> отменен.</span><span class="sxs-lookup"><span data-stu-id="c2738-905">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-906">Задача была удалена.</span><span class="sxs-lookup"><span data-stu-id="c2738-906">The task has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c2738-907">Задача отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-907">The task was canceled.</span></span> <span data-ttu-id="c2738-908">Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит объект <see cref="T:System.Threading.Tasks.TaskCanceledException" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-908">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="c2738-909">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-909">-or-</span></span> 
<span data-ttu-id="c2738-910">Во время выполнения задачи возникло исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-910">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="c2738-911">Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит сведения об исключении или исключениях.</span><span class="sxs-lookup"><span data-stu-id="c2738-911">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="c2738-912">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-912">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c2738-913">Ожидает завершения выполнения задач <see cref="T:System.Threading.Tasks.Task" /> в течение указанного временного периода.</span><span class="sxs-lookup"><span data-stu-id="c2738-913">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="c2738-914">Значение <see langword="true" />, если <see cref="T:System.Threading.Tasks.Task" /> завершил выполнение в течение отведенного времени; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-914"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-915"><xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> — Это метод синхронизации, который вызывающий поток ожидания для текущего экземпляра задачи завершения, пока не произойдет одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="c2738-915"><xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="c2738-916">Задача завершается успешно.</span><span class="sxs-lookup"><span data-stu-id="c2738-916">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="c2738-917">Сама задача отменяется или создает исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-917">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="c2738-918">В этом случае вы обрабатываете <xref:System.AggregateException> исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-918">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="c2738-919"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Свойство содержит сведения об исключении или исключениях.</span><span class="sxs-lookup"><span data-stu-id="c2738-919">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="c2738-920">Интервал, заданный `timeout` пройдет указанное время.</span><span class="sxs-lookup"><span data-stu-id="c2738-920">The interval defined by `timeout` elapses.</span></span> <span data-ttu-id="c2738-921">В этом случае текущий поток возобновляет выполнение, а метод возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="c2738-921">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-922">В следующем примере запускается задача, которая создает пять миллионов случайных целых чисел от 0 до 100 и вычисляет их среднее значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-922">The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="c2738-923">В примере используется <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> метод для ожидания в миллисекундах 150 приложения.</span><span class="sxs-lookup"><span data-stu-id="c2738-923">The example uses the <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> method to wait for the application to complete within 150 milliseconds.</span></span> <span data-ttu-id="c2738-924">Если приложение обычно завершает, задача отображается сумма и среднее значение случайных чисел, он сформирован.</span><span class="sxs-lookup"><span data-stu-id="c2738-924">If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</span></span> <span data-ttu-id="c2738-925">Если истек интервал времени ожидания, выводится сообщение перед завершением.</span><span class="sxs-lookup"><span data-stu-id="c2738-925">If the timeout interval has elapsed, the example displays a message before it terminates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-926">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-926">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-927"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-927"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="c2738-928">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-928">-or-</span></span> 
 <span data-ttu-id="c2738-929">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-929"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c2738-930">Задача отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-930">The task was canceled.</span></span> <span data-ttu-id="c2738-931">Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит объект <see cref="T:System.Threading.Tasks.TaskCanceledException" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-931">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="c2738-932">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-932">-or-</span></span> 
<span data-ttu-id="c2738-933">Во время выполнения задачи возникло исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-933">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="c2738-934">Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит сведения об исключении или исключениях.</span><span class="sxs-lookup"><span data-stu-id="c2738-934">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="c2738-935">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-935">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-936">Токен отмены, который нужно контролировать во время ожидания выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-936">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="c2738-937">Ожидает завершения выполнения задачи <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-937">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span> <span data-ttu-id="c2738-938">Ожидание завершается, если время ожидания истекает или токен отмены отменяется до завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-938">The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes.</span></span></summary>
        <returns><span data-ttu-id="c2738-939">Значение <see langword="true" />, если <see cref="T:System.Threading.Tasks.Task" /> завершил выполнение в течение отведенного времени; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-939"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-940"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> — Это метод синхронизации, который вызывающий поток ожидания для текущего экземпляра задачи завершения, пока не произойдет одно из следующих:</span><span class="sxs-lookup"><span data-stu-id="c2738-940"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="c2738-941">Задача завершается успешно.</span><span class="sxs-lookup"><span data-stu-id="c2738-941">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="c2738-942">Сама задача отменяется или создает исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-942">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="c2738-943">В этом случае вы обрабатываете <xref:System.AggregateException> исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-943">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="c2738-944"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Свойство содержит сведения об исключении или исключениях.</span><span class="sxs-lookup"><span data-stu-id="c2738-944">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="c2738-945">`cancellationToken` Токен отмены отменяется.</span><span class="sxs-lookup"><span data-stu-id="c2738-945">The `cancellationToken` cancellation token is canceled.</span></span> <span data-ttu-id="c2738-946">В этом случае вызов <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> вызывает метод <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="c2738-946">In this case, the call to the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> method throws an <xref:System.OperationCanceledException>.</span></span>  
  
-   <span data-ttu-id="c2738-947">Интервал, заданный `millisecondsTimeout` пройдет указанное время.</span><span class="sxs-lookup"><span data-stu-id="c2738-947">The interval defined by `millisecondsTimeout` elapses.</span></span> <span data-ttu-id="c2738-948">В этом случае текущий поток возобновляет выполнение, а метод возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="c2738-948">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c2738-949">Отмена `cancellationToken` токен отмены никак не влияет на выполняемая задача, если он также был передан токен отмены и подготовиться к обработке отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-949">Canceling the `cancellationToken` cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</span></span> <span data-ttu-id="c2738-950">Передача `cancellationToken` в этот метод просто позволяет отменить ожидание от некоторых условий.</span><span class="sxs-lookup"><span data-stu-id="c2738-950">Passing the `cancellationToken` object to this method simply allows the wait to be canceled based on some condition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-951">В следующем примере вызывается <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> метод, чтобы предоставить значение времени ожидания и отмену токен, который можно завершить ожидания завершения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-951">The following example calls the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> method to provide both a timeout value and a cancellation token that can end the wait for a task's completion.</span></span> <span data-ttu-id="c2738-952">Новый поток запущен и выполняет `CancelToken` метод, который приостанавливает и затем вызывает <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> метод отменить токенов отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-952">A new thread is started and executes the `CancelToken` method, which pauses and then calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to cancel the cancellation tokens.</span></span> <span data-ttu-id="c2738-953">Задача запуска затем откладывается на 5 секунд.</span><span class="sxs-lookup"><span data-stu-id="c2738-953">A task is then launched and delays for 5 seconds.</span></span> <span data-ttu-id="c2738-954"><xref:System.Threading.Tasks.Task.Wait%2A> Метод вызывается для ожидания завершения задачи и предоставляется краткое ожидания и токен отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-954">The <xref:System.Threading.Tasks.Task.Wait%2A> method is then called to wait for the task's completion and is provided both a brief timeout value and a cancellation token.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 <span data-ttu-id="c2738-955">Обратите внимание на то, что точное выходные данные примера зависит ли ожидание было отменено из-за токен отмены, или из-за истечения времени ожидания истекло.</span><span class="sxs-lookup"><span data-stu-id="c2738-955">Note that the precise output from the example depends on whether the wait was canceled because of the cancellation token or because the timeout interval elapsed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="c2738-956">Объект <paramref name="cancellationToken" /> отменен.</span><span class="sxs-lookup"><span data-stu-id="c2738-956">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-957">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-957">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-958">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-958"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c2738-959">Задача отменена.</span><span class="sxs-lookup"><span data-stu-id="c2738-959">The task was canceled.</span></span> <span data-ttu-id="c2738-960">Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит объект <see cref="T:System.Threading.Tasks.TaskCanceledException" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-960">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="c2738-961">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-961">-or-</span></span> 
<span data-ttu-id="c2738-962">Во время выполнения задачи возникло исключение.</span><span class="sxs-lookup"><span data-stu-id="c2738-962">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="c2738-963">Коллекция <see cref="P:System.AggregateException.InnerExceptions" /> содержит сведения об исключении или исключениях.</span><span class="sxs-lookup"><span data-stu-id="c2738-963">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-964">Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-964">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-965">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</span><span class="sxs-lookup"><span data-stu-id="c2738-965">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <summary><span data-ttu-id="c2738-966">Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-966">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c2738-967">В следующем примере запускается 10 задач, каждая из которых передается индекс как объект состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-967">The following example starts 10 tasks, each of which is passed an index as a state object.</span></span> <span data-ttu-id="c2738-968">Задачи с индексом от двух до пяти вызывать исключения.</span><span class="sxs-lookup"><span data-stu-id="c2738-968">Tasks with an index from two to five throw exceptions.</span></span> <span data-ttu-id="c2738-969">Вызов <xref:System.Threading.Tasks.Task.WaitAll%2A> метод создает оболочку для всех исключений в <xref:System.AggregateException> объект и передает его в вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="c2738-969">The call to the <xref:System.Threading.Tasks.Task.WaitAll%2A> method wraps all exceptions in an <xref:System.AggregateException> object and propagates it to the calling thread.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-970">Один или несколько объектов <see cref="T:System.Threading.Tasks.Task" /> в <paramref name="tasks" /> были удалены.</span><span class="sxs-lookup"><span data-stu-id="c2738-970">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-971">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-971">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-972">Аргумент <paramref name="tasks" /> содержит элемент NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-972">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
<span data-ttu-id="c2738-973">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-973">-or-</span></span> 
<span data-ttu-id="c2738-974">Аргумент <paramref name="tasks" /> — пустой массив.</span><span class="sxs-lookup"><span data-stu-id="c2738-974">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c2738-975">По крайней мере один из экземпляров <see cref="T:System.Threading.Tasks.Task" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-975">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="c2738-976">Если задача была отменена, <see cref="T:System.AggregateException" /> содержит исключение <see cref="T:System.OperationCanceledException" /> в коллекции <see cref="P:System.AggregateException.InnerExceptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-976">If a task was canceled, the <see cref="T:System.AggregateException" /> exception contains an <see cref="T:System.OperationCanceledException" /> exception in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="c2738-977">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-977">-or-</span></span> 
<span data-ttu-id="c2738-978">Возникло исключение во время выполнения по крайней мере одного из экземпляров <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-978">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-979">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</span><span class="sxs-lookup"><span data-stu-id="c2738-979">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="c2738-980">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-980">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c2738-981">Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного числа миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="c2738-981">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="c2738-982"><see langword="true" />, если все экземпляры <see cref="T:System.Threading.Tasks.Task" /> завершили выполнение в выделенное время; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-982"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-983">Один или несколько объектов <see cref="T:System.Threading.Tasks.Task" /> в <paramref name="tasks" /> были удалены.</span><span class="sxs-lookup"><span data-stu-id="c2738-983">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-984">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-984">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c2738-985">По крайней мере один из экземпляров <see cref="T:System.Threading.Tasks.Task" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-985">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="c2738-986">Если задача была отменена, <see cref="T:System.AggregateException" /> содержит <see cref="T:System.OperationCanceledException" /> в коллекции <see cref="P:System.AggregateException.InnerExceptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-986">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="c2738-987">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-987">-or-</span></span> 
<span data-ttu-id="c2738-988">Возникло исключение во время выполнения по крайней мере одного из экземпляров <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-988">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-989">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-989"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-990">Аргумент <paramref name="tasks" /> содержит элемент NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-990">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
<span data-ttu-id="c2738-991">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-991">-or-</span></span> 
<span data-ttu-id="c2738-992">Аргумент <paramref name="tasks" /> — пустой массив.</span><span class="sxs-lookup"><span data-stu-id="c2738-992">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-993">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</span><span class="sxs-lookup"><span data-stu-id="c2738-993">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-994">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который нужно контролировать во время ожидания выполнения задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-994">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for the tasks to complete.</span></span></param>
        <summary><span data-ttu-id="c2738-995">Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" />, пока ожидание не будет отменено.</span><span class="sxs-lookup"><span data-stu-id="c2738-995">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution unless the wait is cancelled.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-996">`cancellationToken` Аргумент используется для отмены операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-996">The `cancellationToken` argument is used to cancel the wait operation.</span></span> <span data-ttu-id="c2738-997">— Это отдельная операция отмены задач и путем <xref:System.AggregateException> как указано выше.</span><span class="sxs-lookup"><span data-stu-id="c2738-997">Cancellation of the tasks is a distinct operation, and is signaled by the <xref:System.AggregateException> as noted above.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="c2738-998">Объект <paramref name="cancellationToken" /> отменен.</span><span class="sxs-lookup"><span data-stu-id="c2738-998">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-999">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-999">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c2738-1000">По крайней мере один из экземпляров <see cref="T:System.Threading.Tasks.Task" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-1000">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="c2738-1001">Если задача была отменена, <see cref="T:System.AggregateException" /> содержит <see cref="T:System.OperationCanceledException" /> в коллекции <see cref="P:System.AggregateException.InnerExceptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1001">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="c2738-1002">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-1002">-or-</span></span> 
<span data-ttu-id="c2738-1003">Возникло исключение во время выполнения по крайней мере одного из экземпляров <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1003">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1004">Аргумент <paramref name="tasks" /> содержит элемент NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-1004">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
<span data-ttu-id="c2738-1005">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-1005">-or-</span></span> 
<span data-ttu-id="c2738-1006">Аргумент <paramref name="tasks" /> — пустой массив.</span><span class="sxs-lookup"><span data-stu-id="c2738-1006">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-1007">Один или несколько объектов <see cref="T:System.Threading.Tasks.Task" /> в <paramref name="tasks" /> были удалены.</span><span class="sxs-lookup"><span data-stu-id="c2738-1007">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1008">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</span><span class="sxs-lookup"><span data-stu-id="c2738-1008">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="c2738-1009">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1009">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c2738-1010">Ожидает завершения выполнения всех указанных отменяемых объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного временного интервала.</span><span class="sxs-lookup"><span data-stu-id="c2738-1010">Waits for all of the provided cancellable <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="c2738-1011"><see langword="true" />, если все экземпляры <see cref="T:System.Threading.Tasks.Task" /> завершили выполнение в выделенное время; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1011"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-1012">Один или несколько объектов <see cref="T:System.Threading.Tasks.Task" /> в <paramref name="tasks" /> были удалены.</span><span class="sxs-lookup"><span data-stu-id="c2738-1012">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1013">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1013">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c2738-1014">По крайней мере один из экземпляров <see cref="T:System.Threading.Tasks.Task" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-1014">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="c2738-1015">Если задача была отменена, <see cref="T:System.AggregateException" /> содержит <see cref="T:System.OperationCanceledException" /> в коллекции <see cref="P:System.AggregateException.InnerExceptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1015">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="c2738-1016">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-1016">-or-</span></span> 
<span data-ttu-id="c2738-1017">Возникло исключение во время выполнения по крайней мере одного из экземпляров <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1017">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-1018"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1018"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="c2738-1019">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-1019">-or-</span></span> 
 <span data-ttu-id="c2738-1020">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1020"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1021">Аргумент <paramref name="tasks" /> содержит элемент NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-1021">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
<span data-ttu-id="c2738-1022">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-1022">-or-</span></span> 
<span data-ttu-id="c2738-1023">Аргумент <paramref name="tasks" /> — пустой массив.</span><span class="sxs-lookup"><span data-stu-id="c2738-1023">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1024">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</span><span class="sxs-lookup"><span data-stu-id="c2738-1024">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="c2738-1025">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1025">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-1026">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который нужно контролировать во время ожидания выполнения задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1026">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for the tasks to complete.</span></span></param>
        <summary><span data-ttu-id="c2738-1027">Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного числа миллисекунд или до отмены ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1027">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds or until the wait is cancelled.</span></span></summary>
        <returns><span data-ttu-id="c2738-1028"><see langword="true" />, если все экземпляры <see cref="T:System.Threading.Tasks.Task" /> завершили выполнение в выделенное время; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1028"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-1029">`cancellationToken` Аргумент используется для отмены операции ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1029">The `cancellationToken` argument is used to cancel the wait operation.</span></span> <span data-ttu-id="c2738-1030">— Это отдельная операция отмены задач и путем <xref:System.AggregateException> указано выше.</span><span class="sxs-lookup"><span data-stu-id="c2738-1030">Cancellation of the tasks is a distinct operation, and is signaled by the <xref:System.AggregateException> noted above.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-1031">Один или несколько объектов <see cref="T:System.Threading.Tasks.Task" /> в <paramref name="tasks" /> были удалены.</span><span class="sxs-lookup"><span data-stu-id="c2738-1031">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1032">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1032">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="c2738-1033">По крайней мере один из экземпляров <see cref="T:System.Threading.Tasks.Task" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-1033">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="c2738-1034">Если задача была отменена, <see cref="T:System.AggregateException" /> содержит <see cref="T:System.OperationCanceledException" /> в коллекции <see cref="P:System.AggregateException.InnerExceptions" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1034">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="c2738-1035">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-1035">-or-</span></span> 
<span data-ttu-id="c2738-1036">Возникло исключение во время выполнения по крайней мере одного из экземпляров <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1036">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-1037">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1037"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1038">Аргумент <paramref name="tasks" /> содержит элемент NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-1038">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
<span data-ttu-id="c2738-1039">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-1039">-or-</span></span> 
<span data-ttu-id="c2738-1040">Аргумент <paramref name="tasks" /> — пустой массив.</span><span class="sxs-lookup"><span data-stu-id="c2738-1040">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="c2738-1041">Объект <paramref name="cancellationToken" /> отменен.</span><span class="sxs-lookup"><span data-stu-id="c2738-1041">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-1042">Ожидает завершения выполнения любого из указанных объектов <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1042">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1043">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</span><span class="sxs-lookup"><span data-stu-id="c2738-1043">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <summary><span data-ttu-id="c2738-1044">Ожидает завершения выполнения любого из указанных объектов <see cref="T:System.Threading.Tasks.Task" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1044">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
        <returns><span data-ttu-id="c2738-1045">Индекс завершенного объекта <see cref="T:System.Threading.Tasks.Task" /> в массиве <paramref name="tasks" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1045">The index of the completed <see cref="T:System.Threading.Tasks.Task" /> object in the <paramref name="tasks" /> array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c2738-1046">Следующий пример запускает пять задач, каждая из которых бездействует в течение как минимум 50 миллисекунд или более 1,050 миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="c2738-1046">The following example launches five tasks, each of which sleeps for a minimum of 50 milliseconds or a maximum of 1,050 milliseconds.</span></span> <span data-ttu-id="c2738-1047"><xref:System.Threading.Tasks.Task.WaitAny%2A> Метод затем ожидает либо завершения задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1047">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method then waits for any of the tasks to complete.</span></span> <span data-ttu-id="c2738-1048">В примере отображается идентификатор задачи завершения ожидания задачи, а также текущее состояние всех задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1048">The example displays the task ID of the task that ended the wait, as well as the current status of all the tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-1049">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-1049">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1050">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1050">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1051">Аргумент <paramref name="tasks" /> содержит элемент NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-1051">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1052">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</span><span class="sxs-lookup"><span data-stu-id="c2738-1052">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="c2738-1053">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1053">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c2738-1054">Ожидает завершения выполнения любого из указанных объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного числа миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="c2738-1054">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="c2738-1055">Индекс завершенной задачи в аргументе-массиве <paramref name="tasks" /> или -1, если истекло время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1055">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-1056">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-1056">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1057">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1057">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-1058">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1058"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1059">Аргумент <paramref name="tasks" /> содержит элемент NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-1059">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1060">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</span><span class="sxs-lookup"><span data-stu-id="c2738-1060">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-1061">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который нужно контролировать во время ожидания выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-1061">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for a task to complete.</span></span></param>
        <summary><span data-ttu-id="c2738-1062">Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" />, пока ожидание не будет отменено.</span><span class="sxs-lookup"><span data-stu-id="c2738-1062">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution unless the wait is cancelled.</span></span></summary>
        <returns><span data-ttu-id="c2738-1063">Индекс завершенной задачи в аргументе-массиве <paramref name="tasks" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1063">The index of the completed task in the <paramref name="tasks" /> array argument.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-1064">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-1064">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1065">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1065">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1066">Аргумент <paramref name="tasks" /> содержит элемент NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-1066">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="c2738-1067">Объект <paramref name="cancellationToken" /> отменен.</span><span class="sxs-lookup"><span data-stu-id="c2738-1067">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1068">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</span><span class="sxs-lookup"><span data-stu-id="c2738-1068">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="c2738-1069">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1069">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="c2738-1070">Ожидает завершения выполнения любого из указанных отменяемых объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного временного интервала.</span><span class="sxs-lookup"><span data-stu-id="c2738-1070">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="c2738-1071">Индекс завершенной задачи в аргументе-массиве <paramref name="tasks" /> или -1, если истекло время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1071">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-1072">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-1072">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1073">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1073">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-1074">Параметр <see cref="P:System.TimeSpan.TotalMilliseconds" /> аргумента <paramref name="timeout" /> является отрицательным числом, отличающимся от -1, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1074">The <see cref="P:System.TimeSpan.TotalMilliseconds" /> property of the <paramref name="timeout" /> argument is a negative number other than -1, which represents an infinite time-out.</span></span> 
<span data-ttu-id="c2738-1075">-или-</span><span class="sxs-lookup"><span data-stu-id="c2738-1075">-or-</span></span> 
<span data-ttu-id="c2738-1076">Свойство <paramref name="timeout" /> аргумента <see cref="P:System.TimeSpan.TotalMilliseconds" /> больше чем <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1076">The <see cref="P:System.TimeSpan.TotalMilliseconds" /> property of the <paramref name="timeout" /> argument is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1077">Аргумент <paramref name="tasks" /> содержит элемент NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-1077">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1078">Массив экземпляров <see cref="T:System.Threading.Tasks.Task" />, завершения выполнения которых следует дождаться.</span><span class="sxs-lookup"><span data-stu-id="c2738-1078">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="c2738-1079">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1079">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c2738-1080">Токен <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />, который нужно контролировать во время ожидания выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-1080">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for a task to complete.</span></span></param>
        <summary><span data-ttu-id="c2738-1081">Ожидает завершения выполнения всех указанных объектов <see cref="T:System.Threading.Tasks.Task" /> в течение указанного числа миллисекунд или до отмены токена отмены.</span><span class="sxs-lookup"><span data-stu-id="c2738-1081">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled.</span></span></summary>
        <returns><span data-ttu-id="c2738-1082">Индекс завершенной задачи в аргументе-массиве <paramref name="tasks" /> или -1, если истекло время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1082">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c2738-1083">Объект <see cref="T:System.Threading.Tasks.Task" /> удален.</span><span class="sxs-lookup"><span data-stu-id="c2738-1083">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1084">Аргумент <paramref name="tasks" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1084">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c2738-1085">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1085"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1086">Аргумент <paramref name="tasks" /> содержит элемент NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-1086">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="c2738-1087">Объект <paramref name="cancellationToken" /> отменен.</span><span class="sxs-lookup"><span data-stu-id="c2738-1087">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-1088">Создает задачу, которая будет выполнена после выполнения всех предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1088">Creates a task that will complete when all of the supplied tasks have completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1089">Задачи, завершение которых требуется подождать.</span><span class="sxs-lookup"><span data-stu-id="c2738-1089">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="c2738-1090">Создает задачу, которая будет выполнена, когда все объекты <see cref="T:System.Threading.Tasks.Task" /> в перечисляемой коллекции будут завершены.</span><span class="sxs-lookup"><span data-stu-id="c2738-1090">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task" /> objects in an enumerable collection have completed.</span></span></summary>
        <returns><span data-ttu-id="c2738-1091">Задача, представляющая завершение всех предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1091">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-1092">Перегрузки <xref:System.Threading.Tasks.Task.WhenAll%2A> метода, который возвращает <xref:System.Threading.Tasks.Task> объект обычно вызываются, если вы заинтересованы в состояние набора задач или исключения, создаваемые набор задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1092">The overloads of the <xref:System.Threading.Tasks.Task.WhenAll%2A> method that return a <xref:System.Threading.Tasks.Task> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c2738-1093">Вызов <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> метод не блокирует вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="c2738-1093">The call to <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method does not block the calling thread.</span></span>  
  
 <span data-ttu-id="c2738-1094">Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится также в <xref:System.Threading.Tasks.TaskStatus.Faulted> состояния, где его исключения будут содержать совокупность набор без оболочки исключений из всех предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1094">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state,  where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="c2738-1095">Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращенная задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.Canceled> состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-1095">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="c2738-1096">Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-1096">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="c2738-1097">Если предоставленный массив/перечисление содержит никакие задачи, возвращаемой задачи сразу переходит в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние перед возвратом вызывающей стороне.</span><span class="sxs-lookup"><span data-stu-id="c2738-1097">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-1098">В следующем примере создается набор задач, проверьте связь с URL-адреса в массиве.</span><span class="sxs-lookup"><span data-stu-id="c2738-1098">The following example creates a set of tasks that ping the URLs in an array.</span></span> <span data-ttu-id="c2738-1099">Задачи будут храниться в `List<Task>` коллекции, который передается <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-1099">The tasks are stored in a `List<Task>` collection that is passed to the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method.</span></span> <span data-ttu-id="c2738-1100">После вызова <xref:System.Threading.Tasks.Task.Wait%2A> метод гарантирует, что все потоки завершены, пример просматривает <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> свойства, чтобы определить, ли все задачи в состоянии faulted.</span><span class="sxs-lookup"><span data-stu-id="c2738-1100">After the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that all threads have completed, the example examines the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property to determine whether any tasks have faulted.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1101">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1101">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1102">Коллекция <paramref name="tasks" /> содержала задачу <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1102">The <paramref name="tasks" /> collection contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1103">Задачи, завершение которых требуется подождать.</span><span class="sxs-lookup"><span data-stu-id="c2738-1103">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="c2738-1104">Создает задачу, которая будет выполнена, когда все <see cref="T:System.Threading.Tasks.Task" /> объекты в массиве будут завершены.</span><span class="sxs-lookup"><span data-stu-id="c2738-1104">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task" /> objects in an array have completed.</span></span></summary>
        <returns><span data-ttu-id="c2738-1105">Задача, представляющая завершение всех предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1105">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-1106">Перегрузки <xref:System.Threading.Tasks.Task.WhenAll%2A> метода, который возвращает <xref:System.Threading.Tasks.Task> объект обычно вызываются, если вы заинтересованы в состояние набора задач или исключения, создаваемые набор задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1106">The overloads of the <xref:System.Threading.Tasks.Task.WhenAll%2A> method that return a <xref:System.Threading.Tasks.Task> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c2738-1107">Вызов <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> метод не блокирует вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="c2738-1107">The call to <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> method does not block the calling thread.</span></span>  
  
 <span data-ttu-id="c2738-1108">Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится также в <xref:System.Threading.Tasks.TaskStatus.Faulted> состояния, где его исключения будут содержать совокупность набор без оболочки исключений из всех предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1108">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="c2738-1109">Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращенная задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.Canceled> состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-1109">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="c2738-1110">Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-1110">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="c2738-1111">Если предоставленный массив/перечисление содержит никакие задачи, возвращаемой задачи сразу переходит в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние перед возвратом вызывающей стороне.</span><span class="sxs-lookup"><span data-stu-id="c2738-1111">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-1112">В следующем примере создается набор задач, проверьте связь с URL-адреса в массиве.</span><span class="sxs-lookup"><span data-stu-id="c2738-1112">The following example creates a set of tasks that ping the URLs in an array.</span></span> <span data-ttu-id="c2738-1113">Задачи будут храниться в `List<Task>` коллекцию, которая преобразуется в массив и передается <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> метод.</span><span class="sxs-lookup"><span data-stu-id="c2738-1113">The tasks are stored in a `List<Task>` collection that is converted to an array and passed to the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method.</span></span> <span data-ttu-id="c2738-1114">После вызова <xref:System.Threading.Tasks.Task.Wait%2A> метод гарантирует, что все потоки завершены, пример просматривает <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> свойства, чтобы определить, ли все задачи в состоянии faulted.</span><span class="sxs-lookup"><span data-stu-id="c2738-1114">After the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that all threads have completed, the example examines the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property to determine whether any tasks have faulted.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1115">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1115">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1116">Массив <paramref name="tasks" />, содержащший задачу <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1116">The <paramref name="tasks" /> array contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-1117">Тип завершенной задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-1117">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="c2738-1118">Задачи, завершение которых требуется подождать.</span><span class="sxs-lookup"><span data-stu-id="c2738-1118">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="c2738-1119">Создает задачу, которая будет выполнена, когда все объекты <see cref="T:System.Threading.Tasks.Task`1" /> в перечисляемой коллекции будут завершены.</span><span class="sxs-lookup"><span data-stu-id="c2738-1119">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task`1" /> objects in an enumerable collection have completed.</span></span></summary>
        <returns><span data-ttu-id="c2738-1120">Задача, представляющая завершение всех предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1120">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-1121">Вызов <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> метод не блокирует вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="c2738-1121">The call to <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> method does not block the calling thread.</span></span> <span data-ttu-id="c2738-1122">Тем не менее вызов к возвращенному <xref:System.Threading.Tasks.Task%601.Result%2A> свойство блокирует вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="c2738-1122">However, a call to the returned <xref:System.Threading.Tasks.Task%601.Result%2A> property does block the calling thread.</span></span>  
  
 <span data-ttu-id="c2738-1123">Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится также в <xref:System.Threading.Tasks.TaskStatus.Faulted> состояния, где его исключения будут содержать совокупность набор без оболочки исключений из всех предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1123">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="c2738-1124">Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращенная задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.Canceled> состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-1124">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="c2738-1125">Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-1125">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  <span data-ttu-id="c2738-1126"><xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Возвращаемой задачи будет установлено в массив, содержащий все результаты из предоставленных задач в том же порядке, так как они были предоставлены (например, если входные данные задачи массива t1, t2, t3, выходные данные задачи <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> свойство возвратит `TResult[]` где `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span><span class="sxs-lookup"><span data-stu-id="c2738-1126">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property will return an `TResult[]` where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span></span>  
  
 <span data-ttu-id="c2738-1127">Если `tasks` аргумент содержит никакие задачи, возвращаемой задачи сразу переходит в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние перед возвратом вызывающей стороне.</span><span class="sxs-lookup"><span data-stu-id="c2738-1127">If the `tasks` argument contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span> <span data-ttu-id="c2738-1128">Возвращенный `TResult[]` будет состоять из 0 элементов.</span><span class="sxs-lookup"><span data-stu-id="c2738-1128">The returned `TResult[]` will be an array of 0 elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-1129">В следующем примере создается десять задач, каждая из которых создает экземпляр генератора случайных чисел, который создает 1000 случайных чисел от 1 до 1000 и вычисляет их среднее значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-1129">The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</span></span> <span data-ttu-id="c2738-1130"><xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Метод используется для задержки при создании экземпляра генераторов случайных чисел, таким образом, они не создаются с использованием идентичных начальных значений.</span><span class="sxs-lookup"><span data-stu-id="c2738-1130">The <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</span></span> <span data-ttu-id="c2738-1131">Вызов <xref:System.Threading.Tasks.Task.WhenAll%2A> метод затем возвращает <xref:System.Int64> массив, содержащий среднего значения, вычисленные поиском решения для каждой задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-1131">The call to the <xref:System.Threading.Tasks.Task.WhenAll%2A> method then returns an <xref:System.Int64> array that contains the mean computed by each task.</span></span> <span data-ttu-id="c2738-1132">Затем они используются для вычисления общей среднее значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-1132">These are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 <span data-ttu-id="c2738-1133">В этом случае десяти отдельных задач хранятся в <xref:System.Collections.Generic.List%601> объекта.</span><span class="sxs-lookup"><span data-stu-id="c2738-1133">In this case, the ten individual tasks are stored in a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="c2738-1134">Интерфейс <xref:System.Collections.Generic.List%601> реализует интерфейс <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="c2738-1134"><xref:System.Collections.Generic.List%601> implements the <xref:System.Collections.Generic.IEnumerable%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1135">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1135">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1136">Коллекция <paramref name="tasks" /> содержала задачу <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1136">The <paramref name="tasks" /> collection contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-1137">Тип завершенной задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-1137">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="c2738-1138">Задачи, завершение которых требуется подождать.</span><span class="sxs-lookup"><span data-stu-id="c2738-1138">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="c2738-1139">Создает задачу, которая будет выполнена, когда все <see cref="T:System.Threading.Tasks.Task`1" /> объекты в массиве будут завершены.</span><span class="sxs-lookup"><span data-stu-id="c2738-1139">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task`1" /> objects in an array have completed.</span></span></summary>
        <returns><span data-ttu-id="c2738-1140">Задача, представляющая завершение всех предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1140">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-1141">Вызов <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> метод не блокирует вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="c2738-1141">The call to <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> method does not block the calling thread.</span></span> <span data-ttu-id="c2738-1142">Тем не менее вызов к возвращенному <xref:System.Threading.Tasks.Task%601.Result%2A> свойство блокирует вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="c2738-1142">However, a call to the returned <xref:System.Threading.Tasks.Task%601.Result%2A> property does block the calling thread.</span></span>  
  
 <span data-ttu-id="c2738-1143">Если любой из предоставленных задач завершается в состоянии сбоя, возвращенная задача завершится также в <xref:System.Threading.Tasks.TaskStatus.Faulted> состояния, где его исключения будут содержать совокупность набор без оболочки исключений из всех предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1143">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="c2738-1144">Если ни один из предоставленных задач в состоянии faulted, но по крайней мере один из них было отменено, возвращенная задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.Canceled> состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-1144">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="c2738-1145">Если ни одна из задач в состоянии сбоя, и ни одна из задач были отменены, результирующая задача будет завершен через <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-1145">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  <span data-ttu-id="c2738-1146"><xref:System.Threading.Tasks.Task%601.Result%2A> Возвращаемой задачи устанавливается в массив, содержащий все результаты из предоставленных задач в том же порядке, так как они были предоставлены (например, если входные данные задачи массива t1, t2, t3, выходные данные задачи <xref:System.Threading.Tasks.Task%601.Result%2A> вернет `TResult[]` где `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span><span class="sxs-lookup"><span data-stu-id="c2738-1146">The <xref:System.Threading.Tasks.Task%601.Result%2A> of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output   task's <xref:System.Threading.Tasks.Task%601.Result%2A> will return an `TResult[]` where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span></span>  
  
 <span data-ttu-id="c2738-1147">Если предоставленный массив/перечисление содержит никакие задачи, возвращаемой задачи сразу переходит в <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> состояние перед возвратом вызывающей стороне.</span><span class="sxs-lookup"><span data-stu-id="c2738-1147">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  <span data-ttu-id="c2738-1148">Возвращенный `TResult[]` будет состоять из 0 элементов.</span><span class="sxs-lookup"><span data-stu-id="c2738-1148">The returned `TResult[]` will be an array of 0 elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c2738-1149">В следующем примере создается десять задач, каждая из которых создает экземпляр генератора случайных чисел, который создает 1000 случайных чисел от 1 до 1000 и вычисляет их среднее значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-1149">The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</span></span> <span data-ttu-id="c2738-1150">В этом случае десяти отдельных задач хранятся в `Task<Int64>` массива.</span><span class="sxs-lookup"><span data-stu-id="c2738-1150">In this case, the ten individual tasks are stored in a `Task<Int64>` array.</span></span>  <span data-ttu-id="c2738-1151"><xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Метод используется для задержки при создании экземпляра генераторов случайных чисел, таким образом, они не создаются с использованием идентичных начальных значений.</span><span class="sxs-lookup"><span data-stu-id="c2738-1151">The <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</span></span> <span data-ttu-id="c2738-1152">Вызов <xref:System.Threading.Tasks.Task.WhenAll%2A> метод затем возвращает <xref:System.Int64> массив, содержащий среднего значения, вычисленные поиском решения для каждой задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-1152">The call to the <xref:System.Threading.Tasks.Task.WhenAll%2A> method then returns an <xref:System.Int64> array that contains the mean computed by each task.</span></span> <span data-ttu-id="c2738-1153">Затем они используются для вычисления общей среднее значение.</span><span class="sxs-lookup"><span data-stu-id="c2738-1153">These are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1154">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1154">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1155">Массив <paramref name="tasks" />, содержащший задачу <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1155">The <paramref name="tasks" /> array contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c2738-1156">Создает задачу, которая будет выполнена после выполнения любой из предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1156">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1157">Задачи, завершение которых требуется подождать.</span><span class="sxs-lookup"><span data-stu-id="c2738-1157">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="c2738-1158">Создает задачу, которая будет выполнена после выполнения любой из предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1158">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="c2738-1159">Задача, представляющая завершение одной из предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1159">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="c2738-1160">Результат возвращенной задачи — задача, которая была завершена.</span><span class="sxs-lookup"><span data-stu-id="c2738-1160">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-1161">Возвращаемая задача будет выполнена, когда любой из предоставленных задач завершения.</span><span class="sxs-lookup"><span data-stu-id="c2738-1161">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="c2738-1162">Возвращаемая задача всегда будет заканчиваться `RanToCompletion` состояния с помощью результирующего набора к первой задаче для завершения.</span><span class="sxs-lookup"><span data-stu-id="c2738-1162">The returned task will always end in the `RanToCompletion` state  with its Result set to the first task to complete.</span></span>  <span data-ttu-id="c2738-1163">Это справедливо, даже если завершился завершения первой задачи `Canceled` или `Faulted` состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-1163">This is true even if the first task to complete ended in the `Canceled` or `Faulted` state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1164">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1164">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1165">Массив <paramref name="tasks" /> содержал задачу со значением NULL или был пустым.</span><span class="sxs-lookup"><span data-stu-id="c2738-1165">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="c2738-1166">Задачи, завершение которых требуется подождать.</span><span class="sxs-lookup"><span data-stu-id="c2738-1166">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="c2738-1167">Создает задачу, которая будет выполнена после выполнения любой из предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1167">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="c2738-1168">Задача, представляющая завершение одной из предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1168">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="c2738-1169">Результат возвращенной задачи — задача, которая была завершена.</span><span class="sxs-lookup"><span data-stu-id="c2738-1169">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-1170">Возвращаемая задача будет выполнена, когда любой из предоставленных задач завершения.</span><span class="sxs-lookup"><span data-stu-id="c2738-1170">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="c2738-1171">Возвращаемая задача всегда будет заканчиваться `RanToCompletion` состояния с его `Result` присвоено первой задачи для завершения.</span><span class="sxs-lookup"><span data-stu-id="c2738-1171">The returned task will always end in the `RanToCompletion` state   with its `Result` set to the first task to complete.</span></span>  <span data-ttu-id="c2738-1172">Это справедливо, даже если завершился завершения первой задачи `Canceled` или `Faulted` состояния.</span><span class="sxs-lookup"><span data-stu-id="c2738-1172">This is true even if the first task to complete ended in the `Canceled` or `Faulted` state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1173">Аргумент <paramref name="tasks" /> имел значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-1173">The <paramref name="tasks" /> argument was null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1174">Массив <paramref name="tasks" /> содержал задачу со значением NULL или был пустым.</span><span class="sxs-lookup"><span data-stu-id="c2738-1174">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-1175">Тип завершенной задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-1175">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="c2738-1176">Задачи, завершение которых требуется подождать.</span><span class="sxs-lookup"><span data-stu-id="c2738-1176">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="c2738-1177">Создает задачу, которая будет выполнена после выполнения любой из предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1177">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="c2738-1178">Задача, представляющая завершение одной из предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1178">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="c2738-1179">Результат возвращенной задачи — задача, которая была завершена.</span><span class="sxs-lookup"><span data-stu-id="c2738-1179">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-1180">Возвращаемая задача будет выполнена, когда любой из предоставленных задач завершения.</span><span class="sxs-lookup"><span data-stu-id="c2738-1180">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="c2738-1181">Возвращаемая задача всегда будет заканчиваться в состоянии RanToCompletion результирующего набора к первой задаче для завершения.</span><span class="sxs-lookup"><span data-stu-id="c2738-1181">The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</span></span> <span data-ttu-id="c2738-1182">Это справедливо, даже если завершения выполнения первой задачи в состояние Canceled или Faulted.</span><span class="sxs-lookup"><span data-stu-id="c2738-1182">This is true even if the first task to complete ended in the Canceled or Faulted state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1183">Аргумент <paramref name="tasks" /> имел значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c2738-1183">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1184">Массив <paramref name="tasks" /> содержал задачу со значением NULL или был пустым.</span><span class="sxs-lookup"><span data-stu-id="c2738-1184">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="c2738-1185">Тип завершенной задачи.</span><span class="sxs-lookup"><span data-stu-id="c2738-1185">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="c2738-1186">Задачи, завершение которых требуется подождать.</span><span class="sxs-lookup"><span data-stu-id="c2738-1186">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="c2738-1187">Создает задачу, которая будет выполнена после выполнения любой из предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1187">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="c2738-1188">Задача, представляющая завершение одной из предоставленных задач.</span><span class="sxs-lookup"><span data-stu-id="c2738-1188">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="c2738-1189">Результат возвращенной задачи — задача, которая была завершена.</span><span class="sxs-lookup"><span data-stu-id="c2738-1189">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-1190">Возвращаемая задача будет выполнена, когда любой из предоставленных задач завершения.</span><span class="sxs-lookup"><span data-stu-id="c2738-1190">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="c2738-1191">Возвращаемая задача всегда будет заканчиваться в состоянии RanToCompletion результирующего набора к первой задаче для завершения.</span><span class="sxs-lookup"><span data-stu-id="c2738-1191">The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</span></span> <span data-ttu-id="c2738-1192">Это справедливо, даже если завершения выполнения первой задачи в состояние Canceled или Faulted.</span><span class="sxs-lookup"><span data-stu-id="c2738-1192">This is true even if the first task to complete ended in the Canceled or Faulted state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c2738-1193">Аргумент <paramref name="tasks" /> имел значение NULL.</span><span class="sxs-lookup"><span data-stu-id="c2738-1193">The <paramref name="tasks" /> argument was null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c2738-1194">Массив <paramref name="tasks" /> содержал задачу со значением NULL или был пустым.</span><span class="sxs-lookup"><span data-stu-id="c2738-1194">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c2738-1195">Создает поддерживающий ожидание объект задачи, который асинхронным образом выдает возврат текущему контексту, когда его ожидают.</span><span class="sxs-lookup"><span data-stu-id="c2738-1195">Creates an awaitable task that asynchronously yields back to the current context when awaited.</span></span></summary>
        <returns><span data-ttu-id="c2738-1196">Контекст, который при ожидании будет асинхронно переходить назад в текущий контекст во время ожидания.</span><span class="sxs-lookup"><span data-stu-id="c2738-1196">A context that, when awaited, will asynchronously transition back into the current context at the time of the await.</span></span> <span data-ttu-id="c2738-1197">Если текущий <see cref="T:System.Threading.SynchronizationContext" /> отличен от null, он также обрабатывается как текущий контекст.</span><span class="sxs-lookup"><span data-stu-id="c2738-1197">If the current <see cref="T:System.Threading.SynchronizationContext" /> is non-null, it is treated as the current context.</span></span> <span data-ttu-id="c2738-1198">В противном случае планировщик задач, связанный с задачей, выполняющейся в данный момент, рассматривается как текущий контекст.</span><span class="sxs-lookup"><span data-stu-id="c2738-1198">Otherwise, the task scheduler that is associated with the currently executing task is treated as the current context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c2738-1199">Можно использовать `await Task.Yield();` в асинхронном методе для принудительного завершения асинхронного метода.</span><span class="sxs-lookup"><span data-stu-id="c2738-1199">You can use `await Task.Yield();` in an asynchronous method to force the method to complete asynchronously.</span></span> <span data-ttu-id="c2738-1200">Если текущий контекст синхронизации (<xref:System.Threading.SynchronizationContext> объекта), этот поток будет публиковать в конце выполнения метода к этого контекста.</span><span class="sxs-lookup"><span data-stu-id="c2738-1200">If there is a current synchronization context (<xref:System.Threading.SynchronizationContext> object), this will post the remainder of the method's execution back to that context.</span></span> <span data-ttu-id="c2738-1201">Тем не менее контекст будет решить, как назначать приоритет этой работы по отношению к другим операциям, может быть отложена.</span><span class="sxs-lookup"><span data-stu-id="c2738-1201">However, the context will decide how to prioritize this work relative to other work that may be pending.</span></span> <span data-ttu-id="c2738-1202">Контекст синхронизации, которая присутствует в потоке пользовательского интерфейса в большинстве сред пользовательского интерфейса будет часто определения приоритета работы, отправляется выше, чем входных данных и подготовки к просмотру рабочего контекста.</span><span class="sxs-lookup"><span data-stu-id="c2738-1202">The synchronization context that is present on a UI thread in most UI environments will often prioritize work posted to the context higher than input and rendering work.</span></span> <span data-ttu-id="c2738-1203">По этой причине не следует полагаться на `await Task.Yield();` для сохранения отклика пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="c2738-1203">For this reason, do not rely on `await Task.Yield();` to keep a UI responsive.</span></span>  <span data-ttu-id="c2738-1204">Дополнительные сведения см. в записи [полезные абстракции снабженный ContinueWith](https://devblogs.microsoft.com/pfxteam/useful-abstractions-enabled-with-continuewith/) в параллельному программированию в блоге .NET.</span><span class="sxs-lookup"><span data-stu-id="c2738-1204">For more information, see the entry [Useful Abstractions Enabled with ContinueWith](https://devblogs.microsoft.com/pfxteam/useful-abstractions-enabled-with-continuewith/) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>