<Type Name="NetDataContractSerializer" FullName="System.Runtime.Serialization.NetDataContractSerializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a1825b1f341b0395f339f4eef4352cb29977282a" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53499817" /></Metadata><TypeSignature Language="C#" Value="public sealed class NetDataContractSerializer : System.Runtime.Serialization.XmlObjectSerializer, System.Runtime.Serialization.IFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NetDataContractSerializer extends System.Runtime.Serialization.XmlObjectSerializer implements class System.Runtime.Serialization.IFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Serialization.NetDataContractSerializer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NetDataContractSerializer&#xA;Inherits XmlObjectSerializer&#xA;Implements IFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetDataContractSerializer sealed : System::Runtime::Serialization::XmlObjectSerializer, System::Runtime::Serialization::IFormatter" />
  <TypeSignature Language="F#" Value="type NetDataContractSerializer = class&#xA;    inherit XmlObjectSerializer&#xA;    interface IFormatter" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Serialization</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Serialization.XmlObjectSerializer</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Сериализует и десериализует экземпляр типа в XML-поток или документ с помощью типов, предоставляемых .NET Framework. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существует одно важное отличие <xref:System.Runtime.Serialization.NetDataContractSerializer> от <xref:System.Runtime.Serialization.DataContractSerializer>: <xref:System.Runtime.Serialization.NetDataContractSerializer> включает информацию о типе CLR в сериализованный XML, а <xref:System.Runtime.Serialization.DataContractSerializer> этого не делает. Таким образом <xref:System.Runtime.Serialization.NetDataContractSerializer> может использоваться только при использовании одних и тех же типов CLR на концах сериализации.  
  
 Сериализатор может сериализовать типы, к которым применялся атрибут <xref:System.Runtime.Serialization.DataContractAttribute> или атрибут <xref:System.SerializableAttribute>. Он также сериализует типы, реализующие <xref:System.Runtime.Serialization.ISerializable>.  
  
 Дополнительные сведения о сериализации см. в разделе [сериализации и десериализации](~/docs/framework/wcf/feature-details/serialization-and-deserialization.md).  
  
## <a name="incompatibility-with-xelement"></a>Несовместимость с XElement  
 Класс <xref:System.Xml.Linq.XElement> используется для записи XML. Однако `NetDataContractSerializer` не может сериализовать экземпляр этого типа. Таким образом, следующий код, происходит сбой с исключением: «Корневой тип «System.Xml.Linq.XElement» не поддерживается на верхнем уровне NetDataContractSerializer, так как он является IXmlSerializable с `IsAny` = `true` и должен записывать все свое содержимое, включая корневой элемент.»  
  
 [!code-csharp[NetDataContractSerializer#15](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#15)]
 [!code-vb[NetDataContractSerializer#15](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#15)]  
  
 Однако если `XElement` используется в качестве типа поля или свойства класса, данные, содержащиеся в поле или свойстве, сериализуются. Это происходит потому, что данные являются членом класса и не являются верхним уровнем класса.  
  
   
  
## Examples  
 В следующем примере показана сериализация типа `Person` с помощью <xref:System.Runtime.Serialization.NetDataContractSerializer>. Атрибут <xref:System.Runtime.Serialization.DataContractAttribute> применяется к классу, а атрибут <xref:System.Runtime.Serialization.DataMemberAttribute> применяется к членам класса (включая закрытые члены), чтобы указать <xref:System.Runtime.Serialization.NetDataContractSerializer>, какие элементы сериализовать.  
  
 [!code-csharp[NetDataContractSerializer#0](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#0)]
 [!code-vb[NetDataContractSerializer#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.Serialization.DataContractSerializer" />
    <altmember cref="T:System.Runtime.Serialization.NetDataContractSerializer" />
    <altmember cref="T:System.Runtime.Serialization.XmlObjectSerializer" />
    <related type="Article" href="~/docs/framework/wcf/feature-details/serialization-and-deserialization.md">Сериализация и десериализация</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Serialization.NetDataContractSerializer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetDataContractSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetDataContractSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Serialization.NetDataContractSerializer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[NetDataContractSerializer#8](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#8)]
 [!code-vb[NetDataContractSerializer#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetDataContractSerializer (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.#ctor(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetDataContractSerializer(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.NetDataContractSerializer : System.Runtime.Serialization.StreamingContext -&gt; System.Runtime.Serialization.NetDataContractSerializer" Usage="new System.Runtime.Serialization.NetDataContractSerializer context" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий данные контекста.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Serialization.NetDataContractSerializer" /> с переданными данными контекста потоковой передачи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Runtime.Serialization.StreamingContext> позволяет передавать данные контекста пользователя, которые используются для чтения и записи объектов.  
  
   
  
## Examples  
 В следующем примере показано создание экземпляра класса <xref:System.Runtime.Serialization.NetDataContractSerializer> с помощью <xref:System.Runtime.Serialization.StreamingContext>.  
  
 [!code-csharp[NetDataContractSerializer#9](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#9)]
 [!code-vb[NetDataContractSerializer#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetDataContractSerializer (string rootName, string rootNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string rootName, string rootNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rootName As String, rootNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetDataContractSerializer(System::String ^ rootName, System::String ^ rootNamespace);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.NetDataContractSerializer : string * string -&gt; System.Runtime.Serialization.NetDataContractSerializer" Usage="new System.Runtime.Serialization.NetDataContractSerializer (rootName, rootNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rootName" Type="System.String" />
        <Parameter Name="rootNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rootName">Имя XML-элемента, содержащего данные для сериализации или десериализации.</param>
        <param name="rootNamespace">Пространство имен XML-элемента, содержащего данные для сериализации или десериализации.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Serialization.NetDataContractSerializer" /> с указанными корневыми элементом и пространством имен XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано создание экземпляра класса <xref:System.Runtime.Serialization.DataContractSerializer> с указанием корневых элемента и пространства имен XML, ожидаемых им при десериализации объекта.  
  
 [!code-csharp[NetDataContractSerializer#10](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#10)]
 [!code-vb[NetDataContractSerializer#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetDataContractSerializer (System.Xml.XmlDictionaryString rootName, System.Xml.XmlDictionaryString rootNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlDictionaryString rootName, class System.Xml.XmlDictionaryString rootNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.#ctor(System.Xml.XmlDictionaryString,System.Xml.XmlDictionaryString)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rootName As XmlDictionaryString, rootNamespace As XmlDictionaryString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetDataContractSerializer(System::Xml::XmlDictionaryString ^ rootName, System::Xml::XmlDictionaryString ^ rootNamespace);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.NetDataContractSerializer : System.Xml.XmlDictionaryString * System.Xml.XmlDictionaryString -&gt; System.Runtime.Serialization.NetDataContractSerializer" Usage="new System.Runtime.Serialization.NetDataContractSerializer (rootName, rootNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rootName" Type="System.Xml.XmlDictionaryString" />
        <Parameter Name="rootNamespace" Type="System.Xml.XmlDictionaryString" />
      </Parameters>
      <Docs>
        <param name="rootName">Объект <see cref="T:System.Xml.XmlDictionaryString" />, в котором находится имя XML-элемента, содержащего данные для сериализации или десериализации.</param>
        <param name="rootNamespace">Объект <see cref="T:System.Xml.XmlDictionaryString" />, в котором находится пространство имен XML-элемента, содержащего данные для сериализации или десериализации.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Serialization.NetDataContractSerializer" /> с двумя параметрами типа <see cref="T:System.Xml.XmlDictionaryString" />, содержащими корневые элемент и пространство имен, используемые для задания содержимого.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Xml.XmlDictionaryString> может применяться для оптимизации производительности, когда в экземплярах объектов используется один и тот же набор строк.  
  
   
  
## Examples  
 В следующем примере показано создание экземпляра класса <xref:System.Runtime.Serialization.DataContractSerializer> с указанием корневых элемента и пространства имен XML (в качестве аргументов <xref:System.Xml.XmlDictionaryString>), ожидаемых им при десериализации объекта.  
  
 [!code-csharp[NetDataContractSerializer#11](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#11)]
 [!code-vb[NetDataContractSerializer#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetDataContractSerializer (System.Runtime.Serialization.StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, System.Runtime.Serialization.Formatters.FormatterAssemblyStyle assemblyFormat, System.Runtime.Serialization.ISurrogateSelector surrogateSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Runtime.Serialization.StreamingContext context, int32 maxItemsInObjectGraph, bool ignoreExtensionDataObject, valuetype System.Runtime.Serialization.Formatters.FormatterAssemblyStyle assemblyFormat, class System.Runtime.Serialization.ISurrogateSelector surrogateSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.#ctor(System.Runtime.Serialization.StreamingContext,System.Int32,System.Boolean,System.Runtime.Serialization.Formatters.FormatterAssemblyStyle,System.Runtime.Serialization.ISurrogateSelector)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (context As StreamingContext, maxItemsInObjectGraph As Integer, ignoreExtensionDataObject As Boolean, assemblyFormat As FormatterAssemblyStyle, surrogateSelector As ISurrogateSelector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetDataContractSerializer(System::Runtime::Serialization::StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, System::Runtime::Serialization::Formatters::FormatterAssemblyStyle assemblyFormat, System::Runtime::Serialization::ISurrogateSelector ^ surrogateSelector);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.NetDataContractSerializer : System.Runtime.Serialization.StreamingContext * int * bool * System.Runtime.Serialization.Formatters.FormatterAssemblyStyle * System.Runtime.Serialization.ISurrogateSelector -&gt; System.Runtime.Serialization.NetDataContractSerializer" Usage="new System.Runtime.Serialization.NetDataContractSerializer (context, maxItemsInObjectGraph, ignoreExtensionDataObject, assemblyFormat, surrogateSelector)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="maxItemsInObjectGraph" Type="System.Int32" />
        <Parameter Name="ignoreExtensionDataObject" Type="System.Boolean" />
        <Parameter Name="assemblyFormat" Type="System.Runtime.Serialization.Formatters.FormatterAssemblyStyle" />
        <Parameter Name="surrogateSelector" Type="System.Runtime.Serialization.ISurrogateSelector" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий данные контекста.</param>
        <param name="maxItemsInObjectGraph">Максимальное количество элементов в графе для сериализации или десериализации.</param>
        <param name="ignoreExtensionDataObject">Значение <see langword="true" />, если требуется игнорировать предоставляемые расширением типа данные; в противном случае — значение <see langword="false" />.</param>
        <param name="assemblyFormat">Значение перечисления <see cref="T:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle" />, задающее метод определения местоположения и загрузки сборок.</param>
        <param name="surrogateSelector">Реализация метода <see cref="T:System.Runtime.Serialization.ISurrogateSelector" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Serialization.NetDataContractSerializer" /> с предоставленными данными контекста; также задает максимальное количество сериализуемых элементов объекта и параметры, указывающие, пропускаются ли дополнительные данные, метод загрузки сборки и суррогатный селектор.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `ignoreExtensionDataObject` используется при реализации интерфейса <xref:System.Runtime.Serialization.IExtensibleDataObject> в сериализуемом или десериализуемом классе.  
  
   
  
## Examples  
 В следующем примере показано создание экземпляра класса <xref:System.Runtime.Serialization.NetDataContractSerializer> с помощью <xref:System.Runtime.Serialization.StreamingContext>. В этом коде также задаются параметр `ignoreExtensionDataObject` и реализация интерфейса `ISurrogateSelector` для обработки, предусмотренного для содействия сериализатору при выборе суррогата (для десериализации устаревших типов).  
  
 [!code-csharp[NetDataContractSerializer#12](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#12)]
 [!code-vb[NetDataContractSerializer#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maxItemsInObjectGraph" /> меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetDataContractSerializer (string rootName, string rootNamespace, System.Runtime.Serialization.StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, System.Runtime.Serialization.Formatters.FormatterAssemblyStyle assemblyFormat, System.Runtime.Serialization.ISurrogateSelector surrogateSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string rootName, string rootNamespace, valuetype System.Runtime.Serialization.StreamingContext context, int32 maxItemsInObjectGraph, bool ignoreExtensionDataObject, valuetype System.Runtime.Serialization.Formatters.FormatterAssemblyStyle assemblyFormat, class System.Runtime.Serialization.ISurrogateSelector surrogateSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.#ctor(System.String,System.String,System.Runtime.Serialization.StreamingContext,System.Int32,System.Boolean,System.Runtime.Serialization.Formatters.FormatterAssemblyStyle,System.Runtime.Serialization.ISurrogateSelector)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rootName As String, rootNamespace As String, context As StreamingContext, maxItemsInObjectGraph As Integer, ignoreExtensionDataObject As Boolean, assemblyFormat As FormatterAssemblyStyle, surrogateSelector As ISurrogateSelector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetDataContractSerializer(System::String ^ rootName, System::String ^ rootNamespace, System::Runtime::Serialization::StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, System::Runtime::Serialization::Formatters::FormatterAssemblyStyle assemblyFormat, System::Runtime::Serialization::ISurrogateSelector ^ surrogateSelector);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.NetDataContractSerializer : string * string * System.Runtime.Serialization.StreamingContext * int * bool * System.Runtime.Serialization.Formatters.FormatterAssemblyStyle * System.Runtime.Serialization.ISurrogateSelector -&gt; System.Runtime.Serialization.NetDataContractSerializer" Usage="new System.Runtime.Serialization.NetDataContractSerializer (rootName, rootNamespace, context, maxItemsInObjectGraph, ignoreExtensionDataObject, assemblyFormat, surrogateSelector)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rootName" Type="System.String" />
        <Parameter Name="rootNamespace" Type="System.String" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="maxItemsInObjectGraph" Type="System.Int32" />
        <Parameter Name="ignoreExtensionDataObject" Type="System.Boolean" />
        <Parameter Name="assemblyFormat" Type="System.Runtime.Serialization.Formatters.FormatterAssemblyStyle" />
        <Parameter Name="surrogateSelector" Type="System.Runtime.Serialization.ISurrogateSelector" />
      </Parameters>
      <Docs>
        <param name="rootName">Имя XML-элемента, содержащего данные для сериализации или десериализации.</param>
        <param name="rootNamespace">Пространство имен XML-элемента, содержащего данные для сериализации или десериализации.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий данные контекста.</param>
        <param name="maxItemsInObjectGraph">Максимальное количество элементов в графе для сериализации или десериализации.</param>
        <param name="ignoreExtensionDataObject">Значение <see langword="true" />, если требуется игнорировать предоставляемые расширением типа данные; в противном случае — значение <see langword="false" />.</param>
        <param name="assemblyFormat">Значение перечисления <see cref="T:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle" />, задающее метод определения местоположения и загрузки сборок.</param>
        <param name="surrogateSelector">Реализация объекта <see cref="T:System.Runtime.Serialization.IDataContractSurrogate" />, используемого для обработки устаревших типов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Serialization.NetDataContractSerializer" /> с предоставленными данными контекста, корневыми именем и пространством имен; также задает максимальное количество сериализуемых элементов объекта и параметры, указывающие, пропускаются ли дополнительные данные, метод загрузки сборки и суррогатный селектор.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `ignoreExtensionDataObject` используется при реализации интерфейса <xref:System.Runtime.Serialization.IExtensibleDataObject> в сериализуемом или десериализуемом классе.  
  
   
  
## Examples  
 В следующем примере показано создание экземпляра класса <xref:System.Runtime.Serialization.NetDataContractSerializer> с указанием имени XML-элемента и пространства имен, ожидаемых при десериализации. В этом коде также задаются параметр `ignoreExtensionDataObject` и реализация интерфейса <xref:System.Runtime.Serialization.ISurrogateSelector> для обработки, предусмотренного для содействия сериализатору при выборе суррогата (для десериализации устаревших типов).  
  
 [!code-csharp[NetDataContractSerializer#13](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#13)]
 [!code-vb[NetDataContractSerializer#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maxItemsInObjectGraph" /> меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetDataContractSerializer (System.Xml.XmlDictionaryString rootName, System.Xml.XmlDictionaryString rootNamespace, System.Runtime.Serialization.StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, System.Runtime.Serialization.Formatters.FormatterAssemblyStyle assemblyFormat, System.Runtime.Serialization.ISurrogateSelector surrogateSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlDictionaryString rootName, class System.Xml.XmlDictionaryString rootNamespace, valuetype System.Runtime.Serialization.StreamingContext context, int32 maxItemsInObjectGraph, bool ignoreExtensionDataObject, valuetype System.Runtime.Serialization.Formatters.FormatterAssemblyStyle assemblyFormat, class System.Runtime.Serialization.ISurrogateSelector surrogateSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.#ctor(System.Xml.XmlDictionaryString,System.Xml.XmlDictionaryString,System.Runtime.Serialization.StreamingContext,System.Int32,System.Boolean,System.Runtime.Serialization.Formatters.FormatterAssemblyStyle,System.Runtime.Serialization.ISurrogateSelector)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rootName As XmlDictionaryString, rootNamespace As XmlDictionaryString, context As StreamingContext, maxItemsInObjectGraph As Integer, ignoreExtensionDataObject As Boolean, assemblyFormat As FormatterAssemblyStyle, surrogateSelector As ISurrogateSelector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetDataContractSerializer(System::Xml::XmlDictionaryString ^ rootName, System::Xml::XmlDictionaryString ^ rootNamespace, System::Runtime::Serialization::StreamingContext context, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, System::Runtime::Serialization::Formatters::FormatterAssemblyStyle assemblyFormat, System::Runtime::Serialization::ISurrogateSelector ^ surrogateSelector);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Serialization.NetDataContractSerializer : System.Xml.XmlDictionaryString * System.Xml.XmlDictionaryString * System.Runtime.Serialization.StreamingContext * int * bool * System.Runtime.Serialization.Formatters.FormatterAssemblyStyle * System.Runtime.Serialization.ISurrogateSelector -&gt; System.Runtime.Serialization.NetDataContractSerializer" Usage="new System.Runtime.Serialization.NetDataContractSerializer (rootName, rootNamespace, context, maxItemsInObjectGraph, ignoreExtensionDataObject, assemblyFormat, surrogateSelector)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rootName" Type="System.Xml.XmlDictionaryString" />
        <Parameter Name="rootNamespace" Type="System.Xml.XmlDictionaryString" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="maxItemsInObjectGraph" Type="System.Int32" />
        <Parameter Name="ignoreExtensionDataObject" Type="System.Boolean" />
        <Parameter Name="assemblyFormat" Type="System.Runtime.Serialization.Formatters.FormatterAssemblyStyle" />
        <Parameter Name="surrogateSelector" Type="System.Runtime.Serialization.ISurrogateSelector" />
      </Parameters>
      <Docs>
        <param name="rootName">Объект <see cref="T:System.Xml.XmlDictionaryString" />, содержащий корневой элемент содержимого.</param>
        <param name="rootNamespace">Объект <see cref="T:System.Xml.XmlDictionaryString" />, содержащий пространство имен корневого элемента.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий данные контекста.</param>
        <param name="maxItemsInObjectGraph">Максимальное количество элементов в графе для сериализации или десериализации.</param>
        <param name="ignoreExtensionDataObject">Значение <see langword="true" />, если требуется игнорировать предоставляемые расширением типа данные; в противном случае — значение <see langword="false" />.</param>
        <param name="assemblyFormat">Значение перечисления <see cref="T:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle" />, задающее метод определения местоположения и загрузки сборок.</param>
        <param name="surrogateSelector">Реализация объекта <see cref="T:System.Runtime.Serialization.IDataContractSurrogate" />, используемого для обработки устаревших типов.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Runtime.Serialization.NetDataContractSerializer" /> с предоставленными данными контекста, корневыми именем и пространством имен (в качестве параметров <see cref="T:System.Xml.XmlDictionaryString" />); также задает максимальное количество сериализуемых элементов объекта и параметры, указывающие, игнорируются ли дополнительные данные, метод загрузки сборки и суррогатный селектор.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Xml.XmlDictionaryString> может применяться для оптимизации производительности, когда в экземплярах объектов используется один и тот же набор строк.  
  
 Параметр `ignoreExtensionDataObject` используется при реализации интерфейса <xref:System.Runtime.Serialization.IExtensibleDataObject> в сериализуемом или десериализуемом классе.  
  
   
  
## Examples  
 В следующем примере показано создание экземпляра класса <xref:System.Runtime.Serialization.NetDataContractSerializer> с указанием имени XML-элемента и пространства имен (в качестве аргументов <xref:System.Xml.XmlDictionaryString>), ожидаемых при десериализации. В этом коде также задаются параметр `ignoreExtensionDataObject` и реализация интерфейса <xref:System.Runtime.Serialization.ISurrogateSelector> для обработки, предусмотренного для содействия сериализатору при выборе суррогата (для десериализации устаревших типов).  
  
 [!code-csharp[NetDataContractSerializer#14](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#14)]
 [!code-vb[NetDataContractSerializer#14](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maxItemsInObjectGraph" /> меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="AssemblyFormat">
      <MemberSignature Language="C#" Value="public System.Runtime.Serialization.Formatters.FormatterAssemblyStyle AssemblyFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Serialization.Formatters.FormatterAssemblyStyle AssemblyFormat" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property AssemblyFormat As FormatterAssemblyStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Serialization::Formatters::FormatterAssemblyStyle AssemblyFormat { System::Runtime::Serialization::Formatters::FormatterAssemblyStyle get(); void set(System::Runtime::Serialization::Formatters::FormatterAssemblyStyle value); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyFormat : System.Runtime.Serialization.Formatters.FormatterAssemblyStyle with get, set" Usage="System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Serialization.Formatters.FormatterAssemblyStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, задающее метод определения местоположения и загрузки сборок.</summary>
        <value>Значение перечисления <see cref="T:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle" />, задающее метод определения местоположения и загрузки сборок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр `AssemblyFormat` может иметь один из двух стилей: <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> или <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>. Если задать стиль `Simple`, в версии будет можно выполнить загрузку и десериализацию типов из экземпляра, сериализованного в другой версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Задаваемое значение не соответствует ни одному из значений <see cref="T:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Binder">
      <MemberSignature Language="C#" Value="public System.Runtime.Serialization.SerializationBinder Binder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Serialization.SerializationBinder Binder" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.NetDataContractSerializer.Binder" />
      <MemberSignature Language="VB.NET" Value="Public Property Binder As SerializationBinder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Serialization::SerializationBinder ^ Binder { System::Runtime::Serialization::SerializationBinder ^ get(); void set(System::Runtime::Serialization::SerializationBinder ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Binder : System.Runtime.Serialization.SerializationBinder with get, set" Usage="System.Runtime.Serialization.NetDataContractSerializer.Binder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Serialization.IFormatter.Binder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Serialization.SerializationBinder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, управляющий загрузкой класса.</summary>
        <value><see cref="T:System.Runtime.Serialization.SerializationBinder" />, используемый с текущим модулем форматирования.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При сериализации модуль форматирования передает сведения, необходимые для создания экземпляра объекта правильных типа и версии. Эти сведения обычно содержат полное имя типа и имя сборки объекта. Имя сборки содержит имя, версию и хэш строгого имени сборки. По умолчанию десериализация использует эти сведения для создания экземпляра идентичного объекта (с исключением любой загрузки сборки, ограниченной политикой безопасности). Некоторым пользователям необходимо отслеживать загружаемый класс либо потому, что класс перемещен из одной сборки в другую, либо потому, что для сервера и клиента требуется отличная версия класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public System.Runtime.Serialization.StreamingContext Context { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Serialization.StreamingContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.NetDataContractSerializer.Context" />
      <MemberSignature Language="VB.NET" Value="Public Property Context As StreamingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Serialization::StreamingContext Context { System::Runtime::Serialization::StreamingContext get(); void set(System::Runtime::Serialization::StreamingContext value); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Runtime.Serialization.StreamingContext with get, set" Usage="System.Runtime.Serialization.NetDataContractSerializer.Context" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Serialization.IFormatter.Context</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Serialization.StreamingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, позволяющий передавать данные контекста, которые могут потребоваться при сериализации и десериализации.</summary>
        <value>Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий данные контекста.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public object Deserialize (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Deserialize(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.Deserialize(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Deserialize(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="abstract member Deserialize : System.IO.Stream -&gt; obj&#xA;override this.Deserialize : System.IO.Stream -&gt; obj" Usage="netDataContractSerializer.Deserialize stream" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IFormatter.Deserialize(System.IO.Stream)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Поток <see cref="T:System.IO.Stream" />, содержащий десериализуемый XML.</param>
        <summary>Десериализует XML-документ или поток в объект.</summary>
        <returns>Десериализованный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Предполагается, что формат по умолчанию для этого метода — текст XML.  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.NetDataContractSerializer.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool" Usage="System.Runtime.Serialization.NetDataContractSerializer.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, следует ли игнорировать предоставляемые расширением объекта данные.</summary>
        <value>Значение <see langword="true" />, если требуется игнорировать предоставляемые расширением типа данные; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При реализации <xref:System.Runtime.Serialization.IExtensibleDataObject> данные из будущей версии типа могут храниться в <xref:System.Runtime.Serialization.ExtensionDataObject>. Во время кругового пути (при выполнении десериализации, изменения и сериализации объекта) дополнительные данные сохраняются и снова сериализуются. Дополнительные сведения см. в разделе [сериализации и десериализации](~/docs/framework/wcf/feature-details/serialization-and-deserialization.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, расположено ли средство чтения на объекте, который может быть десериализован.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это эквивалентно использованию метода `ReadObject` интерфейса `IFormatter`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartObject">
      <MemberSignature Language="C#" Value="public override bool IsStartObject (System.Xml.XmlDictionaryReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsStartObject(class System.Xml.XmlDictionaryReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.IsStartObject(System.Xml.XmlDictionaryReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsStartObject (reader As XmlDictionaryReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsStartObject(System::Xml::XmlDictionaryReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.IsStartObject : System.Xml.XmlDictionaryReader -&gt; bool" Usage="netDataContractSerializer.IsStartObject reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlDictionaryReader" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Xml.XmlDictionaryReader" />, содержащий XML для чтения.</param>
        <summary>Определяет, расположено ли средство чтения <see cref="T:System.Xml.XmlDictionaryReader" /> на объекте, который может быть десериализован с помощью указанного средства чтения.</summary>
        <returns>Значение <see langword="true" />, если модуль чтения установлен на начальном элементе считываемого потока; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Serialization.DataContractSerializer.IsStartObject%2A> определяет, можно ли считать объект посредством проверки имени и пространства имен XML-элемента, на котором установлено средство чтения, и сравнения этих значений с ожидаемыми именем и пространством имен. Ожидаемые имя и пространство имен могут принимать следующие значения: имя и пространство имен контракта данных типа, переданного в конструктор, или значения `rootName` и `rootNamespace`, переданные в конструктор (при его наличии).  
  
 `rootName` и `rootNamespace` можно задать в следующих конструкторах: <xref:System.Runtime.Serialization.NetDataContractSerializer.%23ctor%28System.String%2CSystem.String%29?displayProperty=nameWithType>, <xref:System.Runtime.Serialization.NetDataContractSerializer.%23ctor%28System.Xml.XmlDictionaryString%2CSystem.Xml.XmlDictionaryString%29?displayProperty=nameWithType> и <xref:System.Runtime.Serialization.NetDataContractSerializer.%23ctor%28System.Xml.XmlDictionaryString%2CSystem.Xml.XmlDictionaryString%2CSystem.Runtime.Serialization.StreamingContext%2CSystem.Int32%2CSystem.Boolean%2CSystem.Runtime.Serialization.Formatters.FormatterAssemblyStyle%2CSystem.Runtime.Serialization.ISurrogateSelector%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">параметру <paramref name="reader" /> задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsStartObject">
      <MemberSignature Language="C#" Value="public override bool IsStartObject (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsStartObject(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.IsStartObject(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsStartObject (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsStartObject(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.IsStartObject : System.Xml.XmlReader -&gt; bool" Usage="netDataContractSerializer.IsStartObject reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Xml.XmlReader" />, содержащий XML для чтения.</param>
        <summary>Определяет, расположено ли средство чтения <see cref="T:System.Xml.XmlReader" /> на объекте, который может быть десериализован с помощью указанного средства чтения.</summary>
        <returns>Значение <see langword="true" />, если модуль чтения установлен на начальном элементе считываемого потока; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">параметру <paramref name="reader" /> задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int" Usage="System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальное количество элементов, допустимое в сериализуемом объекте.</summary>
        <value>Максимальное количество элементов, допустимое в объекте. Значение по умолчанию — <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о квотах параметр, см. в разделе [вопросы безопасности для данных](~/docs/framework/wcf/feature-details/security-considerations-for-data.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает XML-поток или документ и возвращает десериализованный объект.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadObject">
      <MemberSignature Language="C#" Value="public override object ReadObject (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object ReadObject(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.ReadObject(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadObject (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ ReadObject(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.ReadObject : System.Xml.XmlReader -&gt; obj" Usage="netDataContractSerializer.ReadObject reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения <see cref="T:System.Xml.XmlReader" />, используемое для чтения XML-потока или документа.</param>
        <summary>Считывает XML-поток или документ с помощью средства чтения <see cref="T:System.Xml.XmlDictionaryReader" /> и возвращает десериализованный объект.</summary>
        <returns>Десериализованный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">параметру <paramref name="reader" /> задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadObject">
      <MemberSignature Language="C#" Value="public override object ReadObject (System.Xml.XmlDictionaryReader reader, bool verifyObjectName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object ReadObject(class System.Xml.XmlDictionaryReader reader, bool verifyObjectName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.ReadObject(System.Xml.XmlDictionaryReader,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadObject (reader As XmlDictionaryReader, verifyObjectName As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ ReadObject(System::Xml::XmlDictionaryReader ^ reader, bool verifyObjectName);" />
      <MemberSignature Language="F#" Value="override this.ReadObject : System.Xml.XmlDictionaryReader * bool -&gt; obj" Usage="netDataContractSerializer.ReadObject (reader, verifyObjectName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlDictionaryReader" />
        <Parameter Name="verifyObjectName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения <see cref="T:System.Xml.XmlDictionaryReader" />, используемое для чтения XML-потока или документа.</param>
        <param name="verifyObjectName"><see langword="true" />, если требуется проверить соответствие имени и пространства имен включающего XML-элемента ожидаемым корневым имени и пространству имен, используемым для создания сериализатора; <see langword="false" />, если следует пропустить проверку.</param>
        <summary>Считывает XML-поток или документ с помощью средства чтения <see cref="T:System.Xml.XmlDictionaryReader" /> и возвращает десериализованный объект; также проверяет, соответствуют ли данные объекта имени и пространству имен, используемым для создания сериализатора.</summary>
        <returns>Десериализованный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `verifyObjectName` определяет, можно ли считать объект посредством проверки имени и пространства имен XML-элемента, на котором установлено средство чтения, и сравнения этих значений с ожидаемыми именем и пространством имен. Ожидаемые имя и пространство имен могут принимать следующие значения: имя и пространство имен контракта данных типа, переданного в конструктор, или значения `rootName` и `rootNamespace`, переданные в конструктор (при его наличии).  
  
 `rootName` и `rootNamespace` можно задать в следующих конструкторах: <xref:System.Runtime.Serialization.NetDataContractSerializer.%23ctor%28System.String%2CSystem.String%29>, <xref:System.Runtime.Serialization.NetDataContractSerializer.%23ctor%28System.Xml.XmlDictionaryString%2CSystem.Xml.XmlDictionaryString%29> и <xref:System.Runtime.Serialization.NetDataContractSerializer.%23ctor%28System.Xml.XmlDictionaryString%2CSystem.Xml.XmlDictionaryString%2CSystem.Runtime.Serialization.StreamingContext%2CSystem.Int32%2CSystem.Boolean%2CSystem.Runtime.Serialization.Formatters.FormatterAssemblyStyle%2CSystem.Runtime.Serialization.ISurrogateSelector%29>.  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">параметру <paramref name="reader" /> задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadObject">
      <MemberSignature Language="C#" Value="public override object ReadObject (System.Xml.XmlReader reader, bool verifyObjectName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object ReadObject(class System.Xml.XmlReader reader, bool verifyObjectName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.ReadObject(System.Xml.XmlReader,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadObject (reader As XmlReader, verifyObjectName As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ ReadObject(System::Xml::XmlReader ^ reader, bool verifyObjectName);" />
      <MemberSignature Language="F#" Value="override this.ReadObject : System.Xml.XmlReader * bool -&gt; obj" Usage="netDataContractSerializer.ReadObject (reader, verifyObjectName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="verifyObjectName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reader">Средство чтения <see cref="T:System.Xml.XmlReader" />, используемое для чтения XML-потока или документа.</param>
        <param name="verifyObjectName"><see langword="true" />, если требуется проверить соответствие имени и пространства имен включающего XML-элемента ожидаемым корневым имени и пространству имен, используемым для создания сериализатора; <see langword="false" />, если следует пропустить проверку.</param>
        <summary>Считывает XML-поток или документ с помощью средства чтения <see cref="T:System.Xml.XmlDictionaryReader" /> и возвращает десериализованный объект; также проверяет, соответствуют ли данные объекта имени и пространству имен, используемым для создания сериализатора.</summary>
        <returns>Десериализованный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `verifyObjectName` определяет, можно ли считать объект посредством проверки имени и пространства имен XML-элемента, на котором установлено средство чтения, и сравнения этих значений с ожидаемыми именем и пространством имен. Ожидаемые имя и пространство имен могут принимать следующие значения: имя и пространство имен контракта данных типа, переданного в конструктор, или значения `rootName` и `rootNamespace`, переданные в конструктор (при его наличии).  
  
 `rootName` и `rootNamespace` можно задать в следующих конструкторах: <xref:System.Runtime.Serialization.NetDataContractSerializer.%23ctor%28System.String%2CSystem.String%29>, <xref:System.Runtime.Serialization.NetDataContractSerializer.%23ctor%28System.Xml.XmlDictionaryString%2CSystem.Xml.XmlDictionaryString%29> и <xref:System.Runtime.Serialization.NetDataContractSerializer.%23ctor%28System.Xml.XmlDictionaryString%2CSystem.Xml.XmlDictionaryString%2CSystem.Runtime.Serialization.StreamingContext%2CSystem.Int32%2CSystem.Boolean%2CSystem.Runtime.Serialization.Formatters.FormatterAssemblyStyle%2CSystem.Runtime.Serialization.ISurrogateSelector%29>.  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">параметру <paramref name="reader" /> задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public void Serialize (System.IO.Stream stream, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Serialize(class System.IO.Stream stream, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.Serialize(System.IO.Stream,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Serialize(System::IO::Stream ^ stream, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="abstract member Serialize : System.IO.Stream * obj -&gt; unit&#xA;override this.Serialize : System.IO.Stream * obj -&gt; unit" Usage="netDataContractSerializer.Serialize (stream, graph)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IFormatter.Serialize(System.IO.Stream,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" />, с помощью которого выполняется сериализация.</param>
        <param name="graph">Объект для сериализации. Все дочерние объекты этого корневого объекта сериализуются автоматически.</param>
        <summary>Сериализует заданный граф объектов с помощью указанного модуля записи.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SurrogateSelector">
      <MemberSignature Language="C#" Value="public System.Runtime.Serialization.ISurrogateSelector SurrogateSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Serialization.ISurrogateSelector SurrogateSelector" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property SurrogateSelector As ISurrogateSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Serialization::ISurrogateSelector ^ SurrogateSelector { System::Runtime::Serialization::ISurrogateSelector ^ get(); void set(System::Runtime::Serialization::ISurrogateSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SurrogateSelector : System.Runtime.Serialization.ISurrogateSelector with get, set" Usage="System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Serialization.IFormatter.SurrogateSelector</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Serialization.ISurrogateSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект, содействующий модулю форматирования при выборе суррогата для сериализации.</summary>
        <value><see cref="T:System.Runtime.Serialization.ISurrogateSelector" /> для выбора суррогата.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о <xref:System.Runtime.Serialization.IDataContractSurrogate>, см. в разделе [суррогаты контрактов данных](~/docs/framework/wcf/extending/data-contract-surrogates.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Serialization.ISurrogateSelector" />
        <altmember cref="T:System.Runtime.Serialization.IFormatter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEndObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет запись закрывающего XML-элемента с помощью указанного модуля записи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteObjectContent%2A> и <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteEndObject%2A> последовательно используются для записи завершенной сериализации в следующем порядке: начало записи, запись содержимого и завершение записи. Эти три метода также вызываются методом <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteObject%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEndObject">
      <MemberSignature Language="C#" Value="public override void WriteEndObject (System.Xml.XmlDictionaryWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndObject(class System.Xml.XmlDictionaryWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.WriteEndObject(System.Xml.XmlDictionaryWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndObject (writer As XmlDictionaryWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndObject(System::Xml::XmlDictionaryWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.WriteEndObject : System.Xml.XmlDictionaryWriter -&gt; unit" Usage="netDataContractSerializer.WriteEndObject writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlDictionaryWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Xml.XmlDictionaryWriter" />, используемый для записи XML-документа или потока.</param>
        <summary>Выполняет запись закрывающего XML-элемента с помощью средства записи <see cref="T:System.Xml.XmlDictionaryWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается объект для сериализации, экземпляр класса <xref:System.Runtime.Serialization.NetDataContractSerializer> и экземпляр класса <xref:System.Xml.XmlDictionaryWriter>.  В этом примере для записи данных объекта в XML-документ используются методы <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteObjectContent%2A> и <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteEndObject%2A>.  
  
 [!code-csharp[NetDataContractSerializer#5](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#5)]
 [!code-vb[NetDataContractSerializer#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">параметру <paramref name="writer" /> задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndObject">
      <MemberSignature Language="C#" Value="public override void WriteEndObject (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndObject(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.WriteEndObject(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndObject (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndObject(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.WriteEndObject : System.Xml.XmlWriter -&gt; unit" Usage="netDataContractSerializer.WriteEndObject writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Xml.XmlWriter" />, используемый для записи XML-документа или потока.</param>
        <summary>Выполняет запись закрывающего XML-элемента с помощью средства записи <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">параметру <paramref name="writer" /> задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteObject">
      <MemberSignature Language="C#" Value="public override void WriteObject (System.Xml.XmlWriter writer, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteObject(class System.Xml.XmlWriter writer, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.WriteObject(System.Xml.XmlWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteObject (writer As XmlWriter, graph As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteObject(System::Xml::XmlWriter ^ writer, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="override this.WriteObject : System.Xml.XmlWriter * obj -&gt; unit" Usage="netDataContractSerializer.WriteObject (writer, graph)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Xml.XmlWriter" />, используемый для записи XML-документа или потока.</param>
        <param name="graph">Объект, в котором находится содержимое для записи.</param>
        <summary>Записывает полное содержимое объекта (начало записи, запись содержимого и завершение записи) в XML-документ или поток с помощью указанного средства записи <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">сериализуемый тип не удовлетворяет правилам контракта данных. Например, к этому типу не применен атрибут <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">возникла проблема с сериализуемым экземпляром.</exception>
        <exception cref="T:System.ServiceModel.QuotaExceededException">было превышено максимально допустимое количество объектов для сериализации. Проверьте свойство <see cref="P:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteObjectContent">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет запись содержимого XML с помощью указанного средства записи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteObjectContent%2A> и <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteEndObject%2A> последовательно используются для записи завершенной сериализации в следующем порядке: начало записи, запись содержимого и завершение записи. Эти три метода также вызываются методом <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteObject%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteObjectContent">
      <MemberSignature Language="C#" Value="public override void WriteObjectContent (System.Xml.XmlDictionaryWriter writer, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteObjectContent(class System.Xml.XmlDictionaryWriter writer, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.WriteObjectContent(System.Xml.XmlDictionaryWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteObjectContent (writer As XmlDictionaryWriter, graph As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteObjectContent(System::Xml::XmlDictionaryWriter ^ writer, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="override this.WriteObjectContent : System.Xml.XmlDictionaryWriter * obj -&gt; unit" Usage="netDataContractSerializer.WriteObjectContent (writer, graph)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlDictionaryWriter" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Xml.XmlDictionaryWriter" />, используемый для записи содержимого XML.</param>
        <param name="graph">Объект для сериализации. Все дочерние объекты этого корневого объекта сериализуются автоматически.</param>
        <summary>Выполняет запись содержимого XML с помощью средства записи <see cref="T:System.Xml.XmlDictionaryWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается объект для сериализации, экземпляр класса <xref:System.Runtime.Serialization.NetDataContractSerializer> и экземпляр класса <xref:System.Xml.XmlDictionaryWriter>.  В этом примере для записи данных объекта в XML-документ используются методы <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteObjectContent%2A> и <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteEndObject%2A>.  
  
 [!code-csharp[NetDataContractSerializer#5](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#5)]
 [!code-vb[NetDataContractSerializer#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">сериализуемый тип не удовлетворяет правилам контракта данных. Например, к этому типу не применен атрибут <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">возникла проблема с сериализуемым экземпляром.</exception>
        <exception cref="T:System.ServiceModel.QuotaExceededException">было превышено максимально допустимое количество объектов для сериализации. Проверьте свойство <see cref="P:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteObjectContent">
      <MemberSignature Language="C#" Value="public override void WriteObjectContent (System.Xml.XmlWriter writer, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteObjectContent(class System.Xml.XmlWriter writer, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.WriteObjectContent(System.Xml.XmlWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteObjectContent (writer As XmlWriter, graph As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteObjectContent(System::Xml::XmlWriter ^ writer, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="override this.WriteObjectContent : System.Xml.XmlWriter * obj -&gt; unit" Usage="netDataContractSerializer.WriteObjectContent (writer, graph)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Xml.XmlWriter" />, используемый для записи содержимого XML.</param>
        <param name="graph">Объект для сериализации. Все дочерние объекты этого корневого объекта сериализуются автоматически.</param>
        <summary>Выполняет запись содержимого XML с помощью средства записи <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">сериализуемый тип не удовлетворяет правилам контракта данных. Например, к этому типу не применен атрибут <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">возникла проблема с сериализуемым экземпляром.</exception>
        <exception cref="T:System.ServiceModel.QuotaExceededException">было превышено максимально допустимое количество объектов для сериализации. Проверьте свойство <see cref="P:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteStartObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет запись открывающего XML-элемента с помощью указанного средства записи.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public override void WriteStartObject (System.Xml.XmlDictionaryWriter writer, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartObject(class System.Xml.XmlDictionaryWriter writer, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.WriteStartObject(System.Xml.XmlDictionaryWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartObject (writer As XmlDictionaryWriter, graph As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartObject(System::Xml::XmlDictionaryWriter ^ writer, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="override this.WriteStartObject : System.Xml.XmlDictionaryWriter * obj -&gt; unit" Usage="netDataContractSerializer.WriteStartObject (writer, graph)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlDictionaryWriter" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Xml.XmlDictionaryWriter" />, используемый для записи XML-элемента.</param>
        <param name="graph">Объект для сериализации. Все дочерние объекты этого корневого объекта сериализуются автоматически.</param>
        <summary>Выполняет запись открывающего XML-элемента с помощью модуля записи <see cref="T:System.Xml.XmlDictionaryWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается объект для сериализации, экземпляр класса <xref:System.Runtime.Serialization.NetDataContractSerializer> и экземпляр класса <xref:System.Xml.XmlDictionaryWriter>.  В этом примере для записи данных объекта в XML-документ используются методы <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteObjectContent%2A> и <xref:System.Runtime.Serialization.NetDataContractSerializer.WriteEndObject%2A>.  
  
 [!code-csharp[NetDataContractSerializer#5](~/samples/snippets/csharp/VS_Snippets_CFX/netdatacontractserializer/cs/source.cs#5)]
 [!code-vb[NetDataContractSerializer#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/netdatacontractserializer/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">сериализуемый тип не удовлетворяет правилам контракта данных. Например, к этому типу не применен атрибут <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">возникла проблема с сериализуемым экземпляром.</exception>
        <exception cref="T:System.ServiceModel.QuotaExceededException">было превышено максимально допустимое количество объектов для сериализации. Проверьте свойство <see cref="P:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public override void WriteStartObject (System.Xml.XmlWriter writer, object graph);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartObject(class System.Xml.XmlWriter writer, object graph) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Serialization.NetDataContractSerializer.WriteStartObject(System.Xml.XmlWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartObject (writer As XmlWriter, graph As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartObject(System::Xml::XmlWriter ^ writer, System::Object ^ graph);" />
      <MemberSignature Language="F#" Value="override this.WriteStartObject : System.Xml.XmlWriter * obj -&gt; unit" Usage="netDataContractSerializer.WriteStartObject (writer, graph)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Serialization</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="graph" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Xml.XmlDictionaryWriter" />, используемый для записи XML-элемента.</param>
        <param name="graph">Объект для сериализации. Все дочерние объекты этого корневого объекта сериализуются автоматически.</param>
        <summary>Выполняет запись открывающего XML-элемента с помощью модуля записи <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.InvalidDataContractException">сериализуемый тип не удовлетворяет правилам контракта данных. Например, к этому типу не применен атрибут <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">возникла проблема с сериализуемым экземпляром.</exception>
        <exception cref="T:System.ServiceModel.QuotaExceededException">было превышено максимально допустимое количество объектов для сериализации. Проверьте свойство <see cref="P:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>