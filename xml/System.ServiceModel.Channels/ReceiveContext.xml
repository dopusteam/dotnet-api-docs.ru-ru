<Type Name="ReceiveContext" FullName="System.ServiceModel.Channels.ReceiveContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5f7c33a6d97d68cafa5ab014f15d63dfe76ad5b0" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39996283" /></Metadata><TypeSignature Language="C#" Value="public abstract class ReceiveContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ReceiveContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.ReceiveContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ReceiveContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReceiveContext abstract" />
  <TypeSignature Language="F#" Value="type ReceiveContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Создайте производный от этого класса, чтобы реализовать пользовательский конечный автомат для функции контекста получения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Функция контекста получения является двухступенчатой. При работе с каналом в очереди контекст получения позволяет заблокировать сообщение до его обработки. В случае сбоя сообщение останется заблокированным, а служба, обрабатывающая это сообщение, останется его владельцем (другая служба не сможет получить и обработать это сообщение) и сможет выполнить с ним любые другие действия. При работе с односторонним каналом контекст получения позволяет службе контролировать время отправки подтверждения приема или она может указать на проблему, отправив уведомление о недоставке. В этом случае клиент может отправить сообщение повторно, если было получено уведомление о недоставке или если уведомление о доставке не было получено в течение определенного времени.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReceiveContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ReceiveContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ServiceModel.Channels.ReceiveContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abandon">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывает переход конечного автомата в прерванное состояние.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.ReceiveContext.Abandon%2A> может зависнуть при отсутствии внешнюю транзакцию и <xref:System.ServiceModel.Channels.ReceiveContext.Complete%2A> вызывается и после этого транзакция откатывается. Если <xref:System.ServiceModel.Channels.ReceiveContext.Abandon%2A> вызывается до завершения транзакции отката, будут существовать гонки, вызывая вызов <xref:System.ServiceModel.Channels.ReceiveContext.Abandon%2A> зависание. Это может быть показано в следующем примере псевдокода  
  
```  
using (TransactionScope ts = new TransactionScope())   
{  
   try  
   {  
       rc.Complete();  
      ...  
   }  
   Catch (Exception)   
   {  
      rc.Abandon()  
   }  
}  
  
```  
  
 Это не рекомендуемый шаблон для работы с T:System.ServiceModel.Channels.RecieveContext. Вместо этого блока try/catch должен располагаться за пределами области транзакции.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abandon">
      <MemberSignature Language="C#" Value="public virtual void Abandon (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Abandon(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.Abandon(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Abandon (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Abandon(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Abandon : TimeSpan -&gt; unit&#xA;override this.Abandon : TimeSpan -&gt; unit" Usage="receiveContext.Abandon timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Время ожидания для завершения операции прерывания.</param>
        <summary>Вызывает переход конечного автомата в прерванное состояние с указанным значением времени ожидания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abandon">
      <MemberSignature Language="C#" Value="public virtual void Abandon (Exception exception, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Abandon(class System.Exception exception, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.Abandon(System.Exception,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Abandon(Exception ^ exception, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Abandon : Exception * TimeSpan -&gt; unit&#xA;override this.Abandon : Exception * TimeSpan -&gt; unit" Usage="receiveContext.Abandon (exception, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="exception">Исключение, вызывающее операцию прерывания.</param>
        <param name="timeout">Время ожидания для завершения операции прерывания.</param>
        <summary>Вызывает переход конечного компьютера в прерванное состояние с указанным исключением и значением времени ожидания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAbandon">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает асинхронную операцию прерывания.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAbandon">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAbandon (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAbandon(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.BeginAbandon(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginAbandon (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAbandon(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAbandon : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAbandon : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="receiveContext.BeginAbandon (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Время ожидания для завершения операции прерывания.</param>
        <param name="callback">Делегат асинхронного обратного вызова, принимающий уведомление о завершении асинхронной операции.</param>
        <param name="state">Определенные пользователем данные о состоянии.</param>
        <summary>Начинает любую асинхронную операцию прерывания с указанным временем ожидания, асинхронным обратным вызовом и определяемыми пользователем данными о состоянии.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию прерывания.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAbandon">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAbandon (Exception exception, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAbandon(class System.Exception exception, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.BeginAbandon(System.Exception,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAbandon(Exception ^ exception, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAbandon : Exception * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAbandon : Exception * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="receiveContext.BeginAbandon (exception, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="exception">Исключение, содержащее причину для операции прерывания.</param>
        <param name="timeout">Время ожидания для завершения операции прерывания.</param>
        <param name="callback">Делегат асинхронного обратного вызова, принимающий уведомление о завершении асинхронной операции.</param>
        <param name="state">Определенные пользователем данные о состоянии.</param>
        <summary>Начинает любую асинхронную операцию прерывания с указанным исключением, временем ожидания, асинхронным обратным вызовом и определяемыми пользователем данными о состоянии.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию прерывания.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginComplete">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginComplete (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginComplete(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.BeginComplete(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginComplete (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginComplete(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginComplete : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginComplete : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="receiveContext.BeginComplete (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Время ожидания для завершения операции завершения.</param>
        <param name="callback">Делегат асинхронного обратного вызова, принимающий уведомление о завершении асинхронной операции.</param>
        <param name="state">Определенные пользователем данные о состоянии.</param>
        <summary>Начинает любую асинхронную операцию завершения с указанным временем ожидания, асинхронным обратным вызовом и определяемыми пользователем данными о состоянии.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию завершения.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Complete">
      <MemberSignature Language="C#" Value="public virtual void Complete (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Complete(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.Complete(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Complete (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Complete(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Complete : TimeSpan -&gt; unit&#xA;override this.Complete : TimeSpan -&gt; unit" Usage="receiveContext.Complete timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Время ожидания для завершения операции завершения.</param>
        <summary>Вызывает переход конечного компьютера в состояние завершения с указанным значением времени ожидания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAbandon">
      <MemberSignature Language="C#" Value="public virtual void EndAbandon (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAbandon(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.EndAbandon(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAbandon (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAbandon(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAbandon : IAsyncResult -&gt; unit&#xA;override this.EndAbandon : IAsyncResult -&gt; unit" Usage="receiveContext.EndAbandon result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, возвращенный вызовом одного из методов <see cref="Overload:System.ServiceModel.Activities.WorkflowControlClient.BeginAbandon" />.</param>
        <summary>Завершает асинхронную операцию прерывания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndComplete">
      <MemberSignature Language="C#" Value="public virtual void EndComplete (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndComplete(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.EndComplete(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndComplete (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndComplete(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndComplete : IAsyncResult -&gt; unit&#xA;override this.EndComplete : IAsyncResult -&gt; unit" Usage="receiveContext.EndComplete result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, возвращенный методом <see cref="M:System.ServiceModel.Channels.ReceiveContext.BeginComplete(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <summary>Завершает асинхронную операцию завершения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fault">
      <MemberSignature Language="C#" Value="protected internal virtual void Fault ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Fault() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.Fault" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Fault ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Fault();" />
      <MemberSignature Language="F#" Value="abstract member Fault : unit -&gt; unit&#xA;override this.Fault : unit -&gt; unit" Usage="receiveContext.Fault " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает переход конечного автомата в состояние сбоя.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Faulted">
      <MemberSignature Language="C#" Value="public event EventHandler Faulted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Faulted" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.Channels.ReceiveContext.Faulted" />
      <MemberSignature Language="VB.NET" Value="Public Event Faulted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Faulted;" />
      <MemberSignature Language="F#" Value="member this.Faulted : EventHandler " Usage="member this.Faulted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет событие, которое инициируется при возникновении исключения в процессе обмена сообщениями.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public static readonly string Name;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Name" />
      <MemberSignature Language="DocId" Value="F:System.ServiceModel.Channels.ReceiveContext.Name" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Name As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Name;" />
      <MemberSignature Language="F#" Value=" staticval mutable Name : string" Usage="System.ServiceModel.Channels.ReceiveContext.Name" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Имя контекста получения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnAbandon">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывается, когда конечный автомат выполняет переход в отброшенное состояние.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnAbandon">
      <MemberSignature Language="C#" Value="protected abstract void OnAbandon (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAbandon(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.OnAbandon(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnAbandon (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnAbandon(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member OnAbandon : TimeSpan -&gt; unit" Usage="receiveContext.OnAbandon timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Время ожидания для завершения операции прерывания.</param>
        <summary>Вызывается, когда конечный автомат переходит в состояние прерывания с указанным значением времени ожидания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAbandon">
      <MemberSignature Language="C#" Value="protected virtual void OnAbandon (Exception exception, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAbandon(class System.Exception exception, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.OnAbandon(System.Exception,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAbandon(Exception ^ exception, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member OnAbandon : Exception * TimeSpan -&gt; unit&#xA;override this.OnAbandon : Exception * TimeSpan -&gt; unit" Usage="receiveContext.OnAbandon (exception, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="exception">Исключение, содержащее причину для операции прерывания.</param>
        <param name="timeout">Время ожидания для завершения операции прерывания.</param>
        <summary>Вызывается, когда конечный компьютер переходит в состояние прерывания с указанным исключением и значением времени ожидания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnBeginAbandon">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывается, когда конечный автомат выполняет переход в отброшенное состояние.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnBeginAbandon">
      <MemberSignature Language="C#" Value="protected abstract IAsyncResult OnBeginAbandon (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult OnBeginAbandon(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.OnBeginAbandon(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function OnBeginAbandon (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract IAsyncResult ^ OnBeginAbandon(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginAbandon : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="receiveContext.OnBeginAbandon (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Время ожидания для завершения операции прерывания.</param>
        <param name="callback">Делегат асинхронного обратного вызова, принимающий уведомление о завершении асинхронной операции.</param>
        <param name="state">Определенные пользователем данные о состоянии.</param>
        <summary>Вызывается, когда конечный автомат асинхронно переходит в состояние прерывания с указанным, значением времени ожидания, обратным вызовом и данными состояния.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginAbandon">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult OnBeginAbandon (Exception exception, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult OnBeginAbandon(class System.Exception exception, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.OnBeginAbandon(System.Exception,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ OnBeginAbandon(Exception ^ exception, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginAbandon : Exception * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.OnBeginAbandon : Exception * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="receiveContext.OnBeginAbandon (exception, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="exception">Исключение, содержащее причину для операции прерывания.</param>
        <param name="timeout">Время ожидания для завершения операции прерывания.</param>
        <param name="callback">Делегат асинхронного обратного вызова, принимающий уведомление о завершении асинхронной операции.</param>
        <param name="state">Определенные пользователем данные о состоянии.</param>
        <summary>Вызывается, когда конечный автомат асинхронно переходит в состояние прерывания с указанным исключением, значением времени ожидания, обратным вызовом и данными состояния.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginComplete">
      <MemberSignature Language="C#" Value="protected abstract IAsyncResult OnBeginComplete (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult OnBeginComplete(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.OnBeginComplete(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function OnBeginComplete (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract IAsyncResult ^ OnBeginComplete(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginComplete : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="receiveContext.OnBeginComplete (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Время ожидания для завершения операции завершения.</param>
        <param name="callback">Делегат асинхронного обратного вызова, принимающий уведомление о завершении асинхронной операции.</param>
        <param name="state">Определенные пользователем данные о состоянии.</param>
        <summary>Вызывается, когда конечный автомат асинхронно переходит в состояние завершения с указанным значением времени ожидания, обратным вызовом и данными состояния.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnComplete">
      <MemberSignature Language="C#" Value="protected abstract void OnComplete (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnComplete(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.OnComplete(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnComplete (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnComplete(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member OnComplete : TimeSpan -&gt; unit" Usage="receiveContext.OnComplete timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Время ожидания для завершения операции завершения.</param>
        <summary>Вызывается, когда конечный автомат переходит в состояние завершения с указанным значением времени ожидания.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndAbandon">
      <MemberSignature Language="C#" Value="protected abstract void OnEndAbandon (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEndAbandon(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.OnEndAbandon(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnEndAbandon (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnEndAbandon(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member OnEndAbandon : IAsyncResult -&gt; unit" Usage="receiveContext.OnEndAbandon result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, возвращенный вызовом одного из методов <see cref="Overload:System.ServiceModel.Channels.ReceiveContext.OnBeginAbandon" />.</param>
        <summary>Вызывается, когда конечный автомат выполняет переход в отброшенное состояние.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndComplete">
      <MemberSignature Language="C#" Value="protected abstract void OnEndComplete (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEndComplete(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.OnEndComplete(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub OnEndComplete (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void OnEndComplete(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member OnEndComplete : IAsyncResult -&gt; unit" Usage="receiveContext.OnEndComplete result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, возвращенный вызовом метода <see cref="M:System.ServiceModel.Channels.ReceiveContext.OnBeginComplete(System.TimeSpan,System.AsyncCallback,System.Object)" /></param>
        <summary>Вызывается, когда конечный автомат асинхронно выполняет переход в состояние завершения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFaulted">
      <MemberSignature Language="C#" Value="protected virtual void OnFaulted ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFaulted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.OnFaulted" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFaulted ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFaulted();" />
      <MemberSignature Language="F#" Value="abstract member OnFaulted : unit -&gt; unit&#xA;override this.OnFaulted : unit -&gt; unit" Usage="receiveContext.OnFaulted " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается, когда конечный автомат выполняет переход в состояние сбоя.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.ReceiveContextState State { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.Channels.ReceiveContextState State" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReceiveContext.State" />
      <MemberSignature Language="VB.NET" Value="Public Property State As ReceiveContextState" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::ServiceModel::Channels::ReceiveContextState State {  public:&#xA;System::ServiceModel::Channels::ReceiveContextState get(); protected:&#xA; void set(System::ServiceModel::Channels::ReceiveContextState value); };" />
      <MemberSignature Language="F#" Value="member this.State : System.ServiceModel.Channels.ReceiveContextState with get, set" Usage="System.ServiceModel.Channels.ReceiveContext.State" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.ReceiveContextState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает состояние конечного автомата.</summary>
        <value>Возвращает текущий контекст получения конечного автомата.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThisLock">
      <MemberSignature Language="C#" Value="protected object ThisLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ThisLock" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReceiveContext.ThisLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ThisLock As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ ThisLock { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ThisLock : obj" Usage="System.ServiceModel.Channels.ReceiveContext.ThisLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Объект, который используется для блокировки экземпляра <see cref="T:System.ServiceModel.Channels.ReceiveContext" />.</summary>
        <value><see cref="T:System.Object" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryGet">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается извлечь контекст получения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryGet">
      <MemberSignature Language="C#" Value="public static bool TryGet (System.ServiceModel.Channels.Message message, out System.ServiceModel.Channels.ReceiveContext property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGet(class System.ServiceModel.Channels.Message message, [out] class System.ServiceModel.Channels.ReceiveContext&amp; property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.TryGet(System.ServiceModel.Channels.Message,System.ServiceModel.Channels.ReceiveContext@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGet(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] System::ServiceModel::Channels::ReceiveContext ^ % property);" />
      <MemberSignature Language="F#" Value="static member TryGet : System.ServiceModel.Channels.Message *  -&gt; bool" Usage="System.ServiceModel.Channels.ReceiveContext.TryGet (message, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="property" Type="System.ServiceModel.Channels.ReceiveContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение.</param>
        <param name="property">Контекст получения.</param>
        <summary>Пытается получить контекст получения от указанного сообщения.</summary>
        <returns>Значение <see langword="true" />, если контекст получения был успешно получен; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGet">
      <MemberSignature Language="C#" Value="public static bool TryGet (System.ServiceModel.Channels.MessageProperties properties, out System.ServiceModel.Channels.ReceiveContext property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGet(class System.ServiceModel.Channels.MessageProperties properties, [out] class System.ServiceModel.Channels.ReceiveContext&amp; property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReceiveContext.TryGet(System.ServiceModel.Channels.MessageProperties,System.ServiceModel.Channels.ReceiveContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGet (properties As MessageProperties, ByRef property As ReceiveContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGet(System::ServiceModel::Channels::MessageProperties ^ properties, [Runtime::InteropServices::Out] System::ServiceModel::Channels::ReceiveContext ^ % property);" />
      <MemberSignature Language="F#" Value="static member TryGet : System.ServiceModel.Channels.MessageProperties *  -&gt; bool" Usage="System.ServiceModel.Channels.ReceiveContext.TryGet (properties, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.ServiceModel.Channels.MessageProperties" />
        <Parameter Name="property" Type="System.ServiceModel.Channels.ReceiveContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="properties">Коллекция свойств сообщения.</param>
        <param name="property">Контекст получения.</param>
        <summary>Пытается возвратить контекст получения из коллекции свойств указанного сообщения.</summary>
        <returns>Значение <see langword="true" />, если контекст получения был успешно получен; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>