<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f88a39f4d4dab5cf50f5b402455902e510a069b3" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57951647" /></Metadata><TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.FriendAccessAllowed</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет связанную с HTTP реализацию класса <see cref="T:System.Net.WebRequest" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  Мы не рекомендуем использовать `HttpWebRequest` для разработки новых приложений. Вместо этого используйте <xref:System.Net.Http.HttpClient?displayProperty=nameWithType> класса.

 <xref:System.Net.HttpWebRequest> Класс обеспечивает поддержку свойства и методы, определенные в <xref:System.Net.WebRequest> и дополнительные свойства и методы, которые позволяют пользователю взаимодействовать непосредственно с серверами с помощью HTTP.  
  
 Не используйте <xref:System.Net.HttpWebRequest.%23ctor%2A> конструктор. Используйте <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> метод для инициализации новых <xref:System.Net.HttpWebRequest> объектов. Если схема для универсальный код ресурса (URI) — `http://` или `https://`, <xref:System.Net.WebRequest.Create%2A> возвращает <xref:System.Net.HttpWebRequest> объекта.  
  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> Метод выполняет синхронный запрос к ресурсу, указанному в <xref:System.Net.HttpWebRequest.RequestUri%2A> свойством и возвращает <xref:System.Net.HttpWebResponse> , содержащий объект ответа. Данные ответа могут быть получены с помощью потока, возвращенного <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Если закрыт объект ответа или в поток ответа, остальные данные будут утрачены. Остальные данные будут утеряны и сокет будет повторно использован для последующих запросов, при закрытии объекта ответа или поток, при следующих условиях: активности или конвейерная передача запроса, только небольшой объем данных должен быть получен, или Осталось данных принимается в небольшого промежутка времени. Если ни одно из упомянутых выше условий хранения или превышения времени стока, сокет закрывается. Для поддержания активности или конвейерных подключений настоятельно рекомендуется, чтобы приложение считывает потоки до конца файла. Это гарантирует, что сокет будет использовать повторно для последующих запросов, что приводит к повышению производительности и менее ресурсы, используемые.  
  
 Если вы хотите отправлять данные в ресурс <xref:System.Net.HttpWebRequest.GetRequestStream%2A> возвращает метод <xref:System.IO.Stream> объект, используемый для отправки данных. <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> И <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> методы предоставляют асинхронный доступ к потоку данных отправки.  
  
 Для проверки подлинности клиента с <xref:System.Net.HttpWebRequest>, сертификат клиента должен быть установлен в хранилище сертификатов текущего пользователя.  
  
 <xref:System.Net.HttpWebRequest> Класса вызывает <xref:System.Net.WebException> при возникновении ошибок во время доступа к ресурсу. <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> Свойство содержит <xref:System.Net.WebExceptionStatus> значение, указывающее источник ошибки. Когда <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> — <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, <xref:System.Net.WebException.Response%2A> свойство содержит <xref:System.Net.HttpWebResponse> полученного из ресурса.  
  
 <xref:System.Net.HttpWebRequest> Предоставляет общие значения для заголовка HTTP посылаемые Интернет-ресурс в виде свойств, устанавливаемых методами, или системы. Следующая таблица содержит полный список. Другие заголовки можно задавать <xref:System.Net.HttpWebRequest.Headers%2A> свойства в виде пары имя/значение. Обратите внимание, что серверы и кэш может изменить или добавить заголовки во время запроса.  
  
 Ниже перечислены заголовки HTTP, которые задаются либо свойства или методы или системой.  
  
|Header|Задается|  
|------------|------------|  
|Принять|Задается <xref:System.Net.HttpWebRequest.Accept%2A> свойство.|  
|Подключение|Задается <xref:System.Net.HttpWebRequest.Connection%2A> свойства <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство.|  
|Content-Length|Задается <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство.|  
|Content-Type|Задается <xref:System.Net.HttpWebRequest.ContentType%2A> свойство.|  
|Ожидать|Задается <xref:System.Net.HttpWebRequest.Expect%2A> свойство.|  
|Дата|Задается равным текущей дате.|  
|Узел|Задайте системой, чтобы сведения о текущем узле.|  
|If-Modified-Since|Задается <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство.|  
|Диапазон|Задается <xref:System.Net.HttpWebRequest.AddRange%2A> метод.|  
|Источник ссылки|Задается <xref:System.Net.HttpWebRequest.Referer%2A> свойство.|  
|Transfer-Encoding|Задается <xref:System.Net.HttpWebRequest.TransferEncoding%2A> свойство ( <xref:System.Net.HttpWebRequest.SendChunked%2A> свойство должно быть `true`).|  
|Агент пользователя|Задается <xref:System.Net.HttpWebRequest.UserAgent%2A> свойство.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> регистрируется автоматически. Необходимо вызвать <xref:System.Net.WebRequest.RegisterPrefix%2A> метод, чтобы зарегистрировать <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> перед использованием URIs начиная с версии `http://` или `https://`.  
  
 Локальный компьютер или файл конфигурации приложения могут использовать прокси-сервер по умолчанию. Если <xref:System.Net.HttpWebRequest.Proxy%2A> свойство указано, затем параметры прокси-сервера из <xref:System.Net.HttpWebRequest.Proxy%2A> переопределения свойств локального компьютера или файл конфигурации приложения и <xref:System.Net.HttpWebRequest> экземпляр будет использовать параметры прокси-сервера, который указан. Если прокси-сервера не указан в файле конфигурации и <xref:System.Net.HttpWebRequest.Proxy%2A> свойство не задано, <xref:System.Net.HttpWebRequest> класс использует параметры прокси-сервера, унаследованные от Internet Explorer на локальном компьютере. Если отсутствуют параметры прокси-сервера в Internet Explorer, запрос отправляется непосредственно на сервер.  
  
 <xref:System.Net.HttpWebRequest> Класс анализирует список обхода прокси-сервера с подстановочными знаками, унаследованные от Internet Explorer, по-разному, чем список вариантов обхода анализируется непосредственно с Internet Explorer. Например <xref:System.Net.HttpWebRequest> класс будет выполнять синтаксический анализ списка обход проверки «nt *» из Internet Explorer регулярные выражения «nt. $». Это отличается от собственное поведение обозревателя Internet Explorer. Поэтому URL-адрес "`http://intxxxxx`" будут обходить прокси с помощью <xref:System.Net.HttpWebRequest> класса, но не будут обходить прокси-сервера, с помощью Internet Explorer.  
  
> [!NOTE]
>  Платформа кэширует сеансы SSL, так как они создаются и пытается повторно использовать кэшированный сеанс для нового запроса, если это возможно. При попытке повторно использовать сеанс SSL, инфраструктура использует первый элемент <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (если есть), или производится попытка повторного использования анонимного сеансы, если <xref:System.Net.HttpWebRequest.ClientCertificates%2A> пуст.  
  
> [!NOTE]
>  По соображениям безопасности файлы cookie отключены по умолчанию. Если вы хотите использовать файлы cookie, используйте <xref:System.Net.HttpWebRequest.CookieContainer%2A> свойство, чтобы включить файлы cookie.  
  
 .NET Framework 4.6 включает новую функцию безопасности, блокирующее небезопасных шифрования и хэширования алгоритмы для подключений. Приложения, с помощью протокола TLS/SSL через API-интерфейсы, такие как HttpClient, HttpWebRequest, FTPClient, SmtpClient, SslStream т. д. и предназначенные для .NET Framework 4.6 получают более надежные и безопасные поведение по умолчанию.  
  
 Разработчики имеют возможность отказаться от этого поведения для сохранения функциональной совместимости с существующей SSL3 службами или TLS с служб RC4. [В этой статье](https://support.microsoft.com/kb/3069494) объясняется, как изменить код таким образом, чтобы отключить новое поведение.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Net.HttpWebRequest> для URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">для доступа к запрашиваемому URL-АДРЕСУ или любой URI, который перенаправляется запрос. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
    <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Изменения в аутентификации NTLM для HTTPWebRequest в версии 3.5 с пакетом обновления 1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.HttpWebRequest" />. Эти конструкторы устарели. Дополнительные сведения см. в разделе "Заметки".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Оба <xref:System.Net.HttpWebRequest> конструкторы, устарели и не должны использоваться. Вызовите <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> метод для инициализации новых <xref:System.Net.HttpWebRequest> объектов.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.HttpWebRequest" />. Этот конструктор является устаревшим.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, который содержит сведения, требуемые для сериализации нового объекта <see cref="T:System.Net.HttpWebRequest" />.</param>
        <param name="streamingContext">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий исходный объект и объект назначения для сериализованного потока, связанного с новым объектом <see cref="T:System.Net.HttpWebRequest" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.HttpWebRequest" /> на основе указанных экземпляров классов <see cref="T:System.Runtime.Serialization.SerializationInfo" /> и <see cref="T:System.Runtime.Serialization.StreamingContext" />. Этот конструктор является устаревшим.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании сериализации, приложение должно работать в режиме полного доверия.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">для неограниченного доступа к сетевым ресурсам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Сериализация XML и SOAP</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет запрос к интернет-ресурсу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A> Метод отменяет запрос к ресурсу. После отмены запроса, вызвав <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, или <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> метода заставляет <xref:System.Net.WebException> с <xref:System.Net.WebException.Status%2A> свойство значение <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 <xref:System.Net.HttpWebRequest.Abort%2A> Метод будет выполняться синхронно обратный вызов, указанный для <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> методы Если <xref:System.Net.HttpWebRequest.Abort%2A> метод вызывается во время этих операций, ожидающих выполнения. Это может привести к потенциальные проблемы взаимоблокировки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [трассировки сети](https://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 В случае асинхронных запросов возлагается клиентского приложения, чтобы реализовать собственный механизм времени ожидания. В следующем примере кода показано, как это сделать.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Accept" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Accept" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы очистить `Accept` задать заголовок HTTP, <xref:System.Net.HttpWebRequest.Accept%2A> свойства `null`.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.Accept%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет в запрос заголовок диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Так как все сущности HTTP представляются в HTTP-сообщения в виде последовательности байтов, концепция диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок диапазона в запросе позволяет клиенту для запроса, что его нужно получить только часть указанный диапазон байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет заголовок диапазона байтов для запроса.  
  
 Если `range` положительно, `range` параметр указывает начальную точку диапазона. Сервер следует начать отправку данных из `range` параметр, указанный в конец данных сущности HTTP.  
  
 Если `range` отрицательное, `range` параметр указывает конечную точку диапазона. Сервер следует начать отправку данных в начале данных сущности HTTP для `range` указан параметр.  
  
 Так как все сущности HTTP представляются в HTTP-сообщения в виде последовательности байтов, концепция диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок диапазона в запросе позволяет клиенту для запроса, что его нужно получить только часть указанный диапазон байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 Пример заголовка диапазона в запросе протокола HTTP, который запрашивает у сервера отправку первые 100 байт (от начала до позиции байта 99) будет следующим:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `range` параметр имел бы -99.  
  
 HTTP-сервера указывает на поддержку заголовки диапазон с заголовком Accept-Ranges. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки диапазона. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но также распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанный с запросом всей анализируются и сделан доступным через свойства <xref:System.Net.HttpWebResponse> класса. Заголовки, связанные с каждым диапазоном возвращаются в ответе.  
  
   
  
## Examples  
 В следующем примере кода добавляет заголовок диапазона для запроса.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет заголовок диапазона байтов для запроса.  
  
 Если `range` положительно, `range` параметр указывает начальную точку диапазона. Сервер следует начать отправку данных из `range` параметр, указанный в конец данных сущности HTTP.  
  
 Если `range` отрицательное, `range` параметр указывает конечную точку диапазона. Сервер следует начать отправку данных в начале данных сущности HTTP для `range` указан параметр.  
  
 Так как все сущности HTTP представляются в HTTP-сообщения в виде последовательности байтов, концепция диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок диапазона в запросе позволяет клиенту для запроса, что его нужно получить только часть указанный диапазон байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 Пример заголовка диапазона в запросе протокола HTTP, который запрашивает у сервера отправку первые 100 байт (от начала до позиции байта 99) будет следующим:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `range` параметр имел бы -99.  
  
 HTTP-сервера указывает на поддержку заголовки диапазон с заголовком Accept-Ranges. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки диапазона. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но также распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанный с запросом всей анализируются и сделан доступным через свойства <xref:System.Net.HttpWebResponse> класса. Заголовки, связанные с каждым диапазоном возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="to" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет заголовок диапазона байтов для запроса.  
  
 Так как все сущности HTTP представляются в HTTP-сообщения в виде последовательности байтов, концепция диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок диапазона в запросе позволяет клиенту для запроса, что его нужно получить только часть указанный диапазон байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 Пример заголовка диапазона в запросе протокола HTTP, которые бы запросы первые 100 байт будет следующее:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `from` параметр должен быть указан как 0 и `to` параметр должен быть указан как 99. Спецификатор диапазона автоматически устанавливается как «исключительного пользования» с помощью данного метода.  
  
 HTTP-сервера указывает на поддержку заголовки диапазон с заголовком Accept-Ranges. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки диапазона. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но также распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанный с запросом всей анализируются и сделан доступным через свойства <xref:System.Net.HttpWebResponse> класса. Заголовки, связанные с каждым диапазоном возвращаются в ответе.  
  
   
  
## Examples  
 В следующем примере кода добавляет заголовок диапазона для запроса.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> больше <paramref name="to" />  
  
-или- 
 Значение <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="to" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона байтов для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет заголовок диапазона байтов для запроса.  
  
 Так как все сущности HTTP представляются в HTTP-сообщения в виде последовательности байтов, концепция диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок диапазона в запросе позволяет клиенту для запроса, что его нужно получить только часть указанный диапазон байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 Пример заголовка диапазона в запросе протокола HTTP, которые бы запросы первые 100 байт будет следующее:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `from` параметр должен быть указан как 0 и `to` параметр должен быть указан как 99. Спецификатор диапазона автоматически устанавливается как «исключительного пользования» с помощью данного метода.  
  
 HTTP-сервера указывает на поддержку заголовки диапазон с заголовком Accept-Ranges. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки диапазона. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но также распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанный с запросом всей анализируются и сделан доступным через свойства <xref:System.Net.HttpWebResponse> класса. Заголовки, связанные с каждым диапазоном возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> больше <paramref name="to" />  
  
-или- 
 Значение <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="range" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок Range для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет в запрос заголовок диапазона.  
  
 Если `range` положительно, `range` параметр указывает начальную точку диапазона. Сервер следует начать отправку данных из `range` параметр, указанный в конец данных сущности HTTP.  
  
 Если `range` отрицательное, `range` параметр указывает конечную точку диапазона. Сервер следует начать отправку данных в начале данных сущности HTTP для `range` указан параметр.  
  
 Так как все сущности HTTP представляются в HTTP-сообщения в виде последовательности байтов, концепция диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок диапазона в запросе позволяет клиенту для запроса, что его нужно получить только часть указанный диапазон байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 `rangeSpecifier` Параметр обычно может быть задан как «исключительного пользования», так как это единственный спецификатор диапазона, который распознается большинством серверов HTTP. Параметр `rangeSpecifier` параметра, либо другой строки разрешает поддержку настраиваемого диапазона описатели, отличные от байтов (описатель диапазона байтов, определяемый в RFC 2616 IETF).  
  
 Пример заголовка диапазона в запросе протокола HTTP, которые бы запросы первые 100 байт будет следующее:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 В этом примере `rangeSpecifier` параметр указывается как «исключительного пользования» и `range` параметр имел бы -99.  
  
 HTTP-сервера указывает на поддержку заголовки диапазон с заголовком Accept-Ranges в ответе. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки диапазона. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но также распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанный с запросом всей анализируются и сделан доступным через свойства <xref:System.Net.HttpWebResponse> класса. Заголовки, связанные с каждым диапазоном возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="range" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="range">Начальная или конечная точка диапазона.</param>
        <summary>Добавляет в запрос заголовок Range для определенного диапазона, располагающегося с начала или с конца запрашиваемых данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет в запрос заголовок диапазона.  
  
 Если `range` положительно, `range` параметр указывает начальную точку диапазона. Сервер следует начать отправку данных из `range` параметр, указанный в конец данных сущности HTTP.  
  
 Если `range` отрицательное, `range` параметр указывает конечную точку диапазона. Сервер следует начать отправку данных в начале данных сущности HTTP для `range` указан параметр.  
  
 Так как все сущности HTTP представляются в HTTP-сообщения в виде последовательности байтов, концепция диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок диапазона в запросе позволяет клиенту для запроса, что его нужно получить только часть указанный диапазон байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 `rangeSpecifier` Параметр обычно может быть задан как «исключительного пользования», так как это единственный спецификатор диапазона, который распознается большинством серверов HTTP. Параметр `rangeSpecifier` параметра, либо другой строки разрешает поддержку настраиваемого диапазона описатели, отличные от байтов (описатель диапазона байтов, определяемый в RFC 2616 IETF).  
  
 Пример заголовка диапазона в запросе протокола HTTP, которые бы запросы первые 100 байт будет следующее:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 В этом примере `rangeSpecifier` параметр указывается как «исключительного пользования» и `range` параметр имел бы -99.  
  
 HTTP-сервера указывает на поддержку заголовки диапазон с заголовком Accept-Ranges в ответе. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки диапазона. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но также распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанный с запросом всей анализируются и сделан доступным через свойства <xref:System.Net.HttpWebResponse> класса. Заголовки, связанные с каждым диапазоном возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="from" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="to" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет в запрос заголовок диапазона.  
  
 Так как все сущности HTTP представляются в HTTP-сообщения в виде последовательности байтов, концепция диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок диапазона в запросе позволяет клиенту для запроса, что его нужно получить только часть указанный диапазон байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 `rangeSpecifier` Параметр обычно может быть задан как «исключительного пользования», так как это единственный спецификатор диапазона, который распознается большинством серверов HTTP. Параметр `rangeSpecifier` параметра, либо другой строки разрешает поддержку настраиваемого диапазона описатели, отличные от байтов (описатель диапазона байтов, определяемый в RFC 2616 IETF).  
  
 Пример заголовка диапазона в запросе протокола HTTP, которые бы запросы первые 100 байт будет следующее:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `rangeSpecifier` «исключительного пользования», будет задан параметр `from` параметра будет равно 0 и `to` параметр имел бы 99.  
  
 HTTP-сервера указывает на поддержку заголовки диапазон с заголовком Accept-Ranges в ответе. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Спецификатор диапазона, который бы выполнить путем является строкой, указанной в заголовке Accept-Ranges `rangeSpecifier` параметр для этого метода.  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки диапазона. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но также распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанный с запросом всей анализируются и сделан доступным через свойства <xref:System.Net.HttpWebResponse> класса. Заголовки, связанные с каждым диапазоном возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> больше <paramref name="to" />  
  
-или- 
 Значение параметра <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="from" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="to" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">Описание диапазона.</param>
        <param name="from">Место начала передачи данных.</param>
        <param name="to">Место остановки передачи данных.</param>
        <summary>Добавляет в запрос заголовок диапазона для заданного диапазона.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> Метод добавляет в запрос заголовок диапазона.  
  
 Так как все сущности HTTP представляются в HTTP-сообщения в виде последовательности байтов, концепция диапазон байтов может применяться для любой сущности HTTP. Однако не все клиенты и серверы должны поддерживать операции диапазона байтов.  
  
 Заголовок диапазона в запросе позволяет клиенту для запроса, что его нужно получить только часть указанный диапазон байтов в сущности HTTP. Серверы не требуются для поддержки запросов заголовка Range.  
  
 `rangeSpecifier` Параметр обычно может быть задан как «исключительного пользования», так как это единственный спецификатор диапазона, который распознается большинством серверов HTTP. Параметр `rangeSpecifier` параметра, либо другой строки разрешает поддержку настраиваемого диапазона описатели, отличные от байтов (описатель диапазона байтов, определяемый в RFC 2616 IETF).  
  
 Пример заголовка диапазона в запросе протокола HTTP, которые бы запросы первые 100 байт будет следующее:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 В этом примере `rangeSpecifier` «исключительного пользования», будет задан параметр `from` параметра будет равно 0 и `to` параметр имел бы 99.  
  
 HTTP-сервера указывает на поддержку заголовки диапазон с заголовком Accept-Ranges в ответе. Пример заголовка Accept-Ranges с сервера, который поддерживает диапазонов байтов будет выглядеть следующим образом:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Спецификатор диапазона, который бы выполнить путем является строкой, указанной в заголовке Accept-Ranges `rangeSpecifier` параметр для этого метода.  
  
 Если заголовок Accept-Ranges не получен в заголовке ответа от сервера, сервер не поддерживает заголовки диапазона. Пример заголовка Accept-Ranges с сервера, который не поддерживает диапазоны, но также распознает заголовок Accept-Ranges, будет выглядеть следующим образом:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 При получении ответа от запроса диапазона, заголовки HTTP, связанный с запросом всей анализируются и сделан доступным через свойства <xref:System.Net.HttpWebResponse> класса. Заголовки, связанные с каждым диапазоном возвращаются в ответе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rangeSpecifier" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="from" /> больше <paramref name="to" />  
  
-или- 
 Значение параметра <paramref name="from" /> или <paramref name="to" /> меньше 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rangeSpecifier" /> недопустим.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось добавить заголовок диапазона.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает URI интернет-ресурса, который фактически отвечает на запрос.</summary>
        <value>Класс <see cref="T:System.Uri" />, идентифицирующий интернет-ресурс, который отвечает на запрос. По умолчанию это URI, используемый методом <see cref="M:System.Net.WebRequest.Create(System.String)" /> для инициализации запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A> Свойство имеет значение URI после любых перенаправлений, которые происходят во время запроса.  
  
 URI исходного запроса сохраняется в <xref:System.Net.HttpWebRequest.RequestUri%2A> свойство.  
  
   
  
## Examples  
 В следующем коде примере выполняется проверка на предмет <xref:System.Net.HttpWebRequest> объект `req` была перенаправлена в другое расположение для выполнения запроса и задает значение `hasChanged` переменной `true` Если запрос был перенаправлен; в противном случае `hasChanged`присваивается `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, должен ли запрос следовать ответам переадресации.</summary>
        <value>Значение <see langword="true" />, если запрос должен автоматически следовать ответам переадресации, получаемым от интернет-ресурса; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задайте <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> для `true` Если запросом, автоматически заголовки перенаправления HTTP в новое расположение ресурса. Максимальное число выполняемых перенаправления задается <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> свойство.  
  
 Если <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> присваивается `false`, все ответы с кодом состояния HTTP от 300 до 399 возвращается в приложение.  
  
 Заголовок авторизации очищается при автоматическом перенаправление и <xref:System.Net.HttpWebRequest> автоматически пытается выполнить повторную аутентификацию в перенаправленном расположении. На практике это означает, что приложение невозможно поместить информацию нестандартной проверки подлинности в заголовке авторизации, если есть вероятность столкнуться с перенаправлением. Вместо этого приложения необходимо реализовать и зарегистрировать пользовательский модуль проверки подлинности. <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> И связанного класса используются для реализации пользовательского модуля проверки подлинности. <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> Метод регистрирует пользовательский модуль проверки подлинности.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> свойство, чтобы разрешить запрос следовать ответам перенаправления.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, будет ли выполняться буферизация данных, полученных от интернет-ресурса.</summary>
        <value>Значение <see langword="true" /> устанавливается для включения буферизации данных, получаемых от интернет-ресурса; значение <see langword="false" /> — для выключения буферизации. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, будет ли выполняться буферизация данных, посылаемых в интернет-ресурс.</summary>
        <value>Значение <see langword="true" /> устанавливается для включения буферизации данных, посылаемых в интернет-ресурс; значение <see langword="false" /> — для выключения буферизации. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> является `true`, выполняется буферизация данных в памяти, чтобы подготовить повторно в случае перенаправления или проверки подлинности запросов.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> свойство для выключения буферизации данных.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Установка <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> для <see langword="true" /> может привести к снижению производительности при отправке больших наборов данных, поскольку буфер данных может использовать всю доступную память.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тип используемой распаковки.</summary>
        <value>Объект <see cref="T:System.Net.DecompressionMethods" /> , указывающий тип используемой распаковки.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Текущее состояние объекта не позволяет задать это свойство.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект состояния для данного запроса.</param>
        <summary>Начинает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных.</summary>
        <returns>Класс <see cref="T:System.IAsyncResult" />, ссылающийся на асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Метод начинает выполнение асинхронного запроса для потока, используемый для отправки данных <xref:System.Net.HttpWebRequest>. Метод асинхронного обратного вызова использует <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> метод для возврата существующего потока.  
  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> Метод требует некоторые задачи синхронной установки для завершения (разрешение DNS, обнаружение прокси-сервера и подключение через сокет TCP, например), прежде чем этот метод становится асинхронной. Таким образом, этот метод вызывать не следует в потоке пользовательского интерфейса пользователя, так как для завершения задач начальной настройки синхронной перед исключение для сообщение об ошибке может занять значительное время (до нескольких минут в зависимости от параметров сети) или метод завершается успешно.  
  
 Дополнительные сведения о пуле потоков, см. в разделе [пул управляемых потоков](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Приложение нельзя смешивать синхронные и асинхронные методы для определенного запроса. При вызове метода <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метода, необходимо использовать <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> метод для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метод для выполнения асинхронного запроса экземпляра потока.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">Значение свойства <see cref="P:System.Net.HttpWebRequest.Method" /> — GET или HEAD.  
  
-или- 
 Значение <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> — <see langword="true" />, значение <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> — <see langword="false" />, значение <see cref="P:System.Net.HttpWebRequest.ContentLength" /> — -1, значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> — <see langword="false" /> и значение <see cref="P:System.Net.HttpWebRequest.Method" /> — POST или PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Поток занят предыдущим вызовом <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  
  
-или- 
 Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> устанавливается значение, а значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.  
  
-или- 
В пуле потоков заканчиваются потоки.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша, однако запросы, записывающие данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского проверяющего элемента управления кэша, который неправильно реализован.</exception>
        <exception cref="T:System.Net.WebException">Метод <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.</exception>
        <exception cref="T:System.ObjectDisposedException">В приложении .NET Compact Framework поток запроса с длиной содержимого, равной нулю, не был получен и закрыт допустимым образом. Дополнительные сведения об обработке запросов с нулевой длиной содержимого см. в разделе [Сетевое программирование в .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" /></param>
        <param name="state">Объект состояния для данного запроса.</param>
        <summary>Начинает асинхронный запрос интернет-ресурса.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, ссылающийся на асинхронный запрос ответа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Метод начинает асинхронный запрос ответа от Интернет-ресурса. Метод асинхронного обратного вызова использует <xref:System.Net.HttpWebRequest.EndGetResponse%2A> метод, чтобы вернуть фактические <xref:System.Net.WebResponse>.  
  
 Объект <xref:System.Net.ProtocolViolationException> возникает в нескольких случаях, когда значение свойства на <xref:System.Net.HttpWebRequest> являются конфликтующими. Это исключение возникает, если приложение задает <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство и <xref:System.Net.HttpWebRequest.SendChunked%2A> свойства `true`, а затем отправляет запрос HTTP GET. Это исключение возникает, если приложение пытается отправить блочный на сервер, который поддерживает только протокол HTTP 1.0, где это не поддерживается. Это исключение возникает, если приложение пытается отправить данные без параметра <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство или <xref:System.Net.HttpWebRequest.SendChunked%2A> — `false` при отключенной буферизации и для проверки активности подключения ( <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство `true`)`.`  
  
 Если <xref:System.Net.WebException> является исключение, используйте <xref:System.Net.WebException.Response%2A> и <xref:System.Net.WebException.Status%2A> свойств исключения, чтобы определить ответ от сервера.  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> Метод требует некоторые задачи синхронной установки для завершения (разрешение DNS, обнаружение прокси-сервера и подключение через сокет TCP, например), прежде чем этот метод становится асинхронной. Таким образом, этот метод вызывать не следует в потоке пользовательского интерфейса пользователя, так как для завершения задач начальной настройки синхронной перед исключение для сообщение об ошибке может занять значительное время (до нескольких минут в зависимости от параметров сети) или метод завершается успешно.  
  
 Дополнительные сведения о пуле потоков, см. в разделе [пул управляемых потоков](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  Приложение нельзя смешивать синхронные и асинхронные методы для определенного запроса. При вызове метода <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метода, необходимо использовать <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> метод для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> метод для выполнения асинхронного запроса для Интернет-ресурса.  
  
> [!NOTE]
>  В случае асинхронных запросов возлагается клиентского приложения, чтобы реализовать собственный механизм времени ожидания. В следующем примере кода показано, как это сделать.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток уже занят предыдущим вызовом <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  
  
-или- 
 Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> устанавливается значение, а значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.  
  
-или- 
В пуле потоков заканчиваются потоки.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">Значение <see cref="P:System.Net.HttpWebRequest.Method" /> — GET или HEAD, кроме того или <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше нуля, или <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="true" />.  
  
-или- 
 Значение <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> — <see langword="true" />, значение <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> — <see langword="false" /> и одно из следующих: значение <see cref="P:System.Net.HttpWebRequest.ContentLength" /> — -1, значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> — <see langword="false" /> и значение <see cref="P:System.Net.HttpWebRequest.Method" /> — POST или PUT.  
  
-или- 
<see cref="T:System.Net.HttpWebRequest" /> имеет тело сущности, но метод <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> вызывается без вызова метода <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.  
  
-или- 
Значение свойства <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше нуля, однако приложение не записывает все обещанные данные.</exception>
        <exception cref="T:System.Net.WebException">Метод <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает коллекцию сертификатов безопасности, связанных с данным запросом.</summary>
        <value>Коллекция <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />, содержащая сертификаты безопасности, связанные этим с запросом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение можно добавить сертификат в коллекцию, но могут отсутствовать права доступа к нему. Чтобы использовать сертификат, содержащийся в коллекции, приложение должно иметь те же права доступа, что лицо, выдавшее сертификат.  
  
> [!NOTE]
>  Платформа кэширует сеансы SSL, так как они создаются и пытается повторно использовать кэшированный сеанс для нового запроса, если это возможно. При попытке повторно использовать сеанс SSL, инфраструктура использует первый элемент <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (если есть), или производится попытка повторного использования анонимного сеансы, если <xref:System.Net.HttpWebRequest.ClientCertificates%2A> пуст.  
  
> [!NOTE]
>  Для повышения производительности, не следует добавлять сертификат клиента для <xref:System.Net.HttpWebRequest> Если неизвестно, сервер будет запрашивать его.  
>   
>  Пример кода, иллюстрирующий, как перечисление сертификатов в хранилище сертификатов клиента, см. в разделе <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Для операции задания указано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Connection" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Connection" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отправляет запрос <xref:System.Net.HttpWebRequest.Connection%2A> свойство Интернет-ресурс как `Connection` заголовок HTTP. Если значение <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство `true`, значение «Keep-alive» добавляется в конец `Connection` заголовка.  
  
 Чтобы очистить `Connection` задать заголовок HTTP, <xref:System.Net.HttpWebRequest.Connection%2A> свойства `null`.  
  
 Изменение <xref:System.Net.HttpWebRequest.Connection%2A> свойство после запуска запроса путем вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает метод <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.HttpWebRequest.Connection%2A> свойство, чтобы задать значение заголовка HTTP-подключения.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение заголовка <see cref="P:System.Net.HttpWebRequest.Connection" /> устанавливается равным Keep-alive или Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя группы подключения для запроса.</summary>
        <value>Имя группы подключения для данного запроса. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> Свойство позволяет связывать запрос с группой подключения. Это полезно в тех случаях, когда приложение отправляет запросы к одному серверу для разных пользователей, таких как веб-сайт, который извлекает сведения о клиенте на сервере базы данных.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать пользовательские данные для объединения в группы соединений, при условии, что переменные `username`, `password`, и `domain` задаются для приложения до вызова этого кода.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Каждая группа подключения создает дополнительные соединения для сервера. Это может привести превышения числа подключений задаются <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> свойства для этого сервера.</para></block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
        <related type="Article" href="~/docs/framework/network-programming/connection-grouping.md">Группирование подключений</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает HTTP-заголовок <see langword="Content-length" />.</summary>
        <value>Количество байтов данных, посылаемых в интернет-ресурс. Значение по умолчанию, равное –1, показывает, что свойство не установлено и отсутствуют данные запроса, предназначенные для отправки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentLength%2A> Свойство содержит значение для отправки в виде `Content-length` заголовок HTTP с запросом.  
  
 Значение, отличное от -1 в <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство указывает, что запрос передает данные и что только те методы, которые загружают данные могут быть установлены <xref:System.Net.HttpWebRequest.Method%2A> свойство.  
  
 После <xref:System.Net.HttpWebRequest.ContentLength%2A> свойству присвоено значение, это количество байтов должно записываться в поток запроса, который возвращается путем вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метод или оба <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> и <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> методы.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство длине строки.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос запущен с помощью метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Новое значение <see cref="P:System.Net.HttpWebRequest.ContentLength" /> меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Content-type" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Content-type" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A> Свойство содержит тип мультимедиа запроса. Значения, присвоенные <xref:System.Net.HttpWebRequest.ContentType%2A> свойство замените все существующее содержимое при отправке запроса `Content-type` заголовок HTTP.  
  
 Чтобы очистить `Content-type` задать заголовок HTTP, <xref:System.Net.HttpWebRequest.ContentType%2A> свойства `null`.  
  
> [!NOTE]
>  Значение этого свойства хранится в <xref:System.Net.WebHeaderCollection> . Если <xref:System.Net.WebHeaderCollection> не установлен, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.ContentType%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метод делегата, вызываемый при получении от интернет-ресурса HTTP-ответа 100-continue.</summary>
        <value>Делегат, реализующий метод обратного вызова, который выполняется при возвращении от интернет-ресурса ответа HTTP Continue. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> Свойство указывает метод обратного вызова, необходимо вызвать, когда клиент получает 100-продолжения ответа.  
  
 Когда <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> свойство имеет значение, клиент вызывает делегат каждый раз, когда протокол ответа типа <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) принимаются. Это полезно, если требуется, чтобы клиент для отображения состояния данных, получаемых от Интернет-ресурса.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает время ожидания в миллисекундах до получения ответа 100-Continue с сервера.</summary>
        <value>Время ожидания в миллисекундах до получения ответа 100-Continue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если 100-по-прежнему ответа получено до истечения времени ожидания, можно отправить в тело.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает файлы cookie, связанные с запросом.</summary>
        <value>Контейнер <see cref="T:System.Net.CookieContainer" />, в котором содержатся файлы cookie, связанные с этим запросом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> Свойство предоставляет экземпляр <xref:System.Net.CookieContainer> класс, который содержит файлы cookie, связанные с этим запросом.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> является `null` по умолчанию. Необходимо назначить <xref:System.Net.CookieContainer> объекта к свойству файлы cookie, возвращаемые в <xref:System.Net.HttpWebResponse.Cookies%2A> свойство <xref:System.Net.HttpWebResponse> возвращаемые <xref:System.Net.HttpWebRequest.GetResponse%2A> метод.  
  
> [!NOTE]
>  По соображениям безопасности файлы cookie отключены по умолчанию. Если вы хотите использовать файлы cookie, используйте <xref:System.Net.HttpWebRequest.CookieContainer%2A> свойство, чтобы включить файлы cookie.  
  
   
  
## Examples  
 В следующем примере кода отправляет запрос на URL-адрес и отображает файлы cookie, возвращаемые в ответе.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о проверке подлинности для этого запроса.</summary>
        <value>Класс <see cref="T:System.Net.ICredentials" />, содержащий учетные данные для проверки подлинности, связанные с запросом. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A> Свойство содержит сведения о проверке подлинности для идентификации автора запроса. <xref:System.Net.HttpWebRequest.Credentials%2A> Свойство может быть либо <xref:System.Net.NetworkCredential>, в какой пользователем, пароля и домена сведения, содержащиеся в <xref:System.Net.NetworkCredential> объект используется для проверки подлинности запроса, или он может быть <xref:System.Net.CredentialCache>в этом случае универсальный код ресурса Код (URI) запроса используется для определения пользователя, пароль и сведения о домене для проверки подлинности запроса.  
  
 В большинстве сценариев на стороне клиента следует использовать <xref:System.Net.CredentialCache.DefaultCredentials%2A> свойство, содержащее учетные данные текущего пользователя. Чтобы сделать это, установите <xref:System.Net.WebClient.UseDefaultCredentials%2A> свойства `true` вместо этого свойства.  
  
 Если <xref:System.Net.HttpWebRequest> класс используется в приложении среднего уровня, например приложение ASP.NET, учетные данные в <xref:System.Net.CredentialCache.DefaultCredentials%2A> свойство принадлежит учетная запись, работает на ASP-страницу (учетные данные на стороне сервера). Как правило это свойство будет присвоено учетные данные клиента, от лица которого выполняется запрос.  
  
> [!NOTE]
>  Схема проверки подлинности NTLM не может использоваться для олицетворения другого пользователя. Kerberos должен быть специально настроен для поддержки олицетворения.  
  
 Чтобы ограничить HttpWebRequest один или несколько методов проверки подлинности, использовать <xref:System.Net.CredentialCache> класса и привязать свои учетные данные для одного или нескольких схем проверки подлинности  
  
 Поддерживаемый тип проверки подлинности схемы включают дайджест, Negotiate, Kerberos, NTLM и Basic.  
  
 По соображениям безопасности при автоматически перенаправляет, сохранить учетные данные, которые вы хотите включить в перенаправления в <xref:System.Net.CredentialCache> и присвоить его этому свойству. Это свойство будет автоматически присвоено `null` при перенаправлении, если он содержит какой-либо кроме <xref:System.Net.CredentialCache>. Наличие значение этого свойства автоматически присваивается значение `null` при этих условиях предотвращает учетные данные, отправляемые в любое непреднамеренное назначение.
  
## Examples  
 В следующем примере кода задает учетные данные для запроса.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение заголовка HTTP <see langword="Date" /> для использования в HTTP-запросе.</summary>
        <value>Значение заголовка Date в HTTP-запросе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если заголовок даты `null`, то возвращаемое значение будет присвоено <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 <xref:System.Net.HttpWebRequest.Date%2A> Свойство — это стандарт <xref:System.DateTime?displayProperty=nameWithType> объекта и может содержать <xref:System.DateTimeKind?displayProperty=nameWithType> поле <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, или <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Любые виды времени можно задать при использовании <xref:System.Net.HttpWebRequest.Date%2A> свойство. Если <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> при задании или получении, <xref:System.Net.HttpWebRequest.Date%2A> свойство предполагается, что <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (местное время).  
  
 Классы в <xref:System.Net> пространства имен всегда записывают его <xref:System.Net.HttpWebRequest.Date%2A> свойство по сети во время передачи в стандартную форму, используя формат по Гринвичу (Utc).  
  
 Если <xref:System.Net.HttpWebRequest.Date%2A> свойству <xref:System.DateTime.MinValue?displayProperty=nameWithType>, а затем `Date` HTTP-заголовок удаляется из <xref:System.Net.HttpWebRequest.Headers%2A> свойство и <xref:System.Net.WebHeaderCollection>.  
  
 Если <xref:System.Net.HttpWebRequest.Date%2A> свойство <xref:System.DateTime.MinValue?displayProperty=nameWithType>, это означает, что `Date` HTTP-заголовок не включается в <xref:System.Net.HttpWebRequest.Headers%2A> свойство и <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
 Если <xref:System.Net.HttpWebRequest.Date%2A> имеет значение и предпринята попытка отправить <xref:System.Net.HttpWebRequest> без текста, а затем <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> будет генерироваться <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, и <xref:System.Net.HttpWebRequest.EndGetResponse%2A> методы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает политику кэширования для этого запроса.</summary>
        <value>Свойство <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />, которое указывает политику кэширования, действующую для этого запроса, если не применима любая другая политика.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задание этого свойства регистрирует указанную политику для схем HTTP и HTTPS. Эта политика используется для данного запроса, если:  
  
 Существует не <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> свойство, указанное для данного запроса.  
  
-или-
  
 Конфигурации компьютера и приложения, файлы не указать политику кэширования, которая будет применяться к универсальный код ресурса (URI) используется для создания данного запроса.  
  
 Политика кэширования, определяет ли запрошенный ресурс может браться из кэша вместо отправки запроса к главному компьютеру ресурсов.  
  
 Копию ресурса добавляется в кэш, только если получен и чтения в конец потока в поток ответа для ресурса. Поэтому другой запрос для одного ресурса может использовать кэшированную копию, в зависимости от уровня политики кэша для этого запроса.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">для неограниченного доступа к сетевым ресурсам. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает наибольшую длину по умолчанию для ответа HTTP об ошибке.</summary>
        <value>Наибольшая длина по умолчанию для ответа HTTP об ошибке.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение меньше 0 и не равно -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает для свойства <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> значение по умолчанию.</summary>
        <value>Длина в килобайтах (1024 байта) или максимум по умолчанию для получаемых заголовков ответов. В конфигурационном файле по умолчанию это значение устанавливается равным 64 килобайтам.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длина заголовка ответа получено строку состояния ответа, а также все дополнительные управляющие символы, получаемые в протоколе HTTP. Значение-1 означает отсутствие ограничений на заголовки ответа получено; значение 0 означает, что все запросы завершаются сбоем.  
  
 Это значение также может быть изменено в файле конфигурации. Влияние этого свойства можно переопределить, задав <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> свойство экземпляра <xref:System.Net.HttpWebRequest> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение не равно -1 и меньше нуля.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Незавершенный запрос потока.</param>
        <summary>Завершает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Метод завершает асинхронный запрос для потока, которое было начато вызовом <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метод. После <xref:System.IO.Stream> объект был возвращен, вы можете отправлять данные с помощью <xref:System.Net.HttpWebRequest> с помощью <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> метод.  
  
> [!NOTE]
>  Необходимо задать значение <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство перед записью данных в поток.  
  
> [!CAUTION]
>  Необходимо вызвать <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> метод, чтобы закрыть поток и освободить соединение для повторного использования. Не удалось закрыть поток предписывает приложению закончиться подключения.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> метод для завершения асинхронного запроса экземпляра потока.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Запрос не завершен и в наличии нет потока.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен текущим экземпляром из вызова <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод был вызван ранее с помощью параметра <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">Метод <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
При обработке этого запроса возникла ошибка.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Незавершенный запрос потока.</param>
        <param name="context">Объект <see cref="T:System.Net.TransportContext" /> для <see cref="T:System.IO.Stream" />.</param>
        <param name="transportContext">Объект <see cref="T:System.Net.TransportContext" /> для <see cref="T:System.IO.Stream" />.</param>
        <summary>Завершает асинхронный запрос объекта <see cref="T:System.IO.Stream" />, используемого для записи данных, и выводит объект <see cref="T:System.Net.TransportContext" />, связанный с потоком.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> Метод завершает асинхронный запрос для потока, которое было начато вызовом <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метод и выходные данные <xref:System.Net.TransportContext> связанный с потоком. После <xref:System.IO.Stream> объект был возвращен, вы можете отправлять данные с помощью <xref:System.Net.HttpWebRequest> с помощью <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> метод.  
  
 Некоторые приложения, использующие встроенную проверку подлинности Windows с расширенной защитой может потребоваться иметь возможность направлять запрос на транспортном уровне, используемые <xref:System.Net.HttpWebRequest> для получения токена привязки канала (CBT) из базового канала TLS. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Метод обеспечивает доступ к этой информации для методов HTTP, иметь текст запроса (`POST` и `PUT` запросов). Требуется, только если приложение реализует собственную проверку подлинности и требуется доступ к CBT.  
  
> [!NOTE]
>  Если приложению необходимо задать значение <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство, то это необходимо сделать до получения потока и запись в нее данных.  
  
> [!CAUTION]
>  Необходимо вызвать <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> метод, чтобы закрыть поток и освободить соединение для повторного использования. Не удалось закрыть поток предписывает приложению закончиться подключения.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен текущим экземпляром из вызова <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод был вызван ранее с помощью параметра <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">Запрос не завершен и в наличии нет потока.</exception>
        <exception cref="T:System.Net.WebException">Метод <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
При обработке этого запроса возникла ошибка.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Незавершенный запрос ответа.</param>
        <summary>Завершает асинхронный запрос интернет-ресурса.</summary>
        <returns>Объект <see cref="T:System.Net.WebResponse" />, содержащий ответ от интернет-ресурса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetResponse%2A> Метод завершает асинхронный запрос Интернет-ресурса, запущенную вызовом <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> метод.  
  
> [!CAUTION]
>  Необходимо вызвать <xref:System.Net.HttpWebResponse.Close%2A> метод, чтобы закрыть поток и освободить соединение. Невыполнение этого требования может привести к закончиться подключения приложения.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.HttpWebRequest.EndGetResponse%2A> для завершения асинхронный запрос Интернет-ресурса.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод был вызван ранее с помощью параметра <paramref name="asyncResult." />  
  
-или- 
Значение свойства <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше 0, но данные не были записаны в поток запроса.</exception>
        <exception cref="T:System.Net.WebException">Метод <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
При обработке этого запроса возникла ошибка.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен текущим экземпляром из вызова <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Expect" />.</summary>
        <value>Содержимое HTTP-заголовка <see langword="Expect" />. Значение по умолчанию — <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 Значение данного свойства содержится в <see cref="T:System.Net.WebHeaderCollection" />. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><see langword="Expect" /> устанавливается равным строке, содержащей "100-continue" в качестве подстроки.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="httpWebRequest.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-значение для экземпляра <see cref="T:System.Net.WebRequest" />.</summary>
        <returns>Целочисленное хэш-значение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Метод GetHashCode Возвращает хэш-код веб-запроса. Это значение может использоваться как ключ в хэш-таблицы.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> для заполнения данными.</param>
        <param name="streamingContext">Контекст <see cref="T:System.Runtime.Serialization.StreamingContext" />, определяющий целевой объект сериализации.</param>
        <summary>Заполняет <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными, требуемыми для сериализации целевого объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все объекты, включенные в <xref:System.Runtime.Serialization.SerializationInfo> автоматически отслеживаются и сериализовано модулем форматирования.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Метод возвращает поток, используемый для отправки данных <xref:System.Net.HttpWebRequest>. После <xref:System.IO.Stream> объект был возвращен, вы можете отправлять данные с помощью <xref:System.Net.HttpWebRequest> с помощью <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> метод.  
  
 Если приложению необходимо задать значение <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство, то это необходимо сделать перед возвращением в поток.  
  
 Необходимо вызвать <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> метод, чтобы закрыть поток и освободить соединение для повторного использования. Не удалось закрыть поток предписывает приложению закончиться подключения.  
  
> [!NOTE]
>  Приложение нельзя смешивать синхронные и асинхронные методы для определенного запроса. При вызове метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метода, необходимо использовать <xref:System.Net.HttpWebRequest.GetResponse%2A> метод для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метод для возврата экземпляра потока.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">Значение свойства <see cref="P:System.Net.HttpWebRequest.Method" /> — GET или HEAD.  
  
-или- 
 Значение <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> — <see langword="true" />, значение <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> — <see langword="false" />, значение <see cref="P:System.Net.HttpWebRequest.ContentLength" /> — -1, значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> — <see langword="false" /> и значение <see cref="P:System.Net.HttpWebRequest.Method" /> — POST или PUT.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> вызывается несколько раз.  
  
-или- 
 Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> устанавливается значение, а значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша, однако запросы, записывающие данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского проверяющего элемента управления кэша, который неправильно реализован.</exception>
        <exception cref="T:System.Net.WebException">Метод <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
Период простоя для запроса с истекшим сроком действия.  
  
-или- 
При обработке этого запроса возникла ошибка.</exception>
        <exception cref="T:System.ObjectDisposedException">В приложении .NET Compact Framework поток запроса с длиной содержимого, равной нулю, не был получен и закрыт допустимым образом. Дополнительные сведения об обработке запросов с нулевой длиной содержимого см. в разделе [Сетевое программирование в .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Net.TransportContext" /> для <see cref="T:System.IO.Stream" />.</param>
        <summary>Получает объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса, и выводит объект <see cref="T:System.Net.TransportContext" />, связанный с потоком.</summary>
        <returns>Объект <see cref="T:System.IO.Stream" />, используемый для записи данных запроса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Метод возвращает поток, используемый для отправки данных <xref:System.Net.HttpWebRequest> и выводит <xref:System.Net.TransportContext> связанный с потоком. После <xref:System.IO.Stream> объект был возвращен, вы можете отправлять данные с помощью <xref:System.Net.HttpWebRequest> с помощью <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> метод.  
  
 Некоторые приложения, использующие встроенную проверку подлинности Windows с расширенной защитой может потребоваться иметь возможность направлять запрос на транспортном уровне, используемые <xref:System.Net.HttpWebRequest> для получения токена привязки канала (CBT) из базового канала TLS. <xref:System.Net.HttpWebRequest.GetRequestStream%2A> Метод обеспечивает доступ к этой информации для методов HTTP, иметь текст запроса (`POST` и `PUT` запросов). Требуется, только если приложение реализует собственную проверку подлинности и требуется доступ к CBT.  
  
 Если приложению необходимо задать значение <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство, то это необходимо сделать перед возвращением в поток.  
  
 Необходимо вызвать <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> метод, чтобы закрыть поток и освободить соединение для повторного использования. Не удалось закрыть поток предписывает приложению закончиться подключения.  
  
> [!NOTE]
>  Приложение нельзя смешивать синхронные и асинхронные методы для определенного запроса. При вызове метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метода, необходимо использовать <xref:System.Net.HttpWebRequest.GetResponse%2A> метод для получения ответа.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Методу <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> не удалось получить <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> вызывается несколько раз.  
  
-или- 
 Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> устанавливается значение, а значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша, однако запросы, записывающие данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского проверяющего элемента управления кэша, который неправильно реализован.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">Значение свойства <see cref="P:System.Net.HttpWebRequest.Method" /> — GET или HEAD.  
  
-или- 
 Значение <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> — <see langword="true" />, значение <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> — <see langword="false" />, значение <see cref="P:System.Net.HttpWebRequest.ContentLength" /> — -1, значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> — <see langword="false" /> и значение <see cref="P:System.Net.HttpWebRequest.Method" /> — POST или PUT.</exception>
        <exception cref="T:System.Net.WebException">Метод <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
Период простоя для запроса с истекшим сроком действия.  
  
-или- 
При обработке этого запроса возникла ошибка.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Встроенная аутентификация Windows с расширенной защитой</related>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает ответ от интернет-ресурса.</summary>
        <returns>Объект <see cref="T:System.Net.WebResponse" />, содержащий ответ от интернет-ресурса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetResponse%2A> Возвращает метод <xref:System.Net.WebResponse> объект, содержащий ответ от Интернет-ресурса. Возвращается реальный экземпляр <xref:System.Net.HttpWebResponse>и может быть приведен к этому классу для НТТР-доступа к свойствам.  
  
 Объект <xref:System.Net.ProtocolViolationException> возникает в нескольких случаях, когда значение свойства на <xref:System.Net.HttpWebRequest> являются конфликтующими. Это исключение возникает, если приложение задает <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство и <xref:System.Net.HttpWebRequest.SendChunked%2A> свойства `true`, а затем отправляет запрос HTTP GET. Это исключение возникает, если приложение пытается отправить блочный на сервер, который поддерживает только протокол HTTP 1.0, где это не поддерживается. Это исключение возникает, если приложение пытается отправить данные без параметра <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство или <xref:System.Net.HttpWebRequest.SendChunked%2A> — `false` при отключенной буферизации и для проверки активности подключения ( <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство `true`)`.`  
  
> [!CAUTION]
>  Необходимо вызвать <xref:System.Net.HttpWebResponse.Close%2A> метод, чтобы закрыть поток и освободить соединение. Невыполнение этого требования может привести к закончиться подключения приложения.  
  
 При использовании метода POST, необходимо получить поток запроса, записать данные и закрыть поток. Этот метод блокирует ожидание публикуемого содержимого; Если не включена времени ожидания и не имеется содержимое, вызывающий поток блокируется на неопределенный срок.  
  
> [!NOTE]
>  Несколько вызовов <xref:System.Net.HttpWebRequest.GetResponse%2A> возвращен объект ответа; запрос не выполняется повторно.  
  
> [!NOTE]
>  Приложение нельзя смешивать синхронные и асинхронные методы для определенного запроса. При вызове метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метода, необходимо использовать <xref:System.Net.HttpWebRequest.GetResponse%2A> метод для получения ответа.  
  
> [!NOTE]
>  Если <xref:System.Net.WebException> является исключение, используйте <xref:System.Net.WebException.Response%2A> и <xref:System.Net.WebException.Status%2A> свойств исключения, чтобы определить ответ от сервера.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  По соображениям безопасности файлы cookie отключены по умолчанию. Если вы хотите использовать файлы cookie, используйте <xref:System.Net.HttpWebRequest.CookieContainer%2A> свойство, чтобы включить файлы cookie.  
  
   
  
## Examples  
 В следующем примере кода получает ответ на запрос.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Поток уже занят предыдущим вызовом <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  
  
-или- 
 Для <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> устанавливается значение, а значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">Значение <see cref="P:System.Net.HttpWebRequest.Method" /> — GET или HEAD, и либо <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше или равно нулю, либо <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="true" />.  
  
-или- 
 Значение <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> — <see langword="true" />, значение <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> — <see langword="false" />, значение <see cref="P:System.Net.HttpWebRequest.ContentLength" /> — -1, значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> — <see langword="false" /> и значение <see cref="P:System.Net.HttpWebRequest.Method" /> — POST или PUT.  
  
-или- 
<see cref="T:System.Net.HttpWebRequest" /> имеет тело сущности, но метод <see cref="M:System.Net.HttpWebRequest.GetResponse" /> вызывается без вызова метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.  
  
-или- 
Значение свойства <see cref="P:System.Net.HttpWebRequest.ContentLength" /> больше нуля, однако приложение не записывает все обещанные данные.</exception>
        <exception cref="T:System.NotSupportedException">Проверяющий элемент управления кэша запросов указывает, что ответ на этот запрос может быть предоставлен из кэша, однако этот запрос включает данные, которые должны быть отправлены на сервер. Запросы, отправляющие данные, не должны использовать кэш. Это исключение может возникнуть при использовании пользовательского проверяющего элемента управления кэша, который неправильно реализован.</exception>
        <exception cref="T:System.Net.WebException">Метод <see cref="M:System.Net.HttpWebRequest.Abort" /> был вызван ранее.  
  
-или- 
Период простоя для запроса с истекшим сроком действия.  
  
-или- 
При обработке этого запроса возникла ошибка.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, был ли получен ответ от интернет-ресурса.</summary>
        <value>Значение <see langword="true" />, если ответ получен, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода в примере выполняется проверка <xref:System.Net.HttpWebRequest.HaveResponse%2A> свойства, чтобы определить, если ответ получен из Интернет-ресурса.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает коллекцию пар "имя-значение", из которых создаются заголовки HTTP.</summary>
        <value>Коллекция <see cref="T:System.Net.WebHeaderCollection" />, содержащая пары "имя-значение", из которых состоят заголовки HTTP-запроса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A> Коллекция содержит заголовки протокола, связанного с запросом. В следующей таблице перечислены заголовки HTTP, которые не хранятся в <xref:System.Net.HttpWebRequest.Headers%2A> коллекции, но они задается системой или заданные свойства и методы.  
  
|Header|Задается|  
|------------|------------|  
|Принять|Задается <xref:System.Net.HttpWebRequest.Accept%2A> свойство.|  
|Подключение|Задается <xref:System.Net.HttpWebRequest.Connection%2A> свойство и <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство.|  
|Content-Length|Задается <xref:System.Net.HttpWebRequest.ContentLength%2A> свойство.|  
|Content-Type|Задается <xref:System.Net.HttpWebRequest.ContentType%2A> свойство.|  
|Ожидать|Задается <xref:System.Net.HttpWebRequest.Expect%2A> свойство.|  
|Дата|Задается <xref:System.Net.HttpWebRequest.Date%2A> свойство.|  
|Узел|Задается <xref:System.Net.HttpWebRequest.Host%2A> свойство.|  
|If-Modified-Since|Задается <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство.|  
|Диапазон|Задается <xref:System.Net.HttpWebRequest.AddRange%2A> метод.|  
|Источник ссылки|Задается <xref:System.Net.HttpWebRequest.Referer%2A> свойство.|  
|Transfer-Encoding|Задается <xref:System.Net.HttpWebRequest.TransferEncoding%2A> свойство ( <xref:System.Net.HttpWebRequest.SendChunked%2A> свойство должно иметь значение true).|  
|Агент пользователя|Задается <xref:System.Net.HttpWebRequest.UserAgent%2A> свойство.|  
  
 <xref:System.Net.WebHeaderCollection.Add%2A> Вызывает метод <xref:System.ArgumentException> при попытке задать один из этих защищенных заголовков.  
  
 Изменение <xref:System.Net.HttpWebRequest.Headers%2A> свойство после запуска запроса путем вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает метод <xref:System.InvalidOperationException>.  
  
 Не следует предполагать, что значения заголовка не изменится, так как веб-серверов и кэши могут изменить или добавить заголовки на веб-запрос.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.HttpWebRequest.Headers%2A> свойства пары имя/значение заголовка HTTP в консоль.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос запущен с помощью метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение заголовка Host для использования в HTTP-запросе независимо от URI запроса.</summary>
        <value>Значение заголовка Host в HTTP-запросе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A> Свойства можно установить значение заголовка для использования в запросе HTTP, независимо от URI запроса для узлов. <xref:System.Net.HttpWebRequest.Host%2A> Свойство может состоять из имени узла и номер дополнительного порта. Заголовок узла без сведения о порте подразумевает порт по умолчанию для запроса службы (порт 80 для URL-адрес HTTP, например).  
  
 Формат для указания узла и порта должны соответствовать правилам в разделе 14.23 RFC2616, опубликованном IETF. Примером соблюдение этих требований, указывающее порт 8080, может служить следующее значение для <xref:System.Net.HttpWebRequest.Host%2A> свойства:  
  
 `www.contoso.com:8080`  
  
 С помощью <xref:System.Net.HttpWebRequest.Host%2A> свойство, чтобы явно указать пользовательское значение заголовка узла также влияет на области кэширования, файлы cookie и проверку подлинности. Если приложение предоставляет учетные данные для определенного префикса URI, приложениям необходимо обязательно используйте URI, содержащие значение заголовка узла, а не на целевой сервер в URI. Ключ, используемый при кэшировании ресурсов, используется значение заголовка узла, а не в URI запроса. Файлы Cookie хранятся в <xref:System.Net.CookieContainer> и логически сгруппированные по имени домена сервера. Если приложение указывает заголовок узла, это значение будет использоваться как домен.  
  
 Если <xref:System.Net.HttpWebRequest.Host%2A> свойство не задано, то значение заголовка узла для использования в HTTP-запрос основан на URI запроса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заголовку узла не может быть присвоено значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Заголовку узла не может быть присвоено недопустимое значение.</exception>
        <exception cref="T:System.InvalidOperationException">Заголовок узла нельзя задать после запуска <see cref="T:System.Net.HttpWebRequest" /> для отправки.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="If-Modified-Since" />.</summary>
        <value>Объект <see cref="T:System.DateTime" />, в котором размещено содержимое HTTP-заголовка <see langword="If-Modified-Since" />. Значением по умолчанию являются текущие дата и время.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> Свойство — это стандарт <xref:System.DateTime?displayProperty=nameWithType> объекта и может содержать <xref:System.DateTimeKind?displayProperty=nameWithType> поле <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, или <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Любые виды времени можно задать при использовании <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство. Если <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> при задании или получении, <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство предполагается, что <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (местное время).  
  
 Классы в <xref:System.Net> пространства имен всегда записывают его <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство по сети во время передачи в стандартную форму, используя формат по Гринвичу (Utc).  
  
 Если <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойству <xref:System.DateTime.MinValue?displayProperty=nameWithType>, а затем `If-Modified-Since` HTTP-заголовок удаляется из <xref:System.Net.HttpWebRequest.Headers%2A> свойство и <xref:System.Net.WebHeaderCollection>.  
  
 Если <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство <xref:System.DateTime.MinValue?displayProperty=nameWithType>, это означает, что `If-Modified-Since` HTTP-заголовок не включается в <xref:System.Net.HttpWebRequest.Headers%2A> свойство и <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода в примере выполняется проверка <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, необходимо ли устанавливать постоянное подключение к интернет-ресурсу.</summary>
        <value>Значение <see langword="true" />, если запрос к интернет-ресурсу должен содержать HTTP-заголовок <see langword="Connection" /> со значением Keep-alive; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `true` для отправки `Connection` заголовок HTTP со значением Keep-alive. Приложение использует <xref:System.Net.HttpWebRequest.KeepAlive%2A> чтобы указать, что предпочтительны постоянные подключения. Когда <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство `true`, приложение создает постоянные подключения к серверам, которые их поддерживают.  
  
> [!NOTE]
>  При использовании HTTP/1.1, Keep-Alive включен по умолчанию. Установка <xref:System.Net.HttpWebRequest.KeepAlive%2A> для `false` может привести к отправке `Connection: Close` заголовка на сервер.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойства `false` во избежание создания постоянного подключения с Интернет-ресурса.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальное количество переадресаций, выполняемых запросом.</summary>
        <value>Максимальное количество ответов переадресации, указаниям которых следует запрос. Значение по умолчанию — 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> Свойство задает максимальное количество переадресаций, выполняемых запросом, если <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> свойство `true`.  
  
   
  
## Examples  
 В следующем примере кода задает значение этого свойства.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Устанавливается значение равное 0 или меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает максимальную допустимую длину заголовков ответов.</summary>
        <value>Длина заголовков ответов, выраженная в килобайтах (1024 байта).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Длина заголовка ответа включает строку состояния ответа, а также все дополнительные управляющие символы, получаемые в протоколе HTTP. Значение-1 означает отсутствие ограничений на заголовки ответа; значение 0 означает, что все запросы завершаются сбоем.  
  
 Если <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> свойство не задано явно, по умолчанию используется значение <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> свойства.  
  
 Если длина заголовка ответа получено превышает значение <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> свойство, <xref:System.Net.HttpWebRequest.EndGetResponse%2A> или <xref:System.Net.HttpWebRequest.GetResponse%2A> методы создадут исключение <xref:System.Net.WebException> с <xref:System.Net.WebException.Status%2A> свойство значение <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 В следующем примере кода задает значение этого свойства.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство устанавливается после передачи запроса.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение меньше 0 и не равно -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает формат носителя запроса.</summary>
        <value>Формат носителя запроса. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение <xref:System.Net.HttpWebRequest.MediaType%2A> свойство влияет на <xref:System.Net.HttpWebResponse.CharacterSet%2A> свойство. При задании <xref:System.Net.HttpWebRequest.MediaType%2A> в запросе, соответствующий тип мультимедиа выбирается из списка наборов символов, возвращаемых в ответе `Content-type` заголовок HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метод для запроса.</summary>
        <value>Метод запроса, используемый для связи с интернет-ресурсом. Значение по умолчанию - GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A> Может быть установлено в любой из команд протокола HTTP 1.1: GET, HEAD, POST, PUT, удалить "," ТРАССИРОВКА "или" Параметры.  
  
 Если <xref:System.Net.HttpWebRequest.ContentLength%2A> свойству присваивается значение, отличное от -1, <xref:System.Net.HttpWebRequest.Method%2A> свойство должно иметь значение свойству протокола, используемого для загрузки данных.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.Method%2A> значение POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Метод не предоставляется.  
  
-или- 
Строка метода содержит недопустимые знаки.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, выполняется ли конвейерная передача запроса в интернет-ресурс.</summary>
        <value>Значение <see langword="true" />, если должна выполняться конвейерная передача запроса, в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение использует <xref:System.Net.HttpWebRequest.Pipelined%2A> свойство, указывающее предпочтение Конвейерные подключения. Когда <xref:System.Net.HttpWebRequest.Pipelined%2A> является `true`, когда приложение устанавливает Конвейерные подключения к серверам, которые их поддерживают.  
  
 Конвейерные подключения выполняются только тогда, когда <xref:System.Net.HttpWebRequest.KeepAlive%2A> свойство является также `true`.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Net.HttpWebRequest.Pipelined%2A> свойства на консоль.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли отправлять заголовок авторизации вместе с запросом.</summary>
        <value>Значение <see langword="true" />, если с запросом требуется отправить заголовок авторизации HTTP после выполнения аутентификации; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После запроса на клиент с конкретными <xref:System.Uri> успешной проверки подлинности, если <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> — `true` и учетные данные указаны, заголовок авторизации отправляется с каждым запросом к любому <xref:System.Uri> , соответствующий конкретный <xref:System.Uri>вплоть до последнего косую черту. Таким образом, если запрос клиента успешно прошел проверку подлинности для конкретного <xref:System.Uri> , содержащий указанные ниже:  
  
 `http://www.contoso.com/firstpath/`  
  
 Затем в заголовок авторизации для предварительной проверки подлинности отправляется с каждым запросом к любому из следующих <xref:System.Uri> экземпляров:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Однако заголовок авторизации не отправляется вместе с запросами к любому из следующих <xref:System.Uri> экземпляров:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Если запрос клиента к определенному <xref:System.Uri> является не успешной проверки подлинности, запрос использует стандартные процедуры проверки подлинности.  
  
 За исключением первого запроса <xref:System.Net.WebRequest.PreAuthenticate%2A> свойство указывает, следует ли отправлять сведения о проверке подлинности с последующими запросами к <xref:System.Uri> , соответствующий конкретный <xref:System.Uri> вплоть до последнего косую черту без ожидания, быть Перейти к прохождению сервером.  
  
 Следующее диалоговое окно между клиентом и сервером показан результат этого свойства. Диалоговое окно предполагается, что является обычной проверки подлинности используется.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> — `false`:  
  
 Клиент: ПОЛУЧИТЬ someUrl  
  
 Сервер: 401 WWW-Authenticate Basic  
  
 Клиент: Получение с заголовками авторизации  
  
 Сервер: 200, ОК  
  
 Клиент: ПОЛУЧИТЬ someUrl  
  
 Сервер: 401 WWW-Authenticate Basic  
  
 Клиент: Получение с заголовками авторизации  
  
 Сервер: 200, ОК  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> — `true`:  
  
 Клиент: ПОЛУЧИТЬ someUrl  
  
 Сервер: 401 WWW-Authenticate Basic  
  
 Клиент: Получение с заголовками авторизации  
  
 Сервер: 200, ОК  
  
 Клиент: ПОЛУЧИТЬ someUrl с заголовками авторизации  
  
 Если схема проверки подлинности не поддерживает предварительную проверку подлинности, значение этого свойства игнорируется.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает версию HTTP-протокола, используемую для запроса.</summary>
        <value>Версия HTTP-протокола, используемая для запроса. Значение по умолчанию — <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest> Класс поддерживает только версии 1.0 и 1.1 HTTP. Параметр <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> до другой версии возникло исключение.  
  
> [!NOTE]
>  Чтобы установить версию HTTP текущего запроса, используйте <xref:System.Net.HttpVersion.Version10> и <xref:System.Net.HttpVersion.Version11> поля <xref:System.Net.HttpVersion> класса.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Заданная версия HTTP-протокола отлична от 1.0 и 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о прокси-сервере для запроса.</summary>
        <value>Объект <see cref="T:System.Net.IWebProxy" />, используемый в качестве прокси-сервера для этого запроса. Значение по умолчанию устанавливается путем вызова свойства <see cref="P:System.Net.GlobalProxySelection.Select" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Proxy%2A> Свойство идентифицирует <xref:System.Net.WebProxy> объект, используемый для обработки запросов к ресурсам в Интернете. Чтобы указать, что следует использовать прокси-сервера, задайте <xref:System.Net.HttpWebRequest.Proxy%2A> свойства к экземпляру прокси-сервера, возвращенный <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> метод.  
  
 Локальный компьютер или файл конфигурации приложения могут использовать прокси-сервер по умолчанию. Если <xref:System.Net.HttpWebRequest.Proxy%2A> свойство указано, затем параметры прокси-сервера из <xref:System.Net.HttpWebRequest.Proxy%2A> переопределения свойств локального компьютера или файл конфигурации приложения и <xref:System.Net.HttpWebRequest> экземпляр будет использовать параметры прокси-сервера, который указан. Если прокси-сервера не указан в файле конфигурации и <xref:System.Net.HttpWebRequest.Proxy%2A> свойство не задано, <xref:System.Net.HttpWebRequest> класс использует параметры прокси-сервера, унаследованные от Internet Explorer на локальном компьютере. Если отсутствуют параметры прокси-сервера в Internet Explorer, запрос отправляется непосредственно на сервер.  
  
 <xref:System.Net.HttpWebRequest> Класс анализирует список обхода прокси-сервера с использованием подстановочных знаков наследуется от Internet Explorer так же как в списке пропускаемых адресов анализируется непосредственно с Internet Explorer. Например <xref:System.Net.HttpWebRequest> класс будет выполнять синтаксический анализ списка обход проверки «nt *» из Internet Explorer регулярные выражения «nt.\*«. Поэтому URL-адрес "`http://nt.com`" будут обходить прокси с помощью <xref:System.Net.HttpWebRequest> класс и с помощью Internet Explorer.  
  
 <xref:System.Net.HttpWebRequest> Класс поддерживает обход локальный прокси-сервер. Класс считает назначения локальным, если выполняется одно из следующих условий:  
  
-   В пути имеются плоским именем (без точки в URL-адрес).  
  
-   В пути имеются петлевой адрес (<xref:System.Net.IPAddress.Loopback> или <xref:System.Net.IPAddress.IPv6Loopback>) или в пути имеются <xref:System.Net.IPAddress> на локальный компьютер.  
  
-   Суффикс домена назначения совпадает с суффиксом домена локального компьютера (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Изменение <xref:System.Net.HttpWebRequest.Proxy%2A> свойство после запуска запроса путем вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает метод <xref:System.InvalidOperationException>. Сведения об элементе прокси-сервера см. в разделе [ \&lt; defaultProxy\&gt; (Сетевые параметры)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.HttpWebRequest.Proxy%2A> метод, чтобы получить информацию о прокси для запроса.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметру <see cref="P:System.Net.HttpWebRequest.Proxy" /> задается значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Запрос начат посредством вызова метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект не имеет разрешения на запрошенную операцию.</exception>
        <permission cref="T:System.Net.WebPermission">Для получения или задания <see cref="P:System.Net.HttpWebRequest.Proxy" /> свойство. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/9d663c4b-07b4-4f6f-9b12-efbd3630354f">Элемент DefaultProxy (параметры сети)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/bb707c72-eed2-4a82-8800-c9e68df2fd4f">Настройка веб-приложений</related>
        <related type="Article" href="https://msdn.microsoft.com/library/353c0a8b-4cee-44f6-8e65-60e286743df9">Настройка прокси-сервера</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fcd9c3bd-93de-4c92-8ff3-837327ad18de">Автоматическое обнаружение прокси-сервера</related>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает время ожидания в миллисекундах при записи в поток или при чтении из него.</summary>
        <value>Количество миллисекунд до истечения срока действия записи или чтения. По умолчанию установлено значение 300 000 миллисекунд (5 минут).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> Свойство используется при записи в поток, возвращенный <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метода или чтение из потока, возвращаемый <xref:System.Net.HttpWebResponse.GetResponseStream%2A> метод.  
  
 В частности <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> свойство определяет время ожидания для <xref:System.IO.Stream.Read%2A> метод, который используется для чтения поток, возвращенный <xref:System.Net.HttpWebResponse.GetResponseStream%2A> метода, а также для <xref:System.IO.Stream.Write%2A> метод, который используется для записи в поток, возвращенный <xref:System.Net.HttpWebRequest.GetRequestStream%2A>метод.  
  
 Чтобы указать время ожидания завершения запроса, используйте <xref:System.Net.HttpWebRequest.Timeout%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано задание свойства <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос уже был отправлен.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанное значение для операции присвоения меньше или равно нулю и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Referer" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Referer" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> свойство `true`, <xref:System.Net.HttpWebRequest.Referer%2A> свойство задается автоматически, когда запрос перенаправляется на другой сайт.  
  
 Чтобы очистить `Referer` задать заголовок HTTP, <xref:System.Net.HttpWebRequest.Referer%2A> свойства `null`.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.Referer%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает исходный URI этого запроса.</summary>
        <value>Объект <see cref="T:System.Uri" />, который содержит код URI интернет-ресурса, переданный в метод <see cref="M:System.Net.WebRequest.Create(System.String)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri> Объект, передаваемый в <xref:System.Net.HttpWebRequest> вызовом <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Переадресации не изменяет заголовок <xref:System.Net.HttpWebRequest.RequestUri%2A> свойство. Для получения фактического URI, который ответил на запрос, проверьте <xref:System.Net.HttpWebRequest.Address%2A> свойство.  
  
   
  
## Examples  
 В следующем коде примере выполняется проверка на предмет <xref:System.Net.HttpWebRequest> объект `req` была перенаправлена в другое расположение для выполнения запроса и задает значение `hasChanged` переменной `true` Если запрос был перенаправляются; в противном случае — значение `hasChanged` присваивается `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, которое указывает, будут ли отправляться данные в интернет-ресурс сегментами.</summary>
        <value>Значение <see langword="true" />, если требуется посылать данные в интернет-ресурс сегментами; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Net.HttpWebRequest.SendChunked%2A> является `true`, запрос отправляет данные в Интернет-ресурс сегментами. Интернет-ресурсу должен поддерживать получение данных по частям.  
  
 Изменение <xref:System.Net.HttpWebRequest.SendChunked%2A> свойство после запуска запроса путем вызова <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, или <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> вызывает метод <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.SendChunked%2A> свойства `true` таким образом, чтобы данные можно отправить в сегментах к Интернет-ресурсу.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Запрос запущен с помощью метода <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> или <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает функцию обратного вызова для проверки сертификата сервера.</summary>
        <value>Функция обратного вызова для проверки сертификата сервера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию используется, что функция обратного вызова не задан и <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> свойство `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает точка обслуживания, используемую для запроса.</summary>
        <value>Значение <see cref="T:System.Net.ServicePoint" />, представляющее сетевое подключение к интернет-ресурсу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> Свойство может отличаться от <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> Если перенаправляется запрос.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое указывает, поддерживает ли запрос <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>Значение <see langword="true" />, если запрос поддерживает <see cref="T:System.Net.CookieContainer" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> для заполнения данными.</param>
        <param name="streamingContext">Контекст <see cref="T:System.Runtime.Serialization.StreamingContext" />, определяющий целевой объект сериализации.</param>
        <summary>Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными, необходимыми для сериализации целевого объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все объекты, включенные в <xref:System.Runtime.Serialization.SerializationInfo> автоматически отслеживаются и сериализовано модулем форматирования.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение ожидания в миллисекундах для методов <see cref="M:System.Net.HttpWebRequest.GetResponse" /> и <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.</summary>
        <value>Количество миллисекунд, ожидаемых до остановки запроса. По умолчанию установлено значение 100 000 миллисекунд (100 секунд).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> число миллисекунд, последующие синхронный запрос, созданный с помощью <xref:System.Net.HttpWebRequest.GetResponse%2A> метод ожидает ответа и <xref:System.Net.HttpWebRequest.GetRequestStream%2A> метод ожидает поток. <xref:System.Net.HttpWebRequest.Timeout%2A> Применяется для всего запроса и ответа, не по отдельности к <xref:System.Net.HttpWebRequest.GetRequestStream%2A> и <xref:System.Net.HttpWebRequest.GetResponse%2A> вызовы методов. Если ресурс не возвращается до истечения времени ожидания, запрос создает исключение <xref:System.Net.WebException> с <xref:System.Net.WebException.Status%2A> свойство значение <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> Свойство должно быть установлено перед <xref:System.Net.HttpWebRequest.GetRequestStream%2A> или <xref:System.Net.HttpWebRequest.GetResponse%2A> вызывается метод. Изменение <xref:System.Net.HttpWebRequest.Timeout%2A> свойство после вызова метода <xref:System.Net.HttpWebRequest.GetRequestStream%2A> или <xref:System.Net.HttpWebRequest.GetResponse%2A> метод не оказывает влияния  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A> Свойство не влияет на асинхронные запросы, созданные с помощью <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> или <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> метод.  
  
> [!CAUTION]
>  В случае асинхронных запросов клиентское приложение реализует собственный механизм времени ожидания. См. пример в <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> метод.  
  
 Чтобы указать время ожидания чтения или записи операции время ожидания, используйте <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> свойство.  
  
 Запрос доменных имен (DNS) может занять до 15 секунд для возврата или истечения времени ожидания. Если запрос содержит имя узла, которое требуется разрешение, а <xref:System.Net.FileWebRequest.Timeout%2A> значение не более 15 секунд может занять 15 секунд или больше, прежде чем <xref:System.Net.WebException> указывающее время ожидания запроса.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.Timeout%2A> свойство <xref:System.Net.HttpWebRequest> объекта.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Указанное значение меньше нуля и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="Transfer-encoding" />.</summary>
        <value>Значение HTTP-заголовка <see langword="Transfer-encoding" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед установкой <xref:System.Net.HttpWebRequest.TransferEncoding%2A> свойства, необходимо сначала установить <xref:System.Net.HttpWebRequest.SendChunked%2A> свойства `true`. Очистка <xref:System.Net.HttpWebRequest.TransferEncoding%2A> при установке для него `null` не влияет на значение <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Значения, присвоенные <xref:System.Net.HttpWebRequest.TransferEncoding%2A> свойство замените все существующее содержимое.  
  
> [!NOTE]
>  Значение данного свойства содержится в <xref:System.Net.WebHeaderCollection>. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> устанавливается, когда значение <see cref="P:System.Net.HttpWebRequest.SendChunked" /> равно <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> устанавливается равным значению "Chunked".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли разрешено совместное использование высокоскоростного подключения с проверкой подлинности NTLM.</summary>
        <value>Значение <see langword="true" />, если необходимо сохранить открытым подключение, прошедшее проверку подлинности, в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение по умолчанию для этого свойства — `false`, который вызывает текущее подключение закрывается после завершения запроса. Приложение должно пройти через последовательность команд проверки подлинности, каждый раз, оно отправляет новый запрос.  
  
 Если это свойство имеет значение `true`, соединение, используемое для извлечения ответа остается открытым после выполнения проверки подлинности. В этом случае другие запросы, у этого свойства задано `true` может использовать подключение без повторения процедуры проверки подлинности. Другими словами, если соединение прошел проверку подлинности для пользователя A, пользователь Б может повторно подключения; запрос пользователем Б выполняется на основе учетных данных пользователя а.  
  
> [!CAUTION]
>  Так как это приложение может использовать подключение без прохождения проверки подлинности, вам нужно убедитесь, что это не административные уязвимости в системе при задании этого свойства `true`. Если ваше приложение отправляет запросы для нескольких пользователей (олицетворяет несколько учетных записей пользователей) и полагается на проверку подлинности для защиты ресурсов, не устанавливайте это свойство `true` только при использовании групп соединений, как описано ниже.  
  
 Вы можете включить этот механизм, если ваш возникают проблемы производительности и приложение выполняется на веб-сервере со встроенной проверкой подлинности Windows.  
  
 При включении этого параметра делает систему угрозы безопасности. Если задать <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> свойства `true` убедитесь, что вы приняли следующие меры предосторожности:  
  
-   Используйте <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> свойство для управления подключениями для разных пользователей. Это исключает возможность использования подключения приложениями без проверки подлинности. Например пользователь А должен иметь имя группы уникального соединения, отличающейся от пользователя б. Это обеспечивает уровень изоляции для каждой учетной записи пользователя.  
  
-   Запустите приложение в защищенной среде, чтобы избежать несанкционированного использования подключения.  
  
 Если вы управляете тыловых серверов, в качестве альтернативы может потребоваться отключить сохраняемость проверки подлинности. Благодаря этому увеличивается производительность в меньшей степени, но безопаснее. Дополнительные сведения см. AuthPersistence в библиотеке MSDN по адресу [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Если оба <xref:System.Net.WebRequest.PreAuthenticate%2A> и <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> присваивается `true`, каждый запрос отправляется с помощью подключения из пула unsafe, но с заголовок авторизации.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Неограниченный веб-полномочие требуется задать это свойство.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение <see cref="T:System.Boolean" />, которое управляет отправкой учетных данных по умолчанию вместе с запросами.</summary>
        <value>Значение равно <see langword="true" />, если используются учетные данные по умолчанию, в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `true` когда запросы, создаваемые этим <xref:System.Net.HttpWebRequest> объекта должны по запросу сервера проходить проверку подлинности с использованием учетных данных пользователя, выполнившего вход. Для клиентских приложений это приемлемо в большинстве сценариев. Для приложений среднего уровня, таких как ASP.NET, вместо того чтобы использовать это свойство обычно устанавливается <xref:System.Net.HttpWebRequest.Credentials%2A> свойства учетные данные клиента, от лица которого выполняется запрос.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Произведена попытка установки этого свойства после отправки запроса.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение HTTP-заголовка <see langword="User-agent" />.</summary>
        <value>Значение HTTP-заголовка <see langword="User-agent" />. Значение по умолчанию — <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 Значение данного свойства содержится в <see cref="T:System.Net.WebHeaderCollection" />. Если задана коллекция WebHeaderCollection, значение свойства утрачивается.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода <xref:System.Net.HttpWebRequest.UserAgent%2A> свойство.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>