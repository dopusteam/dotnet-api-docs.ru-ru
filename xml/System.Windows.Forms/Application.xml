<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="28c0e715149bda84de593d0811549daf5e8f8dbe" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58456039" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет методы и свойства <see langword="static" /> для управления приложением, например методы для запуска и остановки приложения, для обработки сообщений Windows и свойства для получения сведений о приложении. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application> Класс содержит методы для запуска и остановки приложений и потоков, а также для обработки сообщений Windows следующим образом:  
  
-   <xref:System.Windows.Forms.Application.Run%2A> запускает цикл обработки сообщений приложения в текущем потоке и при необходимости делает форму видимой.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> или <xref:System.Windows.Forms.Application.ExitThread%2A> останавливает цикл обработки сообщений.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> обрабатывает сообщения, когда программа находится в цикле.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Добавляет фильтр сообщений в конвейер сообщений приложения для мониторинга сообщений Windows.  
  
-   <xref:System.Windows.Forms.IMessageFilter> позволяет остановить возникновения события или выполнить специальные операции до вызова обработчика событий.  
  
 Этот класс имеет <xref:System.Windows.Forms.Application.CurrentCulture%2A> и <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> свойства требуется получить или задать сведения для текущего потока, язык и региональные параметры.  
  
 Не удается создать экземпляр этого класса.  
  
   
  
## Examples  
 В следующем примере кода список номеров в поле со списком в форме. Каждый раз при щелчке `button1`, приложение добавляет в список другой номер.  
  
 `Main` Вызовы методов <xref:System.Windows.Forms.Application.Run%2A> для запуска приложения, который создает форму, `listBox1` и `button1`. Когда пользователь щелкает `button1`, `button1_Click` отображает метод <xref:System.Windows.Forms.MessageBox>. Если пользователь нажимает кнопку `No` на <xref:System.Windows.Forms.MessageBox>, `button1_Click` метод добавляет номер в список. Если пользователь нажимает кнопку `Yes`, приложение вызывает <xref:System.Windows.Forms.Application.Exit%2A> для обработки всех оставшихся сообщений в очереди и затем осуществить выход.  
  
> [!NOTE]
>  Вызов <xref:System.Windows.Forms.Application.Exit%2A> завершится ошибкой в режиме частичного доверия.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Реализация интерфейса <see cref="T:System.Windows.Forms.IMessageFilter" />, который планируется установить.</param>
        <summary>Добавляет фильтр сообщений для мониторинга сообщений Windows при их маршрутизации к местам назначения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте фильтр сообщений, чтобы предотвратить возникновение определенного события или для выполнения специальных операций для события, прежде чем передается в обработчик событий. Фильтры сообщений являются уникальными для конкретного потока.  
  
 Чтобы предотвратить отправку, сообщение `value` экземпляр параметра, который передается в этот метод необходимо переопределить <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> метод с кодом для обработки сообщения. Метод должен вернуть `false`.  
  
> [!CAUTION]
>  Добавление фильтров сообщений в конвейер сообщений для приложения может привести к снижению производительности.  
  
   
  
## Examples  
 В следующем примере кода создается фильтр сообщений называется `TestMessageFilter`. Этот фильтр блокирует все сообщения, относящиеся к левой кнопки мыши. Прежде чем можно будет использовать фильтр сообщений, необходимо обеспечить реализацию для <xref:System.Windows.Forms.IMessageFilter> интерфейс.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего на вызов неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее, может ли вызывающий объект выйти из этого приложения.</summary>
        <value>Значение <see langword="true" />, если вызывающий объект может выйти из этого приложения, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает `false` при вызове из <xref:System.Windows.Forms.Control> , размещенного в окне браузера. Таким образом <xref:System.Windows.Forms.Control> не может выйти из программы <xref:System.Windows.Forms.Application>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при закрытии приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо присоединить обработчики событий к `ApplicationExit` событий для выполнения необработанных необходимых задач перед закрытием приложения. Вы можете закрыть файлы, открытые с данным приложением, или удалить объекты, не восстановленные при сборке мусора.  
  
 Так как это статическое событие, необходимо отсоединить все обработчики событий, присоединен с этому событию в `ApplicationExit` сам обработчик событий. Если эти обработчики не будут отсоединены, они остаются присоединенными и продолжать использовать память.  
  
   
  
## Examples  
 В следующем примере кода показаны две формы и выход из приложения, при закрытии обе формы. Когда приложение запустится и завершает работу, позиция каждой формы запоминается. В этом примере показано использование `ApplicationExit` событие, чтобы знать, когда позиции формы следует сохранить в файл, а `FileStream` должен быть закрыт.  
  
 Класс `MyApplicationContext` наследует от <xref:System.Windows.Forms.ApplicationContext> и отслеживает при закрытии каждой формы и выходит из текущего потока, если они оба. Этот класс запоминает положение каждой формы, при его закрытии. Когда `ApplicationExit` происходит событие, класс записывает позиции каждого пользователя в файл. Данные позиции формы сохраняются в файле под названием `appdata.txt` , созданный в месте <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Вызовы методов `Application.Run(context)` для запуска приложения, получившего <xref:System.Windows.Forms.ApplicationContext>.  
  
 Этот код является выдержкой из примера, приведенного в <xref:System.Windows.Forms.ApplicationContext> Общие сведения о классе. См. в разделе <xref:System.Windows.Forms.ApplicationContext> для кода.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает путь для данных приложения, являющихся общими для всех пользователей.</summary>
        <value>Путь для данных приложения, являющихся общими для всех пользователей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если путь не существует, он создается в следующем формате:  
  
 *Базовый путь*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> Первый выглядит, чтобы определить наличие сборки, содержащей основного исполняемого файла `AssemblyInformationalVersion` атрибут на нем. Если этот атрибут существует, он используется для обоих <xref:System.Windows.Forms.Application.ProductVersion%2A> и <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Если этот атрибут не существует, оба свойства используйте версию исполняемого файла.  
  
 Путь будет отличаться в зависимости от того, является ли приложение Windows Forms развертывается с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения хранятся в кэше приложений пользователя в C:\Documents and Settings\\*username* каталога. Дополнительные сведения см. в разделе [доступ к локальным и удаленным данным в приложениях ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает раздел реестра для данных приложения, являющихся общими для всех пользователей.</summary>
        <value>Объект <see cref="T:Microsoft.Win32.RegistryKey" />, представляющий раздел реестра данных приложения, являющихся общими для всех пользователей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ не существует, он создается в следующем формате:  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает название компании, сопоставленное с приложением.</summary>
        <value>Название компании.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода получается свойство и его значение отображается в текстовом поле. В этом примере требуется `textBox1` разместил на форме.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает данные о языке и региональных параметрах для текущего потока.</summary>
        <value>Объект <see cref="T:System.Globalization.CultureInfo" /> предоставляет данные о языке и региональных параметрах для текущего потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода получается свойство и его значение отображается в текстовом поле. В этом примере требуется `textBox1` разместил на форме.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон задать это свойство. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текущий язык ввода для текущего потока.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.InputLanguage" />, представляющий текущий язык ввода для текущего потока.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода получается свойство и его значение отображается в текстовом поле. В этом примере требуется `textBox1` разместил на форме.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего на вызов неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обрабатывает все сообщения Windows, которые в данный момент находятся в очереди сообщений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При запуске Windows Form, он создает новую форму, которая затем ожидает события для обработки. Каждый раз, в форме обрабатывает событие, он обрабатывает весь код, связанный с событием. Все остальные события ожидать в очереди. Пока код обрабатывает событие, приложение не отвечает. Например окно не перерисовать, если другое окно перетаскивается в верхней части.  
  
 При вызове метода <xref:System.Windows.Forms.Application.DoEvents%2A> в коде, приложение может обрабатывать другие события. Например, если у вас есть форму, которая добавляет данные к <xref:System.Windows.Forms.ListBox> и добавьте <xref:System.Windows.Forms.Application.DoEvents%2A> в код формы перерисовывается при перетаскивании над ней еще одно окно. При удалении <xref:System.Windows.Forms.Application.DoEvents%2A> из кода, форма не будет перерисовываться, пока не будет завершено обработчик события нажатия кнопки выполнения. Дополнительные сведения о сообщениях см. в разделе [ввод данных пользователем в Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 В отличие от Visual Basic 6.0 <xref:System.Windows.Forms.Application.DoEvents%2A> не вызывает метод <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод.  
  
 Как правило этот метод используется в цикле обработки сообщений.  
  
> [!CAUTION]
>  Вызов этого метода приводит текущий поток будет приостановлено во время обработки всех сообщений окна ожидания. Если сообщение вызывает событие, чтобы активировать, может выполнить других частях кода приложения. Это может вызвать приложение может представлять непредсказуемого поведения, которые трудно отлаживать. При выполнении операций или вычисления, которые слишком долго, часто бывает предпочтительнее, чем выполнять эти операции в новом потоке. Дополнительные сведения об асинхронном программировании см. в разделе [модели асинхронного программирования (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Windows.Forms.Application.DoEvents%2A> метод. Если в этом примере запускается, пользователь может выбрать графических файлов из <xref:System.Windows.Forms.OpenFileDialog>. Выбранные файлы отображаются в форме. <xref:System.Windows.Forms.Application.DoEvents%2A> Метод принудительно перекрашивает формы для каждого открытого файла графики. Чтобы выполнить этот пример, вставьте следующий код в форму, содержащую <xref:System.Windows.Forms.PictureBox> с именем `PictureBox1`, <xref:System.Windows.Forms.OpenFileDialog> с именем `OpenFileDialog1`и кнопку с именем `fileButton`. Вызовите `InitializePictureBox` и `InitializeOpenFileDialog` методы из конструктора формы или `Load` метод.  
  
> [!NOTE]
>  В Visual Studio, если вы добавите <xref:System.Windows.Forms.OpenFileDialog> в вашу форму с помощью операции перетаскивания, необходимо изменить следующие `InitializeOpenFileDialog` метод, удалив строку, которая создает новый экземпляр класса <xref:System.Windows.Forms.OpenFileDialog>.  
  
 В этом примере также требуется <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> событие <xref:System.Windows.Forms.Button> управления и <xref:System.Windows.Forms.FileDialog.FileOk> событие <xref:System.Windows.Forms.OpenFileDialog> подключены обработчики событий, определенный в примере. Если пример выполняется, отобразите диалоговое окно, нажав кнопку.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Включает визуальные стили для приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод включает визуальные стили для приложения. Визуальные стили являются цвета, шрифты и другие визуальные элементы, которые формируют темы операционной системы. Элементы управления будут рисования с применением стилей оформления, если элемент управления и операционная система поддерживает его. Вступил в силу <xref:System.Windows.Forms.Application.EnableVisualStyles> должен вызываться перед созданием элементов управления в приложении; как правило, <xref:System.Windows.Forms.Application.EnableVisualStyles> является первой строкой в `Main` функции. Отдельный манифест не требуется включение визуальных стилей, при вызове <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  До .NET Framework 2.0 `FlatStyle` свойства некоторых элементов управления, такие как элементы управления, которые являются производными от <xref:System.Windows.Forms.ButtonBase>, необходимо задать значение <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> в порядке для элементов управления рисоваться с использованием стилей оформления. В приложениях, написанных с помощью .NET Framework 2.0 это больше не требуется.  
  
> [!NOTE]
>  Этот метод не будет действовать для элементов управления, размещенного в Internet Explorer.  
  
   
  
## Examples  
 В следующем примере кода показан вызов <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> в `Main` функции, чтобы включить визуальные стили для приложения.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при переходе приложения в модальное состояние.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Так как это статическое событие, необходимо отсоединить обработчики событий при удалении приложения или утечки памяти.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.Application.EnterThreadModal> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в Windows Forms и убедитесь, что обработчик событий будет связана с <xref:System.Windows.Forms.Application.EnterThreadModal> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Требуется <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> разрешение для прослушивания события.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает путь для исполняемого файла, запустившего приложение, включая исполняемое имя.</summary>
        <value>Путь и исполняемое имя для исполняемого файла, запустившего приложение.  
  
Этот путь будет отличаться в зависимости от того, развернуто ли приложение Windows Forms с использованием [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения хранятся в кэше приложений пользователя в C:\Documents and Settings\\*username* каталога. Дополнительные сведения см. в разделе [доступ к локальным и удаленным данным в приложениях ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Для получения пути. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сообщает всем средствам переноса сообщений, что они должны завершить работу, а затем закрывает все окна приложения после обработки сообщений.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сообщает всем средствам переноса сообщений, что они должны завершить работу, а затем закрывает все окна приложения после обработки сообщений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A> Метод останавливает все выполняющиеся циклы обработки сообщений во всех потоках и закрывает все окна приложения. Этот метод не обязательно выполняет принудительное закрытие приложения. <xref:System.Windows.Forms.Application.Exit%2A> Метод обычно вызывается из цикла обработки сообщений и заставляет <xref:System.Windows.Forms.Application.Run%2A> для возврата. Чтобы выйти из цикла обработки сообщений только текущий поток, вызовите <xref:System.Windows.Forms.Application.ExitThread%2A>.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> вызывает следующие события и выполняет связанные условные действия:  
  
-   Объект <xref:System.Windows.Forms.Form.FormClosing> события для каждой формы, представленный <xref:System.Windows.Forms.Application.OpenForms%2A> свойство. Это событие можно отменить, установив <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойство их <xref:System.Windows.Forms.FormClosingEventArgs> параметр `true`.  
  
-   Если один или несколько обработчиков отменяет событие, затем <xref:System.Windows.Forms.Application.Exit%2A> возвращает без дополнительной настройки. В противном случае <xref:System.Windows.Forms.Form.FormClosed> событие возникает при каждом открытии формы, а затем закрыть все выполнения циклов обработки сообщений и форм.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A> Метод не вызывает <xref:System.Windows.Forms.Form.Closed> и <xref:System.Windows.Forms.Form.Closing> событий, которые являются устаревшими начиная с версии [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## Examples  
 В следующем примере кода список номеров в поле со списком в форме. Каждый раз при щелчке `button1`, приложение добавляет в список другой номер.  
  
 `Main` Вызовы методов <xref:System.Windows.Forms.Application.Run%2A> для запуска приложения, который создает форму, `listBox1`, и `button1`. Когда пользователь щелкает `button1`, `button1_Click` метод складывает числа одного до трех в поле со списком и отображает <xref:System.Windows.Forms.MessageBox>. Если пользователь нажимает кнопку **нет** на <xref:System.Windows.Forms.MessageBox>, `button1_Click` метод добавляет в список другой номер. Если пользователь нажимает кнопку **Да**, приложение вызывает <xref:System.Windows.Forms.Application.Exit%2A>, чтобы обработать все оставшиеся сообщения в очереди и затем осуществить выход.  
  
 В этом примере требуется `listBox1` и `button1` был создан и размещен в форме.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего на вызов неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Возвращает сведения о том, отменил ли выход какой-либо объект <see cref="T:System.Windows.Forms.Form" /> в приложении.</param>
        <summary>Сообщает всем средствам переноса сообщений, что они должны завершить работу, а затем закрывает все окна приложения после обработки сообщений.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">Для разрешения завершить выполнение потока приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выходит из цикла обработки сообщений в текущем потоке и закрывает все окна в потоке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы выйти из цикла обработки сообщений текущего потока. Этот метод приводит к вызову <xref:System.Windows.Forms.Application.Run%2A> для текущего потока для возврата. Чтобы выйти из всего приложения, вызовите <xref:System.Windows.Forms.Application.Exit%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего на вызов неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">Фильтруемое сообщение о событии Windows.</param>
        <summary>Запускает любые фильтры для сообщения окна и возвращает копию измененного сообщения.</summary>
        <returns>Значение <see langword="true" />, если фильтр был обработан; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение заканчивает обработку и собирается перейти в состояние простоя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При наличии задач, которые необходимо выполнить перед поток становится неактивным, подключите их к этому событию.  
  
> [!CAUTION]
>  Так как это статическое событие, необходимо отсоединить обработчики событий при удалении приложения или утечки памяти.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.Application.Idle> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в форму Windows и убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Application.Idle> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает, когда приложение собирается выйти из модального состояния.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Так как это статическое событие, необходимо отсоединить обработчики событий при удалении приложения или утечки памяти.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.Application.LeaveThreadModal> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в Windows Forms и убедитесь, что обработчик событий будет связана с <xref:System.Windows.Forms.Application.LeaveThreadModal> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает путь для данных приложения локального неперемещающегося пользователя.</summary>
        <value>Путь для данных приложения локального неперемещающегося пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Локальный пользователь входит, профиль пользователя хранится в системе, в которой пользователь вошел в систему. Если путь не существует, он создается в следующем формате:  
  
 *Базовый путь*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Типичный базовый путь — C:\Documents and Settings\\*username*\Local Settings\Application данных. Этот путь будет отличаться, тем не менее, если приложение Windows Forms развертывается с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] создает свой собственный каталог данных приложения, которая изолирована от всех других приложений. Дополнительные сведения см. в разделе [доступ к локальным и удаленным данным в приложениях ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 В следующем примере кода показаны две формы и выход из приложения, при закрытии обе формы. Когда приложение запустится и завершает работу, позиция каждой формы запоминается. Несмотря на то, что в этом примере показано использование <xref:System.Windows.Forms.Application.UserAppDataPath%2A> свойство для хранения данных приложений для пользователя, <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> взамен можно использовать.  
  
 `MyApplicationContext` Класс наследует от <xref:System.Windows.Forms.ApplicationContext> и отслеживает, когда каждая форма закрывается и выходит из текущего потока, если они оба. Класс сохраняет позиции каждой формы для пользователя. Данные позиции формы сохраняются в файле под названием `Appdata.txt` , созданный в месте <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Вызовы методов `Application.Run(context)` для запуска приложения, получившего <xref:System.Windows.Forms.ApplicationContext>.  
  
 Этот код является выдержкой из примера, приведенного в <xref:System.Windows.Forms.ApplicationContext> Общие сведения о классе. Для краткости изложения код не отображается. См. в разделе <xref:System.Windows.Forms.ApplicationContext> для кода.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, существует ли цикл обработки сообщений в данном потоке.</summary>
        <value>Значение <see langword="true" />, если цикл обработки сообщений существует; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При размещении в других средах, таких как неуправляемые приложения Windows Forms это свойство всегда возвращает `false`. Используйте <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> для указания Windows Forms, если среда размещения по-прежнему имеет к циклу активных сообщений.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует OLE в текущем потоке.</summary>
        <returns>Одно из значений <see cref="T:System.Threading.ApartmentState" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом любых `Microsoft.Win32` методу, требующему OLE. <xref:System.Windows.Forms.Application.OleRequired%2A> сначала проверяет, было ли инициализировано OLE в текущем потоке. В противном случае он инициализирует поток для OLE.  
  
> [!NOTE]
>  Если поток вызывает методы OLE непосредственно, вы не обязательно должны вызывать этот метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">Объект <see cref="T:System.Exception" /> представляет выданное исключение.</param>
        <summary>Создает событие <see cref="E:System.Windows.Forms.Application.ThreadException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.Windows.Forms.Application.OnThreadException%2A> для вызова исключения остановке обработки приложения.  
  
 <xref:System.Windows.Forms.Application> Класс имеет <xref:System.Windows.Forms.Application.ThreadException> событий. Можно присоединить обработчик событий к этому событию, чтобы выполнить любую пользовательскую обработку, необходимую для необработанных исключений. Если не присоединяется обработчик событий <xref:System.Windows.Forms.Application.OnThreadException%2A> выполнит поведение по умолчанию, которое включает в себя Отображение диалогового окна, чтобы информировать пользователей о том, что возникла ошибка.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> реализует поведение по умолчанию исключений для необработанных исключений, возникающих только на потоки, принадлежащие Windows Forms. Необработанные исключения в других потоках, обрабатываются <xref:System.AppDomain.UnhandledException> событий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию открытых форм, принадлежащих приложению.</summary>
        <value>Коллекция <see cref="T:System.Windows.Forms.FormCollection" />, содержащая все открытые в данный момент формы, принадлежащие этому приложению.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A> Свойство представляет доступную только для чтения коллекцию форм, принадлежащих приложению. Эта коллекция может осуществляться по индексу или по <xref:System.Windows.Forms.Control.Name%2A> из <xref:System.Windows.Forms.Form>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Вызывающая сторона должна иметь разрешение на доступ к все окна в соответствии с определением <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> значение <see cref="T:System.Security.Permissions.UIPermissionWindow" /> перечисления.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает название продукта, сопоставленного с данным приложением.</summary>
        <value>Название продукта.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` берется из метаданных сборки, содержащей главной формы текущего приложения. Его можно установить, задав <xref:System.Reflection.AssemblyProductAttribute> в манифесте сборки. Дополнительные сведения см. в статье [Манифест сборки](~/docs/framework/app-domains/assembly-manifest.md).  
  
   
  
## Examples  
 В следующем примере кода получается свойство и его значение отображается в текстовом поле. В этом примере требуется `textBox1` разместил на форме.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает версию продукта, сопоставленную с данным приложением.</summary>
        <value>Версия продукта.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, отображает номер версии в виде *основной номер*. *Вспомогательная номер*. *номер сборки*. *номер закрытой части*. Может быть задана явно, установив версию сборки в манифесте сборки. Дополнительные сведения см. в статье [Манифест сборки](~/docs/framework/app-domains/assembly-manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> Первый выглядит, чтобы определить наличие сборки, содержащей основного исполняемого файла `AssemblyInformationalVersion` атрибут на нем. Если этот атрибут существует, он используется для обоих <xref:System.Windows.Forms.Application.ProductVersion%2A> и <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Если этот атрибут не существует, оба свойства используйте версию исполняемого файла.  
  
   
  
## Examples  
 В следующем примере кода получается свойство и его значение отображается в текстовом поле. В этом примере требуется `textBox1` разместил на форме.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, передаваемый событию <see cref="E:System.Windows.Forms.Application.Idle" />.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Application.Idle" /> в размещенных скриптах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется при размещении в другой среде, например в неуправляемом приложении Windows Forms. Следует вызывать <xref:System.Windows.Forms.Application.RaiseIdle%2A> когда ведущее приложение переходит в состояние бездействия. Это обеспечивает некоторые элементы управления Windows Forms и компонентов для выполнения важных фоновой работы, пока пользователь не взаимодействует с приложением.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Метод, вызываемый, когда для Windows Forms требуется проверить, продолжают ли отправляться сообщения в размещаемых средах.</param>
        <summary>Регистрирует ответный вызов, чтобы проверить, выполняется ли цикл обработки сообщений в размещенных средах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется при размещении в другой среде, например в неуправляемом приложении Windows Forms. Что касается размещенных сред <xref:System.Windows.Forms.Application.MessageLoop%2A> свойство будет всегда возвращать значение false, если не обрабатывает сообщения Windows Forms. Используйте этот обратный вызов нужно сообщить Windows Forms, если среда размещения во время обработки сообщения.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Реализация объекта <see cref="T:System.Windows.Forms.IMessageFilter" /> для удаления из приложения.</param>
        <summary>Удаляет фильтр сообщений из средства переноса сообщений приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно удалить фильтр сообщений, если вы больше не требуется захватывать сообщения Windows перед их отправкой.  
  
   
  
## Examples  
 Прежде чем можно будет использовать фильтр сообщений, необходимо обеспечить реализацию для <xref:System.Windows.Forms.IMessageFilter> интерфейс. Следующий класс создает фильтр сообщений называется `TestMessageFilter`. Этот фильтр блокирует все сообщения, относящиеся к левой кнопки мыши.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, будет ли текущее приложение прорисовывать элементы управления с помощью визуальных стилей.</summary>
        <value>Значение <see langword="true" />, если визуальные стили включены для элементов управления в клиентской области окна приложения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При рисовании пользовательского элемента управления, это свойство используется для решить, следует ли для рисования элемента управления с или без учета стилей оформления, таким образом, чтобы его внешний вид согласованное с другими элементами управления в приложении.  
  
 В следующей таблице показаны четыре условия, которые должны выполняться для <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> для возврата `true`.  
  
|Условие|Описание|  
|---------------|-----------------|  
|Операционная система поддерживает стили оформления|Чтобы проверить это условие отдельно, используйте свойство <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> класса <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> .|  
|Пользователь включил стили оформления в операционной системе|Чтобы проверить это условие отдельно, используйте свойство <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> класса <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> .|  
|Визуальные стили включены в приложении|Стили оформления можно включить в приложении, вызвав метод <xref:System.Windows.Forms.Application.EnableVisualStyles> или воспользовавшись манифестом приложения, указывающим, что для рисования элементов управления будет применяться ComCtl32.dll версии 6 или более поздней.|  
|Стили оформления используются для рисования клиентской области окон приложений|Чтобы проверить это условие отдельно, используйте свойство <xref:System.Windows.Forms.Application.VisualStyleState%2A> класса <xref:System.Windows.Forms.Application> и убедитесь, что оно имеет значение <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> или <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает работу приложения и немедленно запускает новый экземпляр.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее частая причина вызова `Restart` — начать новую версию приложения, которое вы скачали через [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] с помощью `Update` или `UpdateAsync` метод.  
  
 Приложения повторно запускаются в контексте, в котором они были изначально запущены. Если приложение было запущено с помощью URL-адрес, указывающий непосредственно на основной исполняемый файл приложения, компьютер будет перезагружен с помощью же URL-адрес. Если приложение является [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения, компьютер будет перезагружен с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 Если приложение было первоначально предоставлены параметры командной строки, при первом выполнении <xref:System.Windows.Forms.Application.Restart%2A> запустит приложение снова с теми же параметрами.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Код пользователя не является приложением Windows Forms. Пользователь не может вызвать этот метод в данном контексте.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Требуется <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> разрешение.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает стандартный цикл обработки сообщений приложения в текущем потоке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает стандартный цикл обработки сообщений приложения в текущем потоке, без формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В основе Win32 или Windows Forms цикл обработки сообщений приложения, — это подпрограмма в код, обрабатывающий события пользователя, например щелчки мышью и нажатия клавиш. Каждого приложения на базе Windows требуется к циклу активных сообщений называется основной цикл обработки сообщений. При закрытии основной цикл обработки сообщений, приложение завершает работу. В Windows Forms, этот цикл закрывается, когда <xref:System.Windows.Forms.Application.Exit%2A> вызывается метод, или когда <xref:System.Windows.Forms.Application.ExitThread%2A> метод вызывается в потоке, который запущен основной цикл обработки сообщений.  
  
 Большинство разработчиков Windows Forms не нужно использовать эту версию метода. Следует использовать <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> перегрузка для запуска приложения с главной формы, чтобы приложение завершает работу при закрытии главной формы. Для всех остальных случаях используйте <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> перегрузку, которая поддерживает предоставление <xref:System.Windows.Forms.ApplicationContext> объекта для улучшения контроля над жизненного цикла приложения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Основной цикл обработки сообщений уже запущен в данном потоке.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">Объект <see cref="T:System.Windows.Forms.ApplicationContext" />, в котором запускается приложение.</param>
        <summary>Запускает стандартный цикл обработки сообщений приложения в текущем потоке, с <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Цикл обработки сообщений выполняется до <xref:System.Windows.Forms.Application.Exit%2A> или <xref:System.Windows.Forms.Application.ExitThread%2A> вызывается или <xref:System.Windows.Forms.Application.ThreadExit> события объекта контекста.  
  
   
  
## Examples  
 В примере показаны две формы и выход из приложения, при закрытии обе формы. Когда приложение запустится и завершает работу, позиция каждой формы запоминается. В этом примере демонстрируется использование <xref:System.Windows.Forms.ApplicationContext>, вместе с `Application.Run(context)` метод для отображения нескольких форм при запуске приложения.  
  
 Класс `MyApplicationContext` наследует от <xref:System.Windows.Forms.ApplicationContext> и отслеживает, когда каждая форма закрывается и выходит из текущего потока, если они оба. Класс сохраняет позиции каждой формы для пользователя. Данные позиции формы сохраняются в файле под названием `Appdata.txt` , созданный в месте <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Вызовы методов `Application.Run(context)` для запуска приложения, получившего <xref:System.Windows.Forms.ApplicationContext>.  
  
 Код для `AppForm1` и `AppForm2` forms не отображается для краткости изложения. См. в разделе <xref:System.Windows.Forms.ApplicationContext> Общие сведения о классе для кода.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Основной цикл обработки сообщений уже запущен в данном потоке.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">Код <see cref="T:System.Windows.Forms.Form" />, представляющий форму, которую следует сделать видимой.</param>
        <summary>Запускает стандартный цикл обработки сообщений приложения в текущем потоке и делает указанную форму видимой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило основная функция приложение вызывает этот метод и передает ему главное окно приложения.  
  
 Этот метод добавляет обработчик событий для `mainForm` параметр <xref:System.Windows.Forms.Form.Closed> событий. Вызовов обработчика событий <xref:System.Windows.Forms.Application.ExitThread%2A> для очистки приложения.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Dispose%2A> Метод <xref:System.Windows.Forms.Form> будет вызван до возвращения этого метода.  
  
   
  
## Examples  
 В следующем примере кода список номеров в поле со списком в форме. Каждый раз при щелчке `button1`, приложение добавляет в список другой номер.  
  
 `Main` Вызовы методов <xref:System.Windows.Forms.Application.Run%2A> для запуска приложения, который создает форму, `listBox1`, и `button1`. Когда пользователь щелкает `button1`, `button1_Click` метод складывает числа одного до трех в поле со списком и отображает <xref:System.Windows.Forms.MessageBox>. Если пользователь нажимает кнопку **нет** на <xref:System.Windows.Forms.MessageBox>, `button1_Click` метод добавляет в список другой номер. Если пользователь нажимает кнопку **Да**, приложение вызывает <xref:System.Windows.Forms.Application.Exit%2A> для обработки всех оставшихся сообщений в очереди и затем осуществить выход.  
  
 В этом примере требуется `listBox1` и `button1` создан и размещен в форме.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Основной цикл обработки сообщений уже запущен в текущем потоке.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает строку формата для использования в заголовках окон верхнего уровня, когда они отображаются с предупреждающим объявлением.</summary>
        <value>Строка формата, применяемая для заголовков окон верхнего уровня.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для всех окон задать это свойство. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Значение по умолчанию, используемое для новых элементов управления. Если задано значение <see langword="true" />, новые элементы управления, поддерживающие <c>UseCompatibleTextRendering</c>, используют для отрисовки текста класс <see cref="T:System.Drawing.Graphics" /> основанный на [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]; если задано значение <see langword="false" />, новые элементы управления используют класс <see cref="T:System.Windows.Forms.TextRenderer" />, основанный на [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)].</param>
        <summary>Задает значения по умолчанию во всем приложении для свойства <c>UseCompatibleTextRendering</c>, определенного в конкретных элементах управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые элементы управления Windows Forms могут визуализировать свой текст, с помощью <xref:System.Windows.Forms.TextRenderer> класс, который основан на [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] графической библиотеки или <xref:System.Drawing.Graphics> класс, который основан на [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] графической библиотеки. Это изменение было внесено в [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] из-за проблем с производительностью и локализации [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Используйте <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> присвоить значение по умолчанию `UseCompatibleTextRendering` свойства для элементов управления, которые ее поддерживают.  
  
 `UseCompatibleTextRendering` Свойство предназначено для предоставления visual совместимости между элементами управления Windows Forms, в этой визуализации текста с помощью <xref:System.Windows.Forms.TextRenderer> класс и [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] и [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] приложений, которые выполняют отрисовку пользовательского текста, с помощью <xref:System.Drawing.Graphics>класса. В большинстве случаев, если приложение не обновляется из [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] или [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], рекомендуется оставить установленным `UseCompatibleTextRendering` присвоено значение по умолчанию `false`.  
  
 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Основе <xref:System.Windows.Forms.TextRenderer> класс впервые появился в [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] для повышения производительности, как сделать текст поиска лучше и улучшить поддержку международных шрифтов. В более ранних версиях [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] основе <xref:System.Drawing.Graphics> класс был использован для выполнения всех отрисовки текста. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] вычисляет интервал и переноса строк по-разному из [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. В приложении Windows Forms, использующего <xref:System.Drawing.Graphics> класса для вывода текста, это может привести к текст для элементов управления, использующих <xref:System.Windows.Forms.TextRenderer> отображаться отличается от другого текста в приложении. Чтобы устранить проблему несовместимости, можно задать `UseCompatibleTextRendering` свойства `true`. Чтобы задать `UseCompatibleTextRendering` для `true` для всех элементов управления в приложении, вызовите <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> метод с параметром `true`.  
  
 Этот метод никогда не следует вызывать, если код Windows Forms находится в другом приложении, например Internet Explorer. Этот метод следует вызовите только в автономных приложений Windows Forms.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Чтобы задать значение по умолчанию для `UseCompatibleTextRendering` в [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] или более поздней версии, см. в разделе <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.  
  
 В [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] или более поздней версии, вызов <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> автоматически создается в файле Program.cs. Чтобы изменить значение по умолчанию отрисовки текста, измените созданный код.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот метод может быть вызван только до того, как первое окно будет создано приложением Windows Forms.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="highDpiMode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state">Объект <see cref="T:System.Windows.Forms.PowerState" />, указывающий режим питания, в который следует перейти.</param>
        <param name="force">Значение <see langword="true" />, чтобы немедленно перейти в режим приостановки работы; значение <see langword="false" />, чтобы система Windows отправила запрос на приостановку работы каждому приложению.</param>
        <param name="disableWakeEvent">Значение <see langword="true" />, чтобы отключить восстановление активного состояния питания системы, если произойдет событие пробуждения, значение <see langword="false" />, чтобы включить восстановление активного состояния питания системы, если произойдет событие пробуждения.</param>
        <summary>Приостанавливает работу системы или переводит ее в спящий режим или же запрашивает приостановку работы системы или перевод ее в спящий режим.</summary>
        <returns>Значение <see langword="true" />, если работа системы приостанавливается, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если приложение не отвечает на запрос в течение 20 секунд, Windows определяет, что он находится в состоянии отвечать, и что приложение может быть переведена в спящий режим или завершен. Когда приложение отвечает на запрос, тем не менее, может занять некоторое время, его необходимо очистить ресурсы и завершить работу активных процессов.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Указывает, как приложение должно реагировать на необработанные исключения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода задаются обработчики событий для исключений, возникающих в потоках Windows Forms и исключений, происходящих в других потоках. Он задает <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> , все исключения обрабатываются приложением, независимо от настроек в файле конфигурации приложения пользователя. Она использует <xref:System.Windows.Forms.Application.ThreadException> событий для обработки исключений для потока пользовательского интерфейса и <xref:System.AppDomain.UnhandledException> событий для обработки исключений потоков без пользовательского интерфейса. Так как <xref:System.AppDomain.UnhandledException> не может помешать приложению завершение работы, пример просто ошибка регистрируется в журнале событий приложений до завершения операции.  
  
 В этом примере предполагается, что было определено два <xref:System.Windows.Forms.Button> элементов управления, `button1` и `button2`на вашей <xref:System.Windows.Forms.Form> класса.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Значение <see cref="T:System.Windows.Forms.UnhandledExceptionMode" />, описывающее поведение приложения при выдаче исключения, которое не было перехвачено.</param>
        <summary>Указывает, как приложение должно реагировать на необработанные исключения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нецелесообразно часто для перехвата всех исключений, генерируемых Windows Forms. При использовании этого метода можно указать приложения ли он должен все необработанные исключения, выдаваемые компонентами Windows Forms и продолжить работу, или независимо от того, следует ли его сделать его доступным для пользователя и останавливает выполнение.  
  
 Вызовите <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> прежде, чем вы создаете экземпляры в основной форме приложения с помощью <xref:System.Windows.Forms.Application.Run%2A> метод.  
  
 Перехватывать исключения, возникающие в потоки, не созданные и владельцем в Windows Forms, использовать <xref:System.AppDomain.UnhandledException> обработчик событий.  
  
   
  
## Examples  
 В следующем примере кода задаются обработчики событий для исключений, возникающих в потоках Windows Forms и исключений, происходящих в других потоках. Он задает <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> , все исключения обрабатываются приложением, независимо от настроек в файле конфигурации приложения пользователя. Она использует <xref:System.Windows.Forms.Application.ThreadException> событий для обработки исключений для потока пользовательского интерфейса и <xref:System.AppDomain.UnhandledException> событий для обработки исключений потоков без пользовательского интерфейса. Так как <xref:System.AppDomain.UnhandledException> не может помешать приложению завершение работы, пример просто ошибка регистрируется в журнале событий приложений до завершения операции.  
  
 В этом примере предполагается, что было определено два <xref:System.Windows.Forms.Button> элементов управления, `button1` и `button2`на вашей <xref:System.Windows.Forms.Form> класса.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Режим исключения не может быть задан после того, как приложение создало свое первое окно.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Значение <see cref="T:System.Windows.Forms.UnhandledExceptionMode" />, описывающее поведение приложения при выдаче исключения, которое не было перехвачено.</param>
        <param name="threadScope">Значение <see langword="true" />, чтобы задать режим исключения потока; в противном случае — значение <see langword="false" />.</param>
        <summary>Предоставляет приложению инструкции, определяющие, как приложение должно отвечать на необработанные исключения, при необходимости применяя поведение, зависящее от потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нецелесообразно часто для перехвата всех исключений, генерируемых Windows Forms. При использовании этого метода можно указать приложения ли он должен все необработанные исключения, выдаваемые компонентами Windows Forms и продолжить работу, или независимо от того, следует ли его сделать его доступным для пользователя и останавливает выполнение.  
  
 Вызовите <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> прежде, чем вы создаете экземпляры в основной форме приложения с помощью <xref:System.Windows.Forms.Application.Run%2A> метод.  
  
 Когда `threadScope` является `true`, задать режим исключения потока. Режим исключения потока переопределяет режим исключения приложения, если `mode` не присвоено значение <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.  
  
 Когда `threadScope` является `false`, задать режим исключения приложения. Режим исключений приложения используется для всех потоков, которые имеют <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> режим. Настройка режима исключения приложения не влияет на параметр текущего потока.  
  
 Перехватывать исключения, возникающие в потоки, не созданные и владельцем в Windows Forms, использовать <xref:System.AppDomain.UnhandledException> обработчик событий.  
  
   
  
## Examples  
 В следующем примере кода задаются обработчики событий для исключений, возникающих в потоках Windows Forms и исключений, происходящих в других потоках. Он задает <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> , все исключения обрабатываются приложением, независимо от настроек в файле конфигурации приложения пользователя. Она использует <xref:System.Windows.Forms.Application.ThreadException> событий для обработки исключений для потока пользовательского интерфейса и <xref:System.AppDomain.UnhandledException> событий для обработки исключений потоков без пользовательского интерфейса. Так как <xref:System.AppDomain.UnhandledException> не может помешать приложению завершение работы, пример просто ошибка регистрируется в журнале событий приложений до завершения операции.  
  
 В этом примере предполагается, что было определено два <xref:System.Windows.Forms.Button> элементов управления, `button1` и `button2`на вашей <xref:System.Windows.Forms.Form> класса.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Режим исключения не может быть задан после того, как приложение создало свое первое окно.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает путь для исполняемого файла, запустившего приложение, не включая исполняемое имя.</summary>
        <value>Путь для исполняемого файла, запустившего приложение.  
  
Этот путь будет отличаться в зависимости от того, развернуто ли приложение Windows Forms с использованием [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] приложения хранятся в кэше приложений пользователя в C:\Documents and Settings\\*username* каталога. Дополнительные сведения см. в разделе [доступ к локальным и удаленным данным в приложениях ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода получается свойство и его значение отображается в текстовом поле. В этом примере требуется `textBox1` разместил на форме.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Для получения пути. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при выдаче неперехваченного исключения потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие позволяет вашему приложению Windows Forms для обработки в противном случае необработанных исключений, возникающих в потоках Windows Forms. Присоединить обработчики событий к <xref:System.Windows.Forms.Application.ThreadException> событие, чтобы обрабатывать эти исключения, которые оставит приложение в неизвестном состоянии. Если это возможно, исключения должна обрабатываться блоков структурной обработки исключений.  
  
 Можно изменить этот обратный вызов используется для необработанных исключений потока Windows Forms, задав ли <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>. Перехватывать исключения, возникающие в потоки, не созданные и владельцем в Windows Forms, использовать <xref:System.AppDomain.UnhandledException> обработчик событий.  
  
> [!NOTE]
>  Чтобы гарантировать, что это событие не активаций будут отсутствовать, необходимо присоединить обработчик, перед вызовом метода <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Так как это статическое событие, необходимо отсоединить обработчики событий при удалении приложения или утечки памяти.  
  
   
  
## Examples  
 В следующем примере кода задаются обработчики событий для исключений, возникающих в потоках Windows Forms и исключений, происходящих в других потоках. Он задает <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> , все исключения обрабатываются приложением, независимо от настроек в файле конфигурации приложения пользователя. Она использует <xref:System.Windows.Forms.Application.ThreadException> событий для обработки исключений для потока пользовательского интерфейса и <xref:System.AppDomain.UnhandledException> событий для обработки исключений потоков без пользовательского интерфейса. Так как <xref:System.AppDomain.UnhandledException> не может помешать приложению завершение работы, пример просто ошибка регистрируется в журнале событий приложений до завершения операции.  
  
 В этом примере предполагается, что было определено два <xref:System.Windows.Forms.Button> элементов управления, `button1` и `button2`на вашей <xref:System.Windows.Forms.Form> класса.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственного вызывающего на вызов неуправляемого кода, при добавлении обработчика для этого события. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при закрытии потока. Перед закрытием главного потока для приложения вызывается данное событие, за которым следует событие <see cref="E:System.Windows.Forms.Application.ApplicationExit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо присоединить обработчики событий к <xref:System.Windows.Forms.Application.ThreadExit> событий для выполнения любых необработанных, необходимых задач перед закрытием потока. Закройте файлы, открытые с данным потоком, или удалите объекты, сборщик мусора не восстановленные.  
  
> [!CAUTION]
>  Так как это статическое событие, необходимо отсоединить обработчики событий при удалении приложения или утечки памяти.  
  
   
  
## Examples  
 В следующем примере кода показано использование этого элемента. В примере обработчик событий сообщает о вхождение <xref:System.Windows.Forms.Application.ThreadExit> событий. Этот отчет позволяет выяснить, когда происходит событие и может оказаться полезным при отладке. Чтобы создать отчет для нескольких событий или событий, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавлении сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в Windows Forms и убедитесь, что обработчик событий будет связана с <xref:System.Windows.Forms.Application.ThreadExit> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет регистрацию ответного вызова цикла обработки сообщений, сделанного с помощью метода <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает путь для данных приложения пользователя.</summary>
        <value>Путь для данных приложения пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если путь не существует, он создается в следующем формате:  
  
 *Базовый путь*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Данные, хранящиеся в данном контуре является частью перемещаемого профиля пользователя. Перемещаемый пользователь работает на более чем один компьютер в сети. Профиль пользователя для перемещаемого профиля пользователя хранится на сервере в сети и загружается в систему при входе пользователя в систему. Для профиля пользователя, следует учитывать при перемещении операционная система должна поддерживать перемещаемые профили, и она должна быть включена.  
  
 Типичный базовый путь — C:\Documents and Settings\\*username*\Application Data. Этот путь будет отличаться, тем не менее, если приложение Windows Forms развертывается с помощью [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] создает свой собственный каталог данных приложения, которая изолирована от всех других приложений. Дополнительные сведения см. в разделе [доступ к локальным и удаленным данным в приложениях ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 В следующем примере кода показаны две формы и выход из приложения, при закрытии обе формы. Когда приложение запустится и завершает работу, позиция каждой формы запоминается. В этом примере показано использование <xref:System.Windows.Forms.Application.UserAppDataPath%2A> свойство для хранения данных приложений для пользователя.  
  
 Класс `MyApplicationContext` наследует от <xref:System.Windows.Forms.ApplicationContext> и отслеживает, когда каждая форма закрывается и выходит из текущего потока, если они оба. Класс сохраняет позиции каждой формы для пользователя. Данные позиции формы сохраняются в файле под названием `Appdata.txt` , созданный в месте <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Вызовы методов `Application.Run(context)` для запуска приложения, получившего <xref:System.Windows.Forms.ApplicationContext>.  
  
 Этот код является выдержкой из примера, приведенного в <xref:System.Windows.Forms.ApplicationContext> Общие сведения о классе. Для краткости изложения код не отображается. См. в разделе <xref:System.Windows.Forms.ApplicationContext> для кода.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает раздел реестра для данных приложения пользователя.</summary>
        <value>Объект <see cref="T:Microsoft.Win32.RegistryKey" /> представляет раздел реестра для данных приложения конкретного пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ключ не существует, он создается в следующем формате:  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Данные, хранящиеся в этот раздел является частью перемещаемого профиля пользователя. Перемещаемый пользователь работает на более чем один компьютер в сети. Профиль пользователя для перемещаемого профиля пользователя хранится на сервере в сети и загружается в систему при входе пользователя в систему. Для профиля пользователя, следует учитывать при перемещении операционная система должна поддерживать перемещаемые профили, и она должна быть включена.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет, используется ли курсор ожидания для всех открытых форм приложения, или задает использование этого курсора.</summary>
        <value>Значение <see langword="true" />, если курсор ожидания будет использоваться для всех открытых форм; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если присвоить этому свойству `true`, <xref:System.Windows.Forms.Control.UseWaitCursor%2A> из всех открытых форм приложения будет установлено `true`. Этот вызов не будет возвращен, пока не установлено это свойство во всех формах. Используйте это свойство после долго выполняющейся операции и чтобы указать во всех формах приложения, которая операция обрабатывается по-прежнему.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, каким образом визуальные стили применяются к окну приложения.</summary>
        <value>Поразрядное сочетание значений <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это <xref:System.Windows.Forms.Application.VisualStyleState%2A> свойство определяет, включены ли стили оформления в клиентской области или неклиентской области окон приложений. Как правило, это свойство должно задаваться в конструкторе форм главной или <xref:System.Windows.Forms.Form.Load> обработчик событий.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Windows.Forms.Application.VisualStyleState%2A> задается одно из <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> значениям в <xref:System.Windows.Forms.Control.Click> обработчик событий для <xref:System.Windows.Forms.Button> элемента управления. Данный пример кода является частью большего примера для <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> перечисления.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>