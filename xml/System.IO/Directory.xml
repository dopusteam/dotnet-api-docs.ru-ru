<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6b2dfc84f48aa62b20974348afaefe56611626b9" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57915832" /></Metadata><TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <TypeSignature Language="F#" Value="type Directory = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет статические методы для создания, перемещения и перечисления в каталогах и вложенных каталогах. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.IO.Directory> класс на выполнение стандартных операций, таких как копирование, перемещение, переименование, создание и удаление каталогов.  
  
-   Чтобы создать каталог, используйте один из <xref:System.IO.Directory.CreateDirectory%2A> методы.  
  
-   Чтобы удалить каталог, используйте один из <xref:System.IO.Directory.Delete%2A> методы.  
  
-   Чтобы получить или задать текущий каталог для приложения, используйте <xref:System.IO.Directory.GetCurrentDirectory%2A> или <xref:System.IO.Directory.SetCurrentDirectory%2A> метод.  
  
-   Для управления <xref:System.DateTime> сведения, связанные с созданием, доступа и запись каталога, использовать такие методы как <xref:System.IO.Directory.SetLastAccessTime%2A> и <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Статические методы класса <xref:System.IO.Directory> выполняется проверка безопасности для всех методов. Если вы собираетесь использовать объект несколько раз, рекомендуется использовать соответствующий метод экземпляра <xref:System.IO.DirectoryInfo> вместо этого, так как проверка безопасности будет не всегда быть необходимости.  
  
 Если выполняется только одно действие, связанное с directory, возможно, более эффективно использовать статический <xref:System.IO.Directory> метод вместо соответствующего <xref:System.IO.DirectoryInfo> метод экземпляра. Большинство <xref:System.IO.Directory> методы требуют путь к каталогу, который вы имеете дело.  
  
> [!NOTE]
>  В членах, которые принимают строку `path` параметра, этот путь должен иметь правильный формат, или возникает исключение. Например если путь является полным, но начинается с пробела («c:\temp»), строка пути не усечено, поэтому путь считается имеет неправильный формат, и возникает исключение. Кроме того нельзя дважды ввести полный путь или сочетание путей. Например «c:\temp c:\windows» также приводит к появлению исключения. При использовании методов, которые принимают строку пути, убедитесь в том, что путь правильного формата. Дополнительные сведения см. в разделе <xref:System.IO.Path>.  
  
 В членах, которые принимают путь путь можно ссылаться в файл или каталог. Для имени сервера и общей папки можно использовать полный путь, относительный путь или путь универсальными именами (UNC). Например все ниже приведены допустимые пути:  
  
-   «c:\\\MyDir» в C#, или «c:\MyDir» в Visual Basic.  
  
-   «MyDir\\\MySubdir» в C#, или «MyDir\MySubDir» в Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare» в C#, или"\\\MyServer\MyShare» в Visual Basic.  
  
 По умолчанию чтение и запись в новые каталоги доступа ко всем пользователям. Тем не менее приложение должно иметь правильный безопасности для доступа к существующие каталоги.  
  
 Запросить разрешение для каталога и всех его подкаталогах, end строку пути с символом разделителя каталогов. (Например, «C:\Temp\\"предоставляет доступ к C:\Temp\ и всех его подкаталогах.) Запросить разрешение только для конкретного каталога, конец строки пути с периодом. (Например, «C:\Temp\\.» предоставляет доступ только к C:\Temp\\, а не к его подкаталогов.)  
  
 В членах, которые принимают `searchPattern` параметра, строка поиска, которая может быть любое сочетание литеральных символов и два подстановочных знака; \* и?. Этот параметр не распознает регулярные выражения. Дополнительные сведения см. в разделе <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> метод или любой другой метод, который использует `searchPattern` параметра.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory> и <xref:System.IO.DirectoryInfo> не поддерживаются для использования в [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] приложений. Сведения о том, как получить доступ к файлам и папкам в [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] приложений, см. в разделе [доступ к данным и файлы (приложения для Windows Store)](https://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 Приведенный ниже показано, как получить все текстовые файлы из каталога и переместите их в новый каталог. После перемещения файлов они больше не существуют в исходном каталоге.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Следующий пример демонстрирует, как использовать <xref:System.IO.Directory.EnumerateFiles%2A> метод для извлечения коллекции текстовых файлов из каталога, а затем использовать эту коллекцию в запросе для поиска всех строк, которые содержат «Пример».  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 Ниже приведен пример, как переместить каталог и все его файлы в новый каталог. Исходный каталог не существует, после его перемещения.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Практическое руководство. Считывание из нового файла данных и запись в этот файл</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает все каталоги по заданному пути.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Каталог, который необходимо создать.</param>
        <summary>Создает все каталоги и подкаталоги по указанному пути, если они еще не существуют.</summary>
        <returns>Объект, представляющий каталог по указанному пути. Этот объект возвращается вне зависимости от того, существует ли уже каталог по указанному пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все каталоги, указанные в `path` создаются, если они уже существуют или часть `path` является недопустимым. Если каталог уже существует, этот метод не создает новый каталог, но она возвращает <xref:System.IO.DirectoryInfo> для существующего каталога.  
  
 `path` Параметр указывает путь к каталогу, а не путь к файлу.  
  
 Конечные пробелы удаляются из конца `path` параметр до создания каталога.  
  
 Можно создать каталог на удаленном компьютере, в общем ресурсе, у вас есть доступ на запись. UNC-пути, поддерживается; Например, можно указать следующие действия для `path`: `\\2009\Archives\December` в Visual Basic и `\\\\2009\\Archives\\December` в C#.  
  
 Создать каталог с единственным знаком двоеточия (:) не поддерживается и приведет к `NotSupportedException` исключение.  
  
   
  
## Examples  
 Следующий пример создает и удаляет заданный каталог.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Для создания каталога C:\Users\User1\Public\Html при C:\Users\User1 указан текущий каталог, используйте любой из следующих вызовов чтобы убедиться, что обратная косая черта будет воспринята должным образом.  
  
 В Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 В C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 In C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Каталог, заданный параметром <paramref name="path" />, является файлом.  
  
-или- 
Имя сети неизвестно.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="path" /> начинается с символа двоеточия (:) или содержит только двоеточие.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> содержит двоеточие (:), которое не является частью метки диска (C:\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов или каталогов. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Каталог, который необходимо создать.</param>
        <param name="directorySecurity">Элемент управления доступом, который необходимо применить к каталогу.</param>
        <summary>Создает все каталоги по указанному пути, если они еще не существуют, с применением заданных параметров безопасности Windows.</summary>
        <returns>Объект, представляющий каталог по указанному пути. Этот объект возвращается вне зависимости от того, существует ли уже каталог по указанному пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку метода для создания каталога с помощью управления доступом, поэтому не может каталоге можно получить доступ, до применения безопасности.  
  
 Все каталоги, указанные в `path` параметра создаются, если они уже существуют или часть `path` является недопустимым. `path` Параметр указывает путь к каталогу, а не путь к файлу. Если каталог уже существует, этот метод не создает новый каталог, но она возвращает <xref:System.IO.DirectoryInfo> для существующего каталога.  
  
 Конечные пробелы удаляются из конца `path` параметр до создания каталога.  
  
 Можно создать каталог на удаленном компьютере, в общем ресурсе, у вас есть доступ на запись. UNC-пути, поддерживается; Например, можно указать следующие действия для `path`: `\\2009\Archives\December` в Visual Basic и `\\\\2009\\Archives\\December` в C#.  
  
 Создать каталог с единственным знаком двоеточия (:) не поддерживается и приводит к `NotSupportedException` исключение.  
  
   
  
## Examples  
 В следующем примере создается новый каталог с правилами доступа для двух учетных записей пользователей.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Каталог, заданный параметром <paramref name="path" />, является файлом.  
  
-или- 
Имя сети неизвестно.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="path" /> начинается с символа двоеточия (:) или содержит только двоеточие.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> содержит двоеточие (:), которое не является частью метки диска (C:\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов и каталогов, а также для доступа к целевому каталогу. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет заданный каталог и при необходимости все подкаталоги.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Directory.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Имя пустого каталога, который необходимо удалить. Этот каталог должен поддерживать запись и быть пустым.</param>
        <summary>Удаляет пустой каталог по заданному пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод работает идентично <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> с `false` второго параметра.  
  
 `path` Параметр может задавать сведения относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Конечные пробелы удаляются из конца `path` параметра перед удалением каталога.  
  
 Этот метод вызывает исключение <xref:System.IO.IOException> Если папка, заданная в `path` параметр содержит файлы или подкаталоги.  
  
 `path` Параметр не чувствителен к регистру.  
  
 В некоторых случаях, если у вас есть указанный каталог откройте в проводнике <xref:System.IO.Directory.Delete%2A> метод не сможете удалить его.  
  
   
  
## Examples  
 Приведенный ниже показано, как создать новый каталог и подкаталог, а затем удалите только подкаталог.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Файл с тем же именем и расположении, заданном <paramref name="path" />, уже существует.  
  
-или- 
Каталог является текущим рабочим каталогом приложения.  
  
-или- 
Каталог, заданный параметром <paramref name="path" />, не пустой.  
  
-или- 
Каталог доступен только для чтения или содержит файл, доступный только для чтения.  
  
-или- 
Каталог используется другим процессом.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Параметр <paramref name="path" /> не существует или не найден.  
  
-или- 
Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberSignature Language="F#" Value="static member Delete : string * bool -&gt; unit" Usage="System.IO.Directory.Delete (path, recursive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Имя каталога, который необходимо удалить.</param>
        <param name="recursive">Значение <see langword="true" /> позволяет удалить каталоги, подкаталоги и файлы по заданному <paramref name="path" />, в противном случае — значение <see langword="false" />.</param>
        <summary>Удаляет заданный каталог и, при наличии соответствующей инструкции, все подкаталоги и файлы в нем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Параметр может задавать сведения относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Конечные пробелы удаляются из конца `path` параметра перед удалением каталога.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Если `recursive` параметр `true`, пользователь должен иметь разрешение на запись для текущего каталога также и все его подкаталоги.  
  
 Поведение этого метода немного отличается при удалении каталог, содержащий точку повторной обработки, например символическую ссылку или точку подключения. Если объект точки повторной обработки является каталогом, таких как точка подключения, она отключается, и удалить точку подключения. Этот метод не выполняет рекурсию через точку повторной обработки. Если объект точки повторной обработки символьную ссылку на файл, удаляется объект точки повторной обработки и не символьную ссылку.  
  
 В некоторых случаях, если у вас есть указанный каталог откройте в проводнике <xref:System.IO.Directory.Delete%2A> метод не сможете удалить его.  
  
   
  
## Examples  
 Приведенный ниже показано, как создать новый каталог, подкаталог и файл во вложенной папке, и затем рекурсивно удалить все новые элементы.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Файл с тем же именем и расположении, заданном <paramref name="path" />, уже существует.  
  
-или- 
Каталог, заданный параметром <paramref name="path" />, доступен только для чтения, или <paramref name="recursive" /> имеет значение <see langword="false" /> и <paramref name="path" /> не является пустым каталогом.  
  
-или- 
Каталог является текущим рабочим каталогом приложения.  
  
-или- 
Каталог содержит файл только для чтения.  
  
-или- 
Каталог используется другим процессом.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Параметр <paramref name="path" /> не существует или не найден.  
  
-или- 
Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает перечисляемую коллекцию имен каталогов, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает перечисляемую коллекцию имен каталогов, расположенных по указанному пути.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для каталогов в каталоге, заданном параметром <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно указать относительный или абсолютный путь данные в `path` параметра. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога, который можно определить с помощью <xref:System.IO.Directory.GetCurrentDirectory%2A> метод. Возвращаемый имена имеют префикс со значением, введенным в `path` параметра. Например, если указать относительный путь в `path` параметр, возвращаемый имена будет содержать относительный путь.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> И <xref:System.IO.Directory.GetDirectories%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateDirectories%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetDirectories%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateDirectories%2A> может оказаться более эффективным.  
  
 Возвращаемая коллекция не помещен в кэш; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> коллекции начнет новое перечисление.  
  
   
  
## Examples  
 В следующем примере перечисляются каталоги верхнего уровня по указанному пути.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которую необходимо сравнивать с именами каталогов, расположенных по пути <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <summary>Возвращает перечисляемую коллекцию имен каталогов, соответствующих шаблону поиска по указанному пути.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для каталогов в каталоге, указанном в <paramref name="path" />, которые соответствуют указанному шаблону поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Можно указать относительный или абсолютный путь данные в `path` параметра. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога, который можно определить с помощью <xref:System.IO.Directory.GetCurrentDirectory%2A> метод. Возвращаемый имена имеют префикс со значением, введенным в `path` параметра. Например, если указать относительный путь в `path` параметр, возвращаемый имена будет содержать относительный путь.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> И <xref:System.IO.Directory.GetDirectories%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateDirectories%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetDirectories%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateDirectories%2A> может оказаться более эффективным.  
  
 Возвращаемая коллекция не помещен в кэш; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> коллекции начнет новое перечисление.  
  
   
  
## Examples  
 В следующем примере перечисляются каталоги верхнего уровня по указанному пути, которые соответствуют указанному шаблону поиска.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.  
  
-или- 
 <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которую необходимо сравнивать с именами каталогов, расположенных по пути <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах.  
  
Значение по умолчанию — <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Возвращает перечисляемую коллекцию имен каталогов, соответствующих шаблону поиска по указанному пути. Возможно, поиск ведется также и в подкаталогах.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для каталогов в каталоге, указанном в <paramref name="path" />, которые соответствуют заданному шаблону и параметрам поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ровно один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Можно указать относительный или абсолютный путь данные в `path` параметра. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога, который можно определить с помощью <xref:System.IO.Directory.GetCurrentDirectory%2A> метод. Возвращаемый имена имеют префикс со значением, введенным в `path` параметра. Например, если указать относительный путь в `path` параметр, возвращаемый имена будет содержать относительный путь.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> И <xref:System.IO.Directory.GetDirectories%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateDirectories%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetDirectories%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateDirectories%2A> может оказаться более эффективным.  
  
 Возвращаемая коллекция не помещен в кэш; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> коллекции начнет новое перечисление.  
  
   
  
## Examples  
 В следующем примере перечисление каталогов по указанному пути, соответствующих указанному шаблону поиска. Она использует `searchOption` параметр, чтобы указать, что все вложенные папки должны быть включены в поиск.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.  
  
-или- 
 <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает перечисляемую коллекцию имен файлов, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает перечисляемую коллекцию имен файлов, расположенных по указанному пути.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для файлов в каталоге, заданном параметром <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно указать относительный путь данные с `path` параметра. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога, который можно определить с помощью <xref:System.IO.Directory.GetCurrentDirectory%2A> метод.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> И <xref:System.IO.Directory.GetFiles%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFiles%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFiles%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 Возвращаемая коллекция не помещен в кэш; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> коллекции начнет новое перечисление.  
  
   
  
## Examples  
 В следующем примере показано, как для получения всех файлов в каталоге и переместите их в новый каталог. После перемещения файлов они больше не существуют в исходном каталоге.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 В следующем примере перечисляются файлы в указанном каталоге, считывает каждую строку файла и отображает строку, если он содержит строку «Европа».  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <summary>Возвращает перечисляемую коллекцию имен файлов, соответствующих шаблону поиска по указанному пути.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для файлов в каталоге, указанном в параметре <paramref name="path" />, которые соответствуют заданному шаблону поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
> [!NOTE]
>  При использовании символом-шаблоном звездочки в `searchPattern` такие как "\*.txt», число символов в указанное расширение влияет на поиск следующим образом:  
>   
> -   Если указанное расширение три символа, метод возвращает файлы с расширениями, которые начинаются с указанным расширением. Например "\*.xls» возвращает «book.xls» и «book.xlsx».  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанным расширением. Например "\*.ai» возвращает «file.ai», но не «file.aif».  
>   
>  Если используется подстановочный знак вопроса, этот метод возвращает только те файлы, которые соответствуют заданным расширением. Например, если в каталоге, шаблон поиска два файла: «file1.txt» и «file1.txtother», «файл?. TXT» возвращает только первый файл, а шаблон поиска «файл\*.txt» возвращает оба файла.  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Можно указать относительный путь данные с `path` параметра. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога, который можно определить с помощью <xref:System.IO.Directory.GetCurrentDirectory%2A> метод.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> И <xref:System.IO.Directory.GetFiles%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFiles%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFiles%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 Возвращаемая коллекция не помещен в кэш; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> коллекции начнет новое перечисление.  
  
   
  
## Examples  
 Приведенный ниже показано, как получить все текстовые файлы в каталоге и переместите их в новый каталог. После перемещения файлов они больше не существуют в исходном каталоге.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 В следующем примере перечисляются файлы в указанном каталоге с расширением .txt, считывает каждую строку файла и отображает строку, если он содержит строку «Европа».  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.  
  
-или- 
 <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах.  
  
Значение по умолчанию — <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Возвращает перечисляемую коллекцию имен файлов, соответствующих шаблону поиска по указанному пути. Возможно, поиск ведется также и в подкаталогах.</summary>
        <returns>Перечисляемая коллекция полных имен (включая пути) для файлов в каталоге, указанном в параметре <paramref name="path" />, которые соответствуют указанному шаблону и параметрам поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
> [!NOTE]
>  При использовании символом-шаблоном звездочки в `searchPattern` такие как "\*.txt», число символов в указанное расширение влияет на поиск следующим образом:  
>   
> -   Если указанное расширение три символа, метод возвращает файлы с расширениями, которые начинаются с указанным расширением. Например "\*.xls» возвращает «book.xls» и «book.xlsx».  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанным расширением. Например "\*.ai» возвращает «file.ai», но не «file.aif».  
>   
>  Если используется подстановочный знак вопроса, этот метод возвращает только те файлы, которые соответствуют заданным расширением. Например, если в каталоге, шаблон поиска два файла: «file1.txt» и «file1.txtother», «файл?. TXT» возвращает только первый файл, а шаблон поиска «файл\*.txt» возвращает оба файла.  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Можно указать относительный путь данные с `path` параметра. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога, который можно определить с помощью <xref:System.IO.Directory.GetCurrentDirectory%2A> метод.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> И <xref:System.IO.Directory.GetFiles%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFiles%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFiles%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 Возвращаемая коллекция не помещен в кэш; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> коллекции начнет новое перечисление.  
  
   
  
## Examples  
 В следующем примере показано, как получить все текстовые файлы в каталоге и его подкаталогах и переместите их в новый каталог. После перемещения файлов они больше не существует в исходных каталогов.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 В следующем примере рекурсивно перечисляются все файлы с расширением .txt, каждая строка файла считывается и отображается строка, если он содержит строку «Microsoft».  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.  
  
-или- 
 <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает перечисляемую коллекцию записей файловой системы, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает перечисляемую коллекцию имен файлов и имен каталогов по указанному пути.</summary>
        <returns>Перечисляемая коллекция записей файловой системы в каталоге, заданном параметром <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно указать относительный путь данные с `path` параметра. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога, который можно определить с помощью <xref:System.IO.Directory.GetCurrentDirectory%2A> метод.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> И <xref:System.IO.Directory.GetFileSystemEntries%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, можно запустить выполнение перечисления коллекции записей, перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>, необходимо дождаться весь массив записей, возвращаемых, прежде чем вы могли обращаться к массиву. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 Возвращаемая коллекция не помещен в кэш; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> коллекции начнет новое перечисление.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами в записях файловой системы, расположенными по пути <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <summary>Возвращает перечисляемую коллекцию имен файлов и имен каталогов по указанному пути, соответствующих шаблону поиска.</summary>
        <returns>Перечисляемая коллекция записей файловой системы в каталоге, заданном параметром <paramref name="path" />, которые соответствуют указанному шаблону поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`. 
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
> [!NOTE]
>  При использовании символом-шаблоном звездочки в `searchPattern` такие как "\*.txt», число символов в указанное расширение влияет на поиск следующим образом:  
>   
> -   Если указанное расширение три символа, метод возвращает файлы с расширениями, которые начинаются с указанным расширением. Например "\*.xls» возвращает «book.xls» и «book.xlsx».  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанным расширением. Например "\*.ai» возвращает «file.ai», но не «file.aif».  
>   
>  Если используется подстановочный знак вопроса, этот метод возвращает только те файлы, которые соответствуют заданным расширением. Например, если в каталоге, шаблон поиска два файла: «file1.txt» и «file1.txtother», «файл?. TXT» возвращает только первый файл, а шаблон поиска «файл\*.txt» возвращает оба файла.  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Можно указать относительный путь данные с `path` параметра. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога, который можно определить с помощью <xref:System.IO.Directory.GetCurrentDirectory%2A> метод.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> И <xref:System.IO.Directory.GetFileSystemEntries%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, можно запустить выполнение перечисления коллекции записей, перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>, необходимо дождаться весь массив записей, возвращаемых, прежде чем вы могли обращаться к массиву. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 Возвращаемая коллекция не помещен в кэш; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> коллекции начнет новое перечисление.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.  
  
-или- 
 <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с записями файловой системы, расположенными по пути <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах.  
  
Значение по умолчанию — <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Возвращает перечисляемую коллекцию записей файловой системы, соответствующих шаблону поиска по указанному пути. Возможно, поиск ведется также и в подкаталогах.</summary>
        <returns>Перечисляемая коллекция записей файловой системы в каталоге, указанном параметром <paramref name="path" />, который соответствует шаблону и параметру поиска.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
> [!NOTE]
>  При использовании символом-шаблоном звездочки в `searchPattern` такие как "\*.txt», число символов в указанное расширение влияет на поиск следующим образом:  
>   
> -   Если указанное расширение три символа, метод возвращает файлы с расширениями, которые начинаются с указанным расширением. Например "\*.xls» возвращает «book.xls» и «book.xlsx».  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанным расширением. Например "\*.ai» возвращает «file.ai», но не «file.aif».  
>   
>  Если используется подстановочный знак вопроса, этот метод возвращает только те файлы, которые соответствуют заданным расширением. Например, если в каталоге, шаблон поиска два файла: «file1.txt» и «file1.txtother», «файл?. TXT» возвращает только первый файл, а шаблон поиска «файл\*.txt» возвращает оба файла.  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Можно указать относительный путь данные с `path` параметра. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога, который можно определить с помощью <xref:System.IO.Directory.GetCurrentDirectory%2A> метод.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> И <xref:System.IO.Directory.GetFileSystemEntries%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, можно запустить выполнение перечисления коллекции записей, перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>, необходимо дождаться весь массив записей, возвращаемых, прежде чем вы могли обращаться к массиву. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 Возвращаемая коллекция не помещен в кэш; Каждый вызов <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> коллекции начнет новое перечисление.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.  
  
-или- 
 <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.Directory.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Проверяемый путь.</param>
        <summary>Определяет, указывает ли заданный путь на существующий каталог на диске.</summary>
        <returns><see langword="true" />, если <paramref name="path" /> ссылается на существующий каталог; значение <see langword="false" />, если каталог не существует или если при попытке определить, существует ли указанный каталог.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога.  
  
 Конечные пробелы удаляются из конца `path` параметра перед проверкой, существует ли каталог.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Если у вас нет с минимально необходимым разрешением только для чтения к каталогу, <xref:System.IO.Directory.Exists%2A> метод возвратит `false`.  
  
 <xref:System.IO.Directory.Exists%2A> Возвращает метод `false` при возникновении любой ошибки при попытке определить, существует ли указанный файл. Это может произойти в ситуации, которые вызывают исключения, например передачи имени файла с недопустимые символы или слишком много символов, со сбоем или отсутствует диск, или если вызывающий объект не имеет разрешения на чтение файла.  
  
   
  
## Examples  
 Следующий пример принимает массив имен файлов или каталогов в командной строке, определяет виды имя его и обрабатывает его соответствующим образом.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения файлов. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает список управления доступом Windows для каталога.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу, в котором содержится объект <see cref="T:System.Security.AccessControl.DirectorySecurity" />, описывающий сведения о списке управления доступом (ACL) для конкретного файла.</param>
        <summary>Получает объект <see cref="T:System.Security.AccessControl.DirectorySecurity" />, который инкапсулирует записи списка управления доступом (ACL) для заданного каталога.</summary>
        <returns>Объект, который инкапсулирует правила управления доступом для файла, описанные параметром <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.IO.Directory.GetAccessControl%2A> метод для извлечения записи списка управления Доступом для каталога.  
  
 В ACL определяются пользователи и группы, имеющие или не имеющие права на выполнение определенных действий для заданного файла или каталога. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 В средах NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> предоставляются пользователю, если пользователь имеет <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> права на родительскую папку. Чтобы запретить <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, запретить <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> в родительском каталоге.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.Directory.GetAccessControl%2A> и <xref:System.IO.Directory.SetAccessControl%2A> методы для добавления доступа запись списка управления Доступом управления и затем удаление элемента списка ACL из каталога.  Для выполнения этого примера необходимо указать допустимую учетную запись пользователя или группы.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">При открытии каталога возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows 2000 или более поздней версии.</exception>
        <exception cref="T:System.SystemException">Произошла ошибка системного уровня, например невозможно найти каталог. Конкретное исключение может быть подклассом <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Параметр <paramref name="path" /> указывает каталог, доступный только для чтения.  
  
-или- 
Эта операция не поддерживается на текущей платформе.  
  
-или- 
У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для разрешения на перечисление список управления доступом (ACL) для каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Действие по обеспечению безопасности: Запросу.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу, в котором содержится объект <see cref="T:System.Security.AccessControl.DirectorySecurity" />, описывающий сведения о списке управления доступом (ACL) для конкретного файла.</param>
        <param name="includeSections">Одно из значений <see cref="T:System.Security.AccessControl.AccessControlSections" />, указывающее тип сведений о списке ACL, которые необходимо получить.</param>
        <summary>Получает объект <see cref="T:System.Security.AccessControl.DirectorySecurity" />, который инкапсулирует записи списка управления доступом (ACL) указанного типа для заданного каталога.</summary>
        <returns>Объект, который инкапсулирует правила управления доступом для файла, описанные параметром <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.IO.Directory.GetAccessControl%2A> метод для извлечения записи списка управления Доступом для каталога.  
  
 В ACL определяются пользователи и группы, имеющие или не имеющие права на выполнение определенных действий для заданного файла или каталога. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 В средах NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> предоставляются пользователю, если пользователь имеет <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> права на родительскую папку. Чтобы запретить <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, запретить <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> в родительском каталоге.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">При открытии каталога возникла ошибка ввода-вывода.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows 2000 или более поздней версии.</exception>
        <exception cref="T:System.SystemException">Произошла ошибка системного уровня, например невозможно найти каталог. Конкретное исключение может быть подклассом <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Параметр <paramref name="path" /> указывает каталог, доступный только для чтения.  
  
-или- 
Эта операция не поддерживается на текущей платформе.  
  
-или- 
У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для разрешения на перечисление список управления доступом (ACL) для каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Действие по обеспечению безопасности: Запросу.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу.</param>
        <summary>Получает дату и время создания каталога.</summary>
        <returns>Структура, для которой заданы дата и время создания указанного каталога. Значение представляется в формате местного времени.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, так как он использует собственные функции, значения которых не будут обновляться постоянно операционной системой.  
  
 Этот метод эквивалентен <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Если каталог описано в разделе `path` параметр не существует, этот метод возвращает 12:00 (полночь), 1 января 1601 года н. э. (C.E.) Время (UTC), корректируется в местное время.  
  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Следующий пример получает время создания указанного каталога.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу.</param>
        <summary>Получает время и дату создания каталога в формате всемирного координированного времени (UTC).</summary>
        <returns>Структура, для которой заданы дата и время создания указанного каталога. Значение выражено в формате всемирного координированного времени (UTC).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, так как он использует собственные функции, значения которых не будут обновляться постоянно операционной системой.  
  
 Если каталог описано в разделе `path` параметр не существует, этот метод возвращает 12:00 (полночь), 1 января 1601 года н. э. (C.E.) Скоординированного времени (UTC).  
  
 Этот метод позволяет получить время создания каталога в формате UTC (UTC).  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате UTC (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDirectory : unit -&gt; string" Usage="System.IO.Directory.GetCurrentDirectory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает текущий рабочий каталог приложения.</summary>
        <returns>Строка, содержащая абсолютный путь к текущей рабочей папке без обратной косой черты (\\) в конце.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий каталог отличается от исходного каталога, из которого был запущен процесс.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показано использование метода `GetCurrentDirectory`.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.NotSupportedException">Операционной системой является Windows CE, которая не поддерживает функциональность текущего каталога.  
  
Этот метод доступен в .NET Compact Framework, но в настоящее время не поддерживается.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути для текущего каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает имена подкаталогов, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; string[]" Usage="System.IO.Directory.GetDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает имена подкаталогов (включая пути) в указанном каталоге.</summary>
        <returns>Массив полных имен (включая пути) подкаталогов по указанному пути или пустой массив, если каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод идентичен методу <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> символом «звездочка» (\*) указан в качестве шаблона поиска, поэтому он возвращает все подкаталоги. Если необходимо выполнить поиск в подкаталогах, используйте <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> метод, который позволяет указать поиск подкаталогов по `searchOption` параметр.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> И <xref:System.IO.Directory.GetDirectories%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateDirectories%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetDirectories%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateDirectories%2A> может оказаться более эффективным.  
  
 `path` Параметра можно указать относительный или абсолютный путь сведения. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Этот метод возвращает префикса directory сведений, предоставленных в `path`.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Следующий пример принимает массив имен файлов или каталогов в командной строке, определяет виды имя его и обрабатывает его соответствующим образом.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведения о пути для текущего каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами подкаталогов в <paramref name="path" />. Этот параметр может содержать сочетание допустимых литеральных и подстановочных символов, но не поддерживает регулярные выражения.</param>
        <summary>Возвращает имена подкаталогов (включая пути) в указанном каталоге, соответствующих указанному шаблону поиска.</summary>
        <returns>Массив полных имен (включая пути) подкаталогов в указанном каталоге, которые соответствуют указанному шаблону поиска, или пустой массив, если каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает все подкаталоги непосредственно в указанном каталоге, которые соответствуют указанному шаблону поиска. Если указанный каталог имеет вложенные каталоги, или нет подкаталогов, соответствующих `searchPattern` параметр, этот метод возвращает пустой массив. Только верхний каталог будет выполнен поиск. Если требуется найти и подкаталоги, используйте <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> метод и указать <xref:System.IO.SearchOption.AllDirectories> в `searchOption` параметра.  
  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 `path` Параметра можно указать относительный или абсолютный путь данные и не учитывает регистр.  Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> И <xref:System.IO.Directory.GetDirectories%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateDirectories%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetDirectories%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateDirectories%2A> может оказаться более эффективным.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере подсчитывается количество каталогов в пути, которые начинаются с указанного письма.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути для текущего каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами подкаталогов в <paramref name="path" />. Этот параметр может содержать сочетание допустимых литеральных и подстановочных символов, но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах.</param>
        <summary>Возвращает имена подкаталогов (включая пути) в указанном каталоге, соответствующих указанному шаблону поиска, и при необходимости ведет поиск в подкаталогах.</summary>
        <returns>Массив полных имен (включая пути) подкаталогов, соответствующих указанным критериям, или пустой массив, если каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Параметра можно указать относительный или абсолютный путь данные и не учитывает регистр. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> И <xref:System.IO.Directory.GetDirectories%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateDirectories%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetDirectories%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateDirectories%2A> может оказаться более эффективным.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере подсчитывается количество каталогов, начинающихся с указанного письма в пути. Каталог верхнего уровня будет выполнен поиск.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути для текущего каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryRoot : string -&gt; string" Usage="System.IO.Directory.GetDirectoryRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь к файлу или каталогу.</param>
        <summary>Возвращает для заданного пути сведения о томе и корневом каталоге по отдельности или сразу.</summary>
        <returns>Строка, в которой содержатся сведения о томе, корневом каталоге или одновременно сведения и о томе, и о корневом каталоге для заданного пути.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод получает полное имя `path`, возвращенная <xref:System.IO.Path.GetFullPath%2A>, и возвращает сведения о корневой папке. Указанный путь не обязательно должны существовать.  
  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере в качестве текущего каталога и отображения корневой каталог.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути для текущего каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает имена файлов, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; string[]" Usage="System.IO.Directory.GetFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает имена файлов (с указанием пути к ним) в указанном каталоге.</summary>
        <returns>Массив полных имен (включая пути) файлов в указанном каталоге или пустой массив, если файлы не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.EnumerateFiles%2A> И <xref:System.IO.Directory.GetFiles%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFiles%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFiles%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 Возвращаемые имена файлов, добавляются в предоставленный `path` параметра.  
  
 Этот метод идентичен методу <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> символом «звездочка» (\*), согласно шаблону поиска.  
  
 `path` Параметра можно указать относительный или абсолютный путь сведения. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Порядок возвращаемые имена файлов не гарантируется; Используйте <xref:System.Array.Sort%2A> метод, если требуется определенный порядок сортировки.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.IO.Directory.GetFiles%2A> метод для возврата имен файлов из места, определяемый пользователем. Конфигурация данного примера позволяет перехватывать все ошибки, характерные для этого метода.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.  
  
-или- 
Произошла сетевая ошибка.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный путь не найден или является недопустимым (например, ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути для текущего каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <summary>Возвращает имена файлов (включая пути) из указанного каталога, отвечающие условиям заданного шаблона поиска.</summary>
        <returns>Массив полных имен (включая пути) файлов в указанном каталоге, которые соответствуют указанному шаблону поиска, или пустой массив, если файлы не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемые имена файлов, добавляются в предоставленный `path` параметр и порядок возвращаемые имена файлов не гарантируется; используйте <xref:System.Array.Sort%2A> метод, если требуется определенный порядок сортировки.  
  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  При использовании символом-шаблоном звездочки в `searchPattern` такие как "\*.txt», число символов в указанное расширение влияет на поиск следующим образом:  
>   
> -   Если указанное расширение три символа, метод возвращает файлы с расширениями, которые начинаются с указанным расширением. Например "\*.xls» возвращает «book.xls» и «book.xlsx».  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанным расширением. Например "\*.ai» возвращает «file.ai», но не «file.aif».  
>   
>  Если используется подстановочный знак вопроса, этот метод возвращает только те файлы, которые соответствуют заданным расширением. Например, если в каталоге, шаблон поиска два файла: «file1.txt» и «file1.txtother», «файл?. TXT» возвращает только первый файл, а шаблон поиска «файл\*.txt» возвращает оба файла.  
  
> [!NOTE]
>  Шаблон, так как этот метод проверяет имена файлов с формат имени файла 8.3 и формат имени файла, аналогичную поиска "\*1\*.txt» может вернуть неожиданные имена файлов. Например, используя шаблон поиска "\*1\*.txt» возвращает «longfilename.txt», так как файла имя в формате 8.3 будет иметь вид «LONGFI~1.TXT».  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> И <xref:System.IO.Directory.GetFiles%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFiles%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFiles%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 `path` Параметра можно указать относительный или абсолютный путь сведения. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере подсчитывается количество файлов, которые начинаются с указанного письма.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.  
  
-или- 
Произошла сетевая ошибка.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный путь не найден или является недопустимым (например, ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути для текущего каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах.</param>
        <summary>Возвращает имена файлов (включая пути) в заданном каталоге, отвечающие условиям шаблона поиска, используя значение, которое определяет, выполнять ли поиск в подкаталогах.</summary>
        <returns>Массив полных имен (включая пути) файлов в указанном каталоге, которые соответствуют указанному шаблону и параметру поиска, или пустой массив, если файлы не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемые имена файлов, добавляются к предоставленным параметром `path` и порядок возвращаемые имена файлов не гарантируется; используйте <xref:System.Array.Sort%2A> метод, если требуется определенный порядок сортировки.  
  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  При использовании символом-шаблоном звездочки в `searchPattern` такие как "\*.txt», число символов в указанное расширение влияет на поиск следующим образом:  
>   
> -   Если указанное расширение три символа, метод возвращает файлы с расширениями, которые начинаются с указанным расширением. Например "\*.xls» возвращает «book.xls» и «book.xlsx».  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанным расширением. Например "\*.ai» возвращает «file.ai», но не «file.aif».  
>   
>  Если используется подстановочный знак вопроса, этот метод возвращает только те файлы, которые соответствуют заданным расширением. Например, если в каталоге, шаблон поиска два файла: «file1.txt» и «file1.txtother», «файл?. TXT» возвращает только первый файл, а шаблон поиска «file*.txt» возвращает оба файла.  
  
> [!NOTE]
>  Шаблон, так как этот метод проверяет имена файлов с формат имени файла 8.3 и формат имени файла, аналогичную поиска "\*1\*.txt» может вернуть неожиданные имена файлов. Например, используя шаблон поиска "\*1\*.txt» возвращает «longfilename.txt», так как файла имя в формате 8.3 будет иметь вид «LONGFI~1.TXT».  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> И <xref:System.IO.Directory.GetFiles%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFiles%2A>, можно запустить выполнение перечисления коллекции имен перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFiles%2A>, необходимо дождаться весь массив имен возвращается, чтобы можно было открыть массива. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 Имена файлов включают полный путь.  
  
 `path` Параметра можно указать относительный или абсолютный путь сведения. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchpattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный путь не найден или является недопустимым (например, ведет на несопоставленный диск).</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.  
  
-или- 
Произошла сетевая ошибка.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути для текущего каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает имена всех файлов и подкаталогов, соответствующих указанным критериям.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <summary>Возвращает имена всех файлов и подкаталогов по указанному пути.</summary>
        <returns>Массив имен файлов и подкаталогов в указанном каталоге или пустой массив, если файлы или подкаталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок возвращенного файла и имена каталогов не гарантируется; Используйте <xref:System.Array.Sort%2A> метод, если требуется определенный порядок сортировки.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> И <xref:System.IO.Directory.GetFileSystemEntries%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, можно запустить выполнение перечисления коллекции записей, перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>, необходимо дождаться весь массив записей, возвращаемых, прежде чем вы могли обращаться к массиву. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 Этот метод идентичен методу <xref:System.IO.Directory.GetFileSystemEntries%2A> символом «звездочка» (\*), согласно шаблону поиска.  
  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.Directory.GetFileSystemEntries%2A> метод для заполнения массива строк с именами всех файлов и подкаталогов в расположении, указанном пользователем и печатает каждая строка в массиве в консоль. Конфигурация данного примера позволяет перехватывать все ошибки, характерные для этого метода.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути для текущего каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая будет сравниваться с именами файла и каталогов в <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <summary>Возвращает массив имен файлов и имен каталогов по указанному пути, соответствующих шаблону поиска.</summary>
        <returns>Массив имен файлов и имен каталогов, соответствующих указанным критериям поиска, или пустой массив, если файлы или каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок возвращенного файла и имена каталогов не гарантируется; Используйте <xref:System.Array.Sort%2A> метод, если требуется определенный порядок сортировки.  
  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  При использовании символом-шаблоном звездочки в `searchPattern` такие как "\*.txt», число символов в указанное расширение влияет на поиск следующим образом:  
>   
> -   Если указанное расширение три символа, метод возвращает файлы с расширениями, которые начинаются с указанным расширением. Например "\*.xls» возвращает «book.xls» и «book.xlsx».  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанным расширением. Например "\*.ai» возвращает «file.ai», но не «file.aif».  
>   
>  Если используется подстановочный знак вопроса, этот метод возвращает только те файлы, которые соответствуют заданным расширением. Например, если в каталоге, шаблон поиска два файла: «file1.txt» и «file1.txtother», «файл?. TXT» возвращает только первый файл, а шаблон поиска «файл\*.txt» возвращает оба файла.  
  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.Directory.GetFileSystemEntries%2A> метод для заполнения массива строк с именами всех файлов, соответствующих фильтру, определяемое пользователем, в определенном расположении и печатает каждой строки в массиве на консоль. Конфигурация данного примера позволяет перехватывать все ошибки, характерные для этого метода.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="path" /> или <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о пути для текущего каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Относительный или абсолютный путь к каталогу для поиска. В этой строке не учитывается регистр знаков.</param>
        <param name="searchPattern">Строка поиска, которая должна сравниваться с именами файлов и каталогов в параметре <paramref name="path" />.  Этот параметр может содержать сочетание допустимого литерального пути и подстановочного символа (* и ?), но не поддерживает регулярные выражения.</param>
        <param name="searchOption">Одно из значений перечисления, определяющее, следует ли выполнять поиск только в текущем каталоге или также во всех его подкаталогах.  
  
Значение по умолчанию — <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Возвращает массив всех имен файлов и каталогов по указанному пути, соответствующих шаблону поиска, и при необходимости ведет поиск в подкаталогах.</summary>
        <returns>Массив имен файлов и имен каталогов, соответствующих указанным критериям поиска, или пустой массив, если файлы или каталоги не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок возвращенного файла и имена каталогов не гарантируется; Используйте <xref:System.Array.Sort%2A> метод, если требуется определенный порядок сортировки.  
  
 `searchPattern` может представлять собой сочетание литеральных и подстановочных символов, но он не поддерживает регулярные выражения. Следующие спецификаторы подстановочных знаков, разрешены в `searchPattern`.  
  
|Описатель подстановочный знак|Число соответствий|  
|------------------------|-------------|  
|\* (звездочка)|Ноль или более символов в этой позиции.|  
|? (вопросительный знак)|Ноль или один символ в этой позиции.|  
  
 Символы, отличные от подстановочный знак — символы литералов. Например `searchPattern` строку "\*t» выполняет поиск всех имен `path` оканчивающихся буквой «t». `searchPattern` Строку «s\*"выполняет поиск всех имен `path` начинающиеся с буквы «s».  
  
 `searchPattern` не может заканчиваться двумя точками ("..») или содержать две точки ("..») за которым следует <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>, не может содержать недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  При использовании символом-шаблоном звездочки в `searchPattern` такие как "\*.txt», число символов в указанное расширение влияет на поиск следующим образом:  
>   
> -   Если указанное расширение три символа, метод возвращает файлы с расширениями, которые начинаются с указанным расширением. Например "\*.xls» возвращает «book.xls» и «book.xlsx».  
> -   Во всех остальных случаях метод возвращает файлы, которые точно соответствуют указанным расширением. Например "\*.ai» возвращает «file.ai», но не «file.aif».  
>   
>  Если используется подстановочный знак вопроса, этот метод возвращает только те файлы, которые соответствуют заданным расширением. Например, если в каталоге, шаблон поиска два файла: «file1.txt» и «file1.txtother», «файл?. TXT» возвращает только первый файл, а шаблон поиска «файл\*.txt» возвращает оба файла.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> И <xref:System.IO.Directory.GetFileSystemEntries%2A> методы имеют следующие различия: При использовании <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, можно запустить выполнение перечисления коллекции записей, перед возвращением всей коллекции; при использовании <xref:System.IO.Directory.GetFileSystemEntries%2A>, необходимо дождаться весь массив записей, возвращаемых, прежде чем вы могли обращаться к массиву. Таким образом, при работе с много файлов и папок, <xref:System.IO.Directory.EnumerateFiles%2A> может оказаться более эффективным.  
  
 Можно указать относительный путь данные с `path` параметра. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога, который можно определить с помощью <xref:System.IO.Directory.GetCurrentDirectory%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, строку, содержащую только пробел, или строку, содержащую недопустимые символы. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-или- 
 <paramref name="searchPattern" /> не содержит допустимый шаблон.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.  
  
-или- 
 <paramref name="searchPattern" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> не является допустимым значением <see cref="T:System.IO.SearchOption" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Недопустимый <paramref name="path" />: например, он ссылается на несопоставленный диск.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> — это имя файла.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или их комбинация превышает максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, информацию о дате и времени обращения к которому следует получить.</param>
        <summary>Возвращает время и дату последнего обращения к указанному файлу или каталогу.</summary>
        <returns>Структура, для которой заданы дата и время последнего доступа к указанному файлу или каталогу. Значение представляется в формате местного времени.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, так как он использует собственные функции, значения которых не будут обновляться постоянно операционной системой.  
  
 Этот метод идентичен методу <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Если каталог описано в разделе `path` параметр не существует, этот метод возвращает 12:00 (полночь), 1 января 1601 года н. э. (C.E.) Время (UTC), корректируется в местное время.  
  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Параметр <paramref name="path" /> имеет недопустимый формат.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, информацию о дате и времени обращения к которому следует получить.</param>
        <summary>Возвращает дату и время последнего доступа к заданному файлу или каталогу в формате всемирного координированного времени (UTC).</summary>
        <returns>Структура, для которой заданы дата и время последнего доступа к указанному файлу или каталогу. Значение выражено в формате всемирного координированного времени (UTC).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, так как он использует собственные функции, значения которых не будут обновляться постоянно операционной системой.  
  
 Если каталог описано в разделе `path` параметр не существует, этот метод возвращает 12:00 (полночь), 1 января 1601 года н. э. (C.E.) Скоординированного времени (UTC).  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате UTC (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.NotSupportedException">Параметр <paramref name="path" /> имеет недопустимый формат.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, дату и время изменения которого следует получить.</param>
        <summary>Возвращает время и дату последней операции записи в указанный файл или каталог.</summary>
        <returns>Структура, для которой заданы дата и время последней операции записи в указанный файл или каталог. Значение представляется в формате местного времени.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, так как он использует собственные функции, значения которых не будут обновляться постоянно операционной системой.  
  
 Если каталог описано в разделе `path` параметр не существует, этот метод возвращает 12:00 (полночь), 1 января 1601 года н. э. (C.E.) Время (UTC), корректируется в местное время.  
  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, дату и время изменения которого следует получить.</param>
        <summary>Возвращает дату и время последней операции записи в заданный файл или каталог в формате всемирного координированного времени (UTC).</summary>
        <returns>Структура, для которой заданы дата и время последней операции записи в указанный файл или каталог. Значение выражено в формате всемирного координированного времени (UTC).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот метод может возвращать неточное значение, так как он использует собственные функции, значения которых не будут обновляться постоянно операционной системой.  
  
 Если каталог описано в разделе `path` параметр не существует, этот метод возвращает 12:00 (полночь), 1 января 1601 года н. э. (C.E.) Скоординированного времени (UTC).  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате UTC (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения указанного файла или каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.IO.Directory.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает имена логических дисков данного компьютера в формате "&lt;буква диска&gt;:\\".</summary>
        <returns>Логические устройства данного компьютера.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives возвращает все устройства, доступные на конкретном компьютере, включая дисковода гибких дисков или оптических дисков.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.Directory.GetLogicalDrives%2A> метод назначения имя каждого диска на компьютере, вызывающий массив строк. Затем каждый член массива строк выводится на консоль. Конфигурация данного примера позволяет перехватывать все ошибки, характерные для этого метода.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Произошла ошибка ввода-вывода (например, ошибка диска).</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода, например вызов машинного кода с помощью PInvoke или COM-взаимодействия. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParent : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.GetParent path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь, для которого необходимо извлечь родительский каталог.</param>
        <summary>Извлекает родительский каталог, на который указывает абсолютный или относительный путь.</summary>
        <returns>Родительский каталог или значение <see langword="null" />, если <paramref name="path" /> является корневым каталогом, в том числе корнем сервера UNC или именем общего ресурса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Параметра можно указать относительный или абсолютный путь сведения. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Конечные пробелы удаляются из конца `path` перед получение каталога.  
  
 Строка, возвращаемая этим методом состоит из всех знаков в путь до, но не включая, последний <xref:System.IO.Path.DirectorySeparatorChar> или <xref:System.IO.Path.AltDirectorySeparatorChar>. Например, передав путь «C:\Directory\SubDirectory\test.txt» <xref:System.IO.Directory.GetParent%2A> возвращает «C:\Directory\SubDirectory». Передача «C:\Directory\SubDirectory» возвращает «C:\Directory». Тем не менее, передав «C:\Directory\SubDirectory\\"возвращает «C:\Directory\SubDirectory», так как конечный разделитель каталогов после «Подкаталог».  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.IO.Directory.GetParent%2A> метод для извлечения родительский каталог создаваемого расположении, указанном пользователем, «путь». Значение, возвращенное <xref:System.IO.Directory.GetParent%2A> метод выводятся на консоль. Конфигурация данного примера позволяет перехватывать все ошибки, характерные для этого метода.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Каталог, заданный параметром <paramref name="path" />, доступен только для чтения.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе. Дополнительные сведения см. в разделе <see cref="T:System.IO.PathTooLongException" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.NotSupportedException">Параметр <paramref name="path" /> задан в недопустимом формате.</exception>
        <exception cref="T:System.Security.SecurityException">Только .NET Framework: У вызывающего объекта отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения из файлов или каталогов. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.Directory.Move (sourceDirName, destDirName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Путь к файлу или каталогу, который необходимо переместить.</param>
        <param name="destDirName">Путь к новому местоположению <paramref name="sourceDirName" />. Если <paramref name="sourceDirName" /> является файлом, то параметр <paramref name="destDirName" /> также должен быть именем файла.</param>
        <summary>Перемещает файл или каталог со всем его содержимым в новое местоположение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает новый каталог с именем, указанным `destDirName` и перемещает содержимое `sourceDirName` на только что созданный целевой каталог. При попытке переместить каталог в каталог, который уже существует, <xref:System.IO.IOException> произойдет. Например если вы пытаетесь переместить c:\mydir в c:\public, и c:\public уже существует, возникает исключение. Кроме того, можно указать «c:\\\public\\\mydir» как `destDirName` параметром, указано, что «mydir» не существует в «c:\\\public», или укажите новое имя каталога, например «c:\\\newdir».  
  
 `sourceDirName` И `destDirName` могут содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Конечные пробелы удаляются из конца параметры пути, прежде чем перейти в каталог.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Ниже приведен пример, как переместить каталог и все его файлы в новый каталог. Исходный каталог не существует, после его перемещения.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Была предпринята попытка переместить каталог в другой том.  
  
-или- 
 <paramref name="destDirName" /> уже существует.  
  
-или- 
Параметры <paramref name="sourceDirName" /> и <paramref name="destDirName" /> указывают на один и тот же файл или каталог.  
  
-или- 
Каталог или находящийся в нем файл используется другим процессом.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirName" /> или <paramref name="destDirName" /> представляет собой строку нулевой длины, строку, содержащую только пробелы, или строку, содержащую один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="sourceDirName" /> или <paramref name="destDirName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Путь, указанный <paramref name="sourceDirName" />, является недопустимым (например, он ведет на несопоставленный диск).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения данных из <paramref name="sourceDirName" /> и запись <paramref name="sourceDirName" /> и <paramref name="destDirName" />. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="System.IO.Directory.SetAccessControl (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Каталог, в который необходимо добавить или из которого нужно удалить записи списка управления доступом.</param>
        <param name="directorySecurity">Объект <see cref="T:System.Security.AccessControl.DirectorySecurity" />, описывающий запись ACL, которую требуется применить к каталогу, описанному параметром <paramref name="path" />.</param>
        <summary>Применяет к заданному каталогу записи списка управления доступом (ACL), описанные объектом <see cref="T:System.Security.AccessControl.DirectorySecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.SetAccessControl%2A> Метод применяет записи списка управления Доступом для управления доступом к файлу, который представляет noninherited список ACL.  
  
> [!CAUTION]
>  Указанный список ACL для `directorySecurity` параметр заменяет существующий список ACL для каталога. Чтобы добавить разрешения для нового пользователя, используйте <xref:System.IO.Directory.GetAccessControl%2A> способ получить существующий список ACL и изменить его.  
  
 В ACL определяются пользователи и группы, имеющие или не имеющие права на выполнение определенных действий для заданного файла или каталога. Дополнительные сведения см. в разделе [Практическое руководство. Добавление или удаление записей списка управления доступом](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 <xref:System.IO.Directory.SetAccessControl%2A> Метод сохраняет только <xref:System.Security.AccessControl.DirectorySecurity> объекты, которые были изменены после создания объекта.  Если <xref:System.Security.AccessControl.DirectorySecurity> объект не был изменен, не будут сохранены в файл.  Таким образом, он уже не сможете получить <xref:System.Security.AccessControl.DirectorySecurity> объекта из одного файла и повторно примените тот же объект в другой файл.  
  
 Чтобы скопировать данные ACL из одного файла в другой:  
  
1.  Используйте <xref:System.IO.Directory.GetAccessControl%2A> метод для извлечения <xref:System.Security.AccessControl.DirectorySecurity> объекта из исходного файла.  
  
2.  Создайте новый <xref:System.Security.AccessControl.DirectorySecurity> объекта для целевого файла.  
  
3.  Используйте <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> или <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> метод источника <xref:System.Security.AccessControl.DirectorySecurity> объекта, чтобы получить сведения о ACL.  
  
4.  Используйте <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> или <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> метод для копирования данных, полученных на шаге 3 в место назначения <xref:System.Security.AccessControl.DirectorySecurity> объекта.  
  
5.  Задайте на конечном <xref:System.Security.AccessControl.DirectorySecurity> объекта к целевому файлу с помощью <xref:System.IO.Directory.SetAccessControl%2A> метод.  
  
 В средах NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> предоставляются пользователю, если пользователь имеет <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> права на родительскую папку. Чтобы запретить <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> и <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, запретить <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> в родительском каталоге.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.Directory.GetAccessControl%2A> и <xref:System.IO.Directory.SetAccessControl%2A> методы для добавления доступа запись списка управления Доступом управления и затем удаление элемента списка ACL из каталога.  Для выполнения этого примера необходимо указать допустимую учетную запись пользователя или группы.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="directorySecurity" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Не удается найти каталог.</exception>
        <exception cref="T:System.ArgumentException">Задан недопустимый <paramref name="path" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Текущий процесс не может получить доступ к каталогу, заданному <paramref name="path" />.  
  
-или- 
Текущий процесс не имеет необходимых прав для задания записи ACL.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows 2000 или более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для разрешения на перечисление список управления доступом (ACL) для каталога. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Действие по обеспечению безопасности: Запросу.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, для которого требуется установить дату и время создания.</param>
        <param name="creationTime">Дата и время последней записи в файл или каталог. Значение представляется в формате местного времени.</param>
        <summary>Устанавливает дату и время создания заданного файла или каталога.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате UTC (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, для которого требуется установить дату и время создания.</param>
        <param name="creationTimeUtc">Дата и время создания каталога или файла. Значение представляется в формате местного времени.</param>
        <summary>Устанавливает дату и время создания указанного файла или папки в формате всемирного координированного времени (UTC).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member SetCurrentDirectory : string -&gt; unit" Usage="System.IO.Directory.SetCurrentDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь, который должен быть назначен рабочему каталогу.</param>
        <summary>Устанавливает заданный каталог в качестве текущего рабочего каталога приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда приложение завершает работу, рабочий каталог восстанавливается в исходное расположение (каталог, где был запущен процесс).  
  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Конечные пробелы удаляются из конца `path` параметра перед настройкой каталога.  
  
 `path` Параметр не чувствителен к регистру.  
  
 При установке каталог на диске со съемного носителя (например, «E:» для ФЛЭШ-накопитель USB), можно определить, готов ли диск с помощью <xref:System.IO.DriveInfo.IsReady%2A> свойство.  
  
   
  
## Examples  
 В следующем примере в качестве текущего каталога и отображения корневой каталог.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для доступа к неуправляемому коду.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указанный каталог не найден.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в файлы или каталоги. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, для которого требуется установить дату и время доступа.</param>
        <param name="lastAccessTime">Объект, содержащий значение, которое необходимо присвоить дате и времени доступа к <paramref name="path" />. Значение представляется в формате местного времени.</param>
        <summary>Устанавливает время и дату последнего обращения к заданному файлу или каталогу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTime" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Файл или каталог, для которого требуется установить дату и время доступа.</param>
        <param name="lastAccessTimeUtc">Объект, содержащий значение, которое необходимо присвоить дате и времени доступа к <paramref name="path" />. Значение выражено в формате всемирного координированного времени (UTC).</param>
        <summary>Устанавливает дату и время последнего доступа к заданному файлу или каталогу в формате всемирного координированного времени (UTC).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате UTC (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Указанный путь не найден.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTimeUtc" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу.</param>
        <param name="lastWriteTime">Дата и время последней записи в файл или каталог. Значение представляется в формате местного времени.</param>
        <summary>Устанавливает дату и время последней записи в файл или каталог.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Параметр <paramref name="path" /> не найден (например, каталог не существует или находится на несопоставленном диске).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Параметр <paramref name="path" /> не найден (например, каталог не существует или находится на несопоставленном диске).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTime" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Путь к каталогу.</param>
        <param name="lastWriteTimeUtc">Дата и время последней записи в файл или каталог. Значение выражено в формате всемирного координированного времени (UTC).</param>
        <summary>Устанавливает дату и время последней записи в заданный каталог в формате всемирного координированного времени (UTC).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Параметр может содержать относительный или абсолютный путь. Сведения о относительный путь интерпретируется относительно текущего рабочего каталога. Чтобы получить текущий рабочий каталог, см. в разделе <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Параметр не чувствителен к регистру.  
  
 Список задач ввода-вывода, см. в разделе [распространенные задачи ввода-вывода](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 В следующем примере показаны различия в выходных данных при использовании выходных данных в формате UTC (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Параметр <paramref name="path" /> не найден (например, каталог не существует или находится на несопоставленном диске).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Параметр <paramref name="path" /> не найден (например, каталог не существует или находится на несопоставленном диске).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов. Вы можете запросить недопустимые символы с помощью метода <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.UnauthorizedAccessException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая операционная система не является системой Windows NT или более поздней версии.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTimeUtc" /> указывает значение вне диапазона дат или времени, разрешенного для операции.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для записи в указанный файл или каталог. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Файловый и потоковый ввод-вывод</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Практическое руководство. Считывание текста из файла</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Практическое руководство. Запись текста в файл</related>
      </Docs>
    </Member>
  </Members>
</Type>