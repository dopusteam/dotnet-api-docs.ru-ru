<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="934f06896ded78a1be250bb2062ad8017ce8cb49" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58462103" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>В модуле <see langword="FileSystem" /> содержатся процедуры, используемые для выполнения операций с файлами, папками или каталогами и системой. Возможность <see langword="My" /> обеспечивает улучшенные производительность и быстродействие в операциях файлового ввода-вывода по сравнению с модулем <see langword="FileSystem" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот модуль поддерживает ключевые слова языка Visual Basic и элементы библиотеки времени выполнения, с доступом к файлам и папкам.  
  
   
  
## Examples  
 В этом примере используется `GetAttr` функцию, чтобы определить атрибуты файла, каталога или папки.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">Сводка по каталогам и файлам</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">Сводка по вводу и выводу</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Ключевые слова (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Члены библиотеки времени выполнения Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Обязательный. Строковое выражение, определяющее, какая папка или каталог становятся новым каталогом или папкой по умолчанию. Параметр <paramref name="Path" /> может содержать метку диска. Если диск не указан, функция <see langword="ChDir" /> меняет каталог или папку по умолчанию на текущем диске.</param>
        <summary>Изменяет текущую папку или каталог. Возможность <see langword="My" /> обеспечивает улучшенные производительность и быстродействие операций файлового ввода-вывода по сравнению с функциями <see langword="ChDir" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir` Функция меняет каталог по умолчанию, но не диск по умолчанию. Например, если по умолчанию это диск C, следующая инструкция изменяет каталог по умолчанию на диске D, но C остается диском по умолчанию:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Может быть сделан относительным изменения каталога является путем ввода двух точек, следующим образом:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir` Функция требует разрешение неуправляемого кода, что может повлиять на выполнение в ситуациях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и.  
  
   
  
## Examples  
 В этом примере используется `ChDir` функции для изменения текущего каталога или папки.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="Path" /> пуст.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Указан несуществующий диск или диск недоступен.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Практическое руководство. Анализ путей к файлам в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Создание, удаление и перемещение файлов и папок в Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Изменяет текущий диск.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Обязательный. Строковое выражение, задающее существующий диск. Если указать пустую строку (""), текущий диск не изменится. Если аргумент <paramref name="Drive" /> содержит строку из нескольких знаков, функция <see langword="ChDrive" /> использует только первую букву.</param>
        <summary>Изменяет текущий диск.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Функция требует разрешение неуправляемого кода, которое может повлиять на выполнение в ситуациях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и [разрешений доступа к коду](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В этом примере используется `ChDrive` функции, чтобы изменить текущий диск. Функция создает исключение, если диск не существует.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Указан несуществующий диск или диск недоступен.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Обязательный. Строковое выражение, задающее существующий диск. Если указать пустую строку (""), текущий диск не изменится. Если аргумент <paramref name="Drive" /> содержит строку из нескольких знаков, функция <see langword="ChDrive" /> использует только первую букву.</param>
        <summary>Изменяет текущий диск.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Функция требует разрешение неуправляемого кода, которое может повлиять на выполнение в ситуациях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission> и [разрешений доступа к коду](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 В этом примере используется `ChDrive` функции, чтобы изменить текущий диск. Функция создает исключение, если диск не существует.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Указан несуществующий диск или диск недоступен.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строку, представляющую текущий путь. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> предоставляет большую производительность и быстродействие в операциях файлового ввода-вывода по сравнению с функцией <see langword="CurDir" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строку, представляющую текущий путь. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> предоставляет большую производительность и быстродействие в операциях файлового ввода-вывода по сравнению с функцией <see langword="CurDir" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Строка, представляющая текущий путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере используется `CurDir` функция возвращает текущий путь.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Необязательный параметр. Выражение типа <see langword="Char" />, задающее существующий диск. Если диск не указан или параметр <paramref name="Drive" /> является пустой строкой (""), функция <see langword="CurDir" /> возвращает путь для текущего диска.</param>
        <summary>Возвращает строку, представляющую текущий путь. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> предоставляет большую производительность и быстродействие в операциях файлового ввода-вывода по сравнению с функцией <see langword="CurDir" />. Дополнительные сведения см. в разделе <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Строка, представляющая текущий путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере используется `CurDir` функция возвращает текущий путь.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строку, представляющую имя файла, каталога или папки, соответствующую указанному шаблону, атрибуту файла или метке тома диска. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> обеспечивает большие показатели производительности и быстродействия операций файлового ввода-вывода, чем функция <see langword="Dir" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строку, представляющую имя файла, каталога или папки, соответствующую указанному шаблону, атрибуту файла или метке тома диска. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> обеспечивает большие показатели производительности и быстродействия операций файлового ввода-вывода, чем функция <see langword="Dir" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Строка, представляющая имя файла, каталога или папки, соответствующее указанному шаблону, атрибуту файла или метке тома на диске.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` Функция поддерживает использование нескольких знаков (`*`) и одиночные (`?`) можно указать несколько файлов.  
  
 `VbVolume` Возвращает метку тома для диска, а не имя файла.  
  
 Необходимо указать `PathName` при первом вызове `Dir` функции. Для получения следующего элемента, может выполнять последующие вызовы `Dir` функции без параметров.  
  
> [!IMPORTANT]
>  Для корректной, `Dir` функции требуется <xref:System.Security.Permissions.FileIOPermissionAccess.Read> и <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> флаги из <xref:System.Security.Permissions.FileIOPermission> должны быть предоставлены для исполняемого кода. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, и [разрешений доступа к коду](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 `Attributes` Используются значения перечисления аргументов следующим образом:  
  
|Значение|Константа|Описание|  
|-|-|-|  
|`Normal`|`vbnormal`|По умолчанию. Указывает файлы без атрибутов.|  
|`ReadOnly`|`vbReadOnly`|Указывает файлы, доступные только для чтения, а также файлы без атрибутов.|  
|`Hidden`|`vbHidden`|Задает скрытые файлы, а также файлы без атрибутов.|  
|`System`|`vbSystem`|Указывает, системные файлы и файлы без атрибутов.|  
|`Volume`|`vbVolume`|Указывает метку тома. Если любой другой атрибут указан, `vbVolume` учитывается.|  
|`Directory`|`vbDirectory`|Указывает каталоги или папки, а также файлы без атрибутов.|  
|`Archive`|`vbArchive`|Файл был изменен с момента создания последней резервной копии.|  
|`Alias`|`vbAlias`|У файла другое имя.|  
  
> [!NOTE]
>  Эти перечисления указаны в языке Visual Basic и может использоваться в любом месте в коде вместо фактических значений.  
  
   
  
## Examples  
 В этом примере используется `Dir` функция для проверки существования определенных файлов и каталогов.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Необязательный параметр. Строковое выражение, задающее имя файла, имя каталога или папки, либо метку тома диска. Если параметр <paramref name="PathName" /> не обнаруживается, возвращается строка нулевой длины (<see langword="&quot;&quot;" />).</param>
        <param name="Pathname">Необязательный параметр. Строковое выражение, задающее имя файла, имя каталога или папки, либо метку тома диска. Если параметр <paramref name="Pathname" /> не обнаруживается, возвращается строка нулевой длины (<see langword="&quot;&quot;" />).</param>
        <param name="Attributes">Необязательный параметр. Перечисление или числовое выражение, значение которого задает атрибуты файла. Если этот параметр опущен, функция <see langword="Dir" /> возвращает файлы, соответствующие параметру <paramref name="Pathname" />, но не имеющие атрибутов.</param>
        <summary>Возвращает строку, представляющую имя файла, каталога или папки, соответствующую указанному шаблону, атрибуту файла или метке тома диска. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> обеспечивает большие показатели производительности и быстродействия операций файлового ввода-вывода, чем функция <see langword="Dir" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Строка, представляющая имя файла, каталога или папки, соответствующее указанному шаблону, атрибуту файла или метке тома на диске.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` Функция поддерживает использование нескольких знаков (`*`) и одиночные (`?`) можно указать несколько файлов.  
  
 `VbVolume` Возвращает метку тома для диска, а не имя файла.  
  
 Необходимо указать `PathName` при первом вызове `Dir` функции. Для получения следующего элемента, может выполнять последующие вызовы `Dir` функции без параметров.  
  
> [!IMPORTANT]
>  Для корректной, `Dir` функции требуется <xref:System.Security.Permissions.FileIOPermissionAccess.Read> и <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> флаги из <xref:System.Security.Permissions.FileIOPermission> должны быть предоставлены для исполняемого кода. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, и [разрешений доступа к коду](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 `Attributes` Используются значения перечисления аргументов следующим образом:  
  
|Значение|Константа|Описание|  
|-|-|-|  
|`Normal`|`vbnormal`|По умолчанию. Указывает файлы, не имеющие атрибутов.|  
|`ReadOnly`|`vbReadOnly`|Указывает файлы только для чтения, в дополнение к файлам без атрибутов.|  
|`Hidden`|`vbHidden`|Задает скрытые файлы, в дополнение к файлам без атрибутов.|  
|`System`|`vbSystem`|Определяет системные файлы, кроме файлов, не имеющие атрибутов.|  
|`Volume`|`vbVolume`|Указывает метку тома. Если любой другой атрибут указан, `vbVolume` учитывается.|  
|`Directory`|`vbDirectory`|Указывает каталоги или папки в дополнение к файлам без атрибутов.|  
|`Archive`|`vbArchive`|Файл был изменен с момента создания последней резервной копии.|  
|`Alias`|`vbAlias`|У файла другое имя.|  
  
> [!NOTE]
>  Эти перечисления указаны в языке Visual Basic и может использоваться в любом месте кода вместо фактических значений.  
  
   
  
## Examples  
 В этом примере используется `Dir` функция для проверки существования определенных файлов и каталогов.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Значение <see langword="Integer" />, содержащее любой допустимый номер файла.</param>
        <summary>Возвращает логическое значение <see langword="True" /> при достижении конца файла, открытого в режиме <see langword="Random" /> или в режиме последовательного ввода (<see langword="Input" />).</summary>
        <returns>Логическое значение <see langword="True" /> при достижении конца файла, открытого в режиме <see langword="Random" /> или в режиме последовательного ввода (<see langword="Input" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `EOF` во избежание ошибки, возникшей при попытке получить данные за пределами файла.  
  
 `EOF` Возвращает `False` пока не будет достигнут конец файла. В файлах, открытых для `Random` или `Binary` доступ, `EOF` возвращает `False` до последнего выполненного `FileGet` функции не удалось прочитать запись целиком.  
  
 В файлах, открытых для `Binary` получить доступ к, попытка прочитать файл с помощью `Input` функционировать до `EOF` возвращает `True` приводит к ошибке. Используйте `LOF` и `Loc` функции вместо `EOF` при чтении двоичных файлов с `Input`, или использовать `Get` при использовании `EOF` функции. В файлах, открытых для `Output`, `EOF` всегда возвращает `True`.  
  
   
  
## Examples  
 В этом примере используется `EOF` функции, чтобы определить конец файла. В этом примере предполагается, что `Testfile` — текстовый файл, который содержит несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. <see langword="Integer" />. Любой допустимый номер файла.</param>
        <summary>Возвращает перечисление, представляющее режим файла для файлов, открытых функцией <see langword="FileOpen" />. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> обеспечивает большие показатели производительности и быстродействия операций файлового ввода-вывода, чем функция <see langword="FileAttr" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Следующие значения перечисления определяют режим доступа к файлу: 
 <list type="table"><item><term> Значение 
 </term><description> Режим 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта функция возвращает перечисление, представляющее режим файла для файлов, открытых `FileOpen` функции.  
  
   
  
## Examples  
 В этом примере используется `FileAttr` функция, возвращающая файловый режим открытого файла.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Необязательный параметр. Массив параметров из 0 или нескольких каналов, которые должны быть закрыты.</param>
        <summary>Завершает операции ввода-вывода с файлом, открытым с помощью функции <see langword="FileOpen" />. Возможность <see langword="My" /> предоставляет лучшие показатели производительности и быстродействии в операциях файлового ввода-вывода. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [Как Чтение текста из файлов с помощью StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [как: Запись текста в файлы с помощью StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), и [Пошаговое руководство: Операции с файлами и каталогами в Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Если опустить `FileNumbers`, все активные файлы, открываемые `FileOpen` функция закрываются.  
  
 При закрытии файлов, открытых для `Output` или `Append`, последнее содержимое буфера выходных данных записывается в буфер операционной системы для этого файла. Все буферное пространство, связанное с закрытого файл освобождается.  
  
 Когда `FileClose` функция выполняется, а связь файла с его файла заканчивается.  
  
   
  
## Examples  
 В этом примере используется `FileClose` функцию, чтобы закрыть файл открыт для `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> — не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">Оператор End</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Оператор Stop (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Обязательный. Строковое выражение, задающее имя копируемого файла. Параметр <paramref name="Source" /> может содержать имя каталога или папки, а также имя диска, где находится исходный файл.</param>
        <param name="Destination">Обязательный. Строковое выражение, определяющее имя файла назначения. Параметр <paramref name="Destination" /> может содержать имя каталога или папки, а также имя диска, где находится файл назначения.</param>
        <summary>Копирует файл. Объект <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> предоставляет большую производительность и быстродействие в операциях файлового ввода-вывода по сравнению с функцией <see langword="FileCopy" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы попытаетесь использовать `FileCopy` работать на открытый файл, возникает ошибка.  
  
 `FileCopy` требует полного доверия для работы на локальном диске.  
  
   
  
## Examples  
 В этом примере используется `FileCopy` функции для копирования одного файла в другой. Для целей этого примера, предположим, что `SrcFile` — это файл, содержащий данные.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="Source" /> или <paramref name="Destination" /> недопустим или не указан.</exception>
        <exception cref="T:System.IO.IOException">Этот файл уже открыт.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">Практическое руководство. Создание копии файла в другом каталоге в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Практическое руководство. Создание копии файла в том же каталоге в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Практическое руководство. Копирование каталога в другой каталог в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательный. Строковое выражение, определяющее имя файла. <paramref name="PathName" /> — может включать каталог или папку, а также имя диска.</param>
        <summary>Возвращает значение типа <see langword="Date" />, которое указывает дату и время последней операции записи в файл. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileDateTime" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Значение типа <see langword="Date" />, которое указывает дату и время создания или последнего изменения файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере используется `FileDateTime` создания или последнего изменения функции для определения даты и времени файла. Формат даты и времени зависит от параметров языкового стандарта системы.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="PathName" /> недопустим или содержит подстановочный знак.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Указанный файл не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью`FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется. Размер и границы массива, передан в `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции`FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью`FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <param name="StringIsFixedLength">Необязательный параметр. Используется только при записи строки. Указывает, записывать ли двухбайтовый дескриптор длины строки. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <param name="ArrayIsDynamic">Необязательный параметр. Применяется только при записи массива. Указывает, нужно ли обрабатывать массив как динамический, и обязательно ли записывать дескриптор массива, описывающий его длину и границы.</param>
        <param name="StringIsFixedLength">Необязательный параметр. Используется только при записи строки. Указывает, записывать ли двухбайтовый дескриптор длины строки. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Считывает данные из файла открытия диска в переменную. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGet" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGet` , обычно записываются в файл с помощью `FilePut`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, следующей записи или после последнего байта `FileGet` или `FilePut` функция (или на которые указывает последний `Seek` функции) доступен для чтения.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGet` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной считываемых данных.  
  
-   По умолчанию, если переменная считывается в строку `FileGet` считывает двухбайтовый дескриптор, который содержит длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины; При записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная является массивом, можно выбрать, следует ли считывать в дескрипторе, размер и размерность массива. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При чтении массива, у вас есть в соответствии с принципами написания массива. Если он был записан с дескриптором, необходимо прочитать дескриптор. Если дескриптор не используется, размер и границы массива, передаваемого `FileGet` определения того, что для чтения.  
  
     Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 байт распределяются следующим образом:  
  
    -   18 байт для дескриптора: (2 + 8 * 2)  
  
    -   200 байт для данных: (5 * 10 * 4).  
  
-   Если переменная считывается в объект другого типа переменной (не строка переменной длины или объект), `FileGet` считывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине считываемых данных.  
  
-   `FileGet` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePut`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно сумме всех байтов, необходимых для чтения отдельных элементов. Сюда входят все массивы и их дескрипторы. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGet` Считывает все переменные с диска последовательно; то есть без Величина заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGet` считывает только данные. Дескриптор не читается.  
  
-   `FileGet` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
    > [!IMPORTANT]
    >  Чтение из файла с помощью `FileGet` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, в которую считываются данные.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы режима <see langword="Random" />) или номер байта (файлы режима <see langword="Binary" />), с которого начинается считывание.</param>
        <summary>Считывает данные из файла открытия диска в переменную.  Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileGetObject" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject` Функции используется вместо `FileGet` во избежание неоднозначности во время компиляции, если тип `Object` возвращается вместо другого типа, таких как `Integer`, `Long`, `Short`, и т. д.  
  
 Если вы собираетесь записать `Variant` типа, `FileGetObject` является обязательным. Если вы сомневаетесь, если вы используете объект для второго параметра, всегда рекомендуется использовать `FilePutObject` и `FileGetObject`.  
  
 `FileGetObject` допустимо только в `Random` и `Binary` режим.  
  
 Данные, считанные с `FileGetObject` записываются с `FilePutObject`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, `FileGetObject` считывает записи или единственного байта после последнего `FileGetObject` или `FilePutObject` функция (или на которые указывает последний `Seek` функции).  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FileGetObject` считывает следующие записи границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку невозможно точно определить объем данных, заполнение, рекомендуется иметь совпадает с длиной данных длиной записи.  
  
-   Если переменная представляет собой строку, по умолчанию `FileGetObject` считывает двухбайтовый дескриптор, содержащий длину строки и затем считывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложении `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки. Visual Basic 6.0 и более ранние версии поддерживают строки фиксированной длины и при записи в файл, дескриптор длины не записывается. Если вы хотите прочитать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если переменная, считываемых в массив, а затем записей длину, заданную `RecordLength` параметр в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: 2 + 8 * NumberOfDimensions.  
  
     Например, следующее объявление массива требуется 218 байтов при записи на диск:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 байт распределяются следующим образом: 18 байт для дескриптора (2 + 8 * 2) и 100 байт для данных (5 * 10 * 4).  
  
-   `FileGetObject` считывает элементы структуры так, как если бы каждый при чтении по отдельности, за исключением того, что есть без заполнения между элементами. На диске, динамический массив в определяемый пользователем тип (с `FilePutObject`) начинается дескриптора, длина которого равна 2 плюс 8 раз число измерений: 2 + 8 * NumberOfDimensions. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для чтения отдельных элементов, включая массивы и их дескрипторы. <xref:Microsoft.VisualBasic.VBFixedStringAttribute> Класс может быть применен к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режим, все `Random` применяются правила, со следующими исключениями:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FileGetObject` Считывает все переменные с диска непрерывно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FileGetObject` считывает только данные. Дескриптор не читается.  
  
 `FileGetObject` считывает строки переменной длины, которые не являются частью структуры ожидается дескриптор длины размером 2 байта. Число считанных байтов равно количеству символов в строке.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. Например файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
   
  
## Examples  
 В следующем примере выполняется запись в файл теста и затем получает его.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательный. Строковое выражение, которое определяет файл. <paramref name="PathName" /> — может включать каталог или папку, а также имя диска.</param>
        <summary>Возвращает значение, которое указывает длину файла в байтах. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileLen" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Длина файла в байтах.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указанный файл открыт, когда `FileLen` вызывается функция, возвращаемое значение представляет размер файла на момент его открытия.  
  
> [!NOTE]
>  Чтобы получить текущую длину открытого файла, используйте `LOF` функции.  
  
   
  
## Examples  
 В этом примере используется `FileLen` функция возвращает длину файла в байтах. Для целей этого примера, предположим, что `TestFile` — это файл, который содержит некоторые данные.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Файл не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла. Для получения следующего свободного номера файла следует использовать функцию <see langword="FreeFile" />.</param>
        <param name="FileName">Обязательный. Строковое выражение, которое указывает имя файла. Может включать имя каталога или папки, а также имя диска.</param>
        <param name="Mode">Обязательный. Перечисление, определяющее режим файла: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> или <see langword="Random" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.OpenMode" />.</param>
        <param name="Access">Необязательный параметр. Перечисление, определяющие операции, разрешенные для работы с открытым файлом: <see langword="Read" />, <see langword="Write" /> или <see langword="ReadWrite" />. По умолчанию — <see langword="ReadWrite" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</param>
        <param name="Share">Необязательный параметр. Перечисление операций, не разрешенных при работе с файлом, открытым другим процессом: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> и <see langword="Lock Read Write" />. По умолчанию — <see langword="Lock Read Write" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.OpenShare" />.</param>
        <param name="RecordLength">Необязательный параметр. Число, не превышающее 32 767 (байт). Для файлов, открытых с произвольным доступом, это значение является длиной записи. Для файлов с последовательным доступом — это число знаков в буфере.</param>
        <summary>Открывает файл для ввода или вывода. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileOpen" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Перед выполнением любой операции ввода-вывода на нем необходимо открыть файл. `FileOpen` выделяет буфер для ввода-вывода в файл и определяет режим доступа для использования с буфером.  
  
> [!IMPORTANT]
>  При записи в файл приложения может потребоваться создать файл, если файл, к которому он пытается получить запись не существует. Чтобы сделать это, ему разрешения для каталога, в котором должен быть создан файл. Тем не менее если файл, заданный параметром `FileName` существует, приложению `Write` разрешение только на сам файл. Везде, где возможно, в целях повышения безопасности, создать файл во время развертывания и предоставить `Write` разрешение на этот файл только, а не для всего каталога. В целях повышения безопасности, записывайте данные в каталоги пользователей, а не в корневом каталоге или каталоге Program Files.  
  
 Канал, чтобы открыть можно найти с помощью `FreeFile()` функции.  
  
> [!IMPORTANT]
>  `FileOpen` Функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления, который может повлиять на выполнение в ситуациях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере показаны различные способы `FileOpen` функцию входные и выходные данные в файл.  
  
 Следующий код открывает файл `TestFile` в `Input` режиме.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 Этот пример открывает файл в `Binary` режиме для записи только операции.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 В следующем примере открывается файл в `Random` режиме. Файл содержит записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Данный пример кода открывает файл в `Output` режиме; любой процесс может прочитать или записать в файл.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Данный пример кода открывает файл в `Binary` режиме для чтения; другие процессы не удается прочитать файл.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Отрицательная длина записи (не равная –1).</exception>
        <exception cref="T:System.IO.IOException">Файл <paramref name="FileName" /> уже открыт, или <paramref name="FileName" /> является недопустимым.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор`VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в`RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <param name="StringIsFixedLength">Необязательный параметр. Используется только при записи строки. Указывает, записывать ли в файл двухбайтовый дескриптор длины строки. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <param name="ArrayIsDynamic">Необязательный параметр. Применяется только при записи массива. Указывает, нужно ли обрабатывать массив как динамический, и записывать ли дескриптор массива для строки, определяющий ее длину.</param>
        <param name="StringIsFixedLength">Необязательный параметр. Используется только при записи строки. Указывает, записывать ли в файл двухбайтовый дескриптор длины строки. Значение по умолчанию — <see langword="False" />.</param>
        <summary>Записывает значения переменных в файл на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePut" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePut`, обычно считываются с помощью `FileGet`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, далее соответствующей записи байтов после последнего `FileGet` или `FilePut` функцию или на которые указывает последний `Seek` написана функция.  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePut` записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, что необходимо сделать то же самое с `FileGet`, и вам нужно убедиться, что строка инициализируется длина ожидается.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Так как объем данных заполнения не может быть определен с достаточной точностью, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, будет создано исключение.  
  
-   Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, который содержит длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, запись длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePut` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, необходимо выбрать, следует ли записать дескриптор размер и размерность массива. Visual Basic 6.0 и более ранних версий записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптор, задайте `ArrayIsDynamic` параметр `True`. При записи массива, имеется в соответствии с принципами, которые будут считываться массива; Если он будет считываться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions). Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   В случае любого другого типа переменной (не строка переменной длины или объект), переменная записывается `FilePut` записывает только данные переменной. Длина записи, указанная с `RecordLength` предложение в `FileOpen` функция должна быть больше или равно длине записываемых данных.  
  
-   `FilePut` Записывает элементы структуры, как если бы каждый были по отдельности, кроме того, что заполнение между элементами. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.  
  
    > [!NOTE]
    >  Строка, полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск,  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режиме:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePut` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
-   Для любого массива, кроме массива в виде структуры `FilePut` записывает только данные. Дескриптор не записывается.  
  
-   `FilePut` Записывает строки переменной длины, которые не являются частью структуры дескриптор длины размером 2 байта. Число записанных байтов равно количеству символов в строке. Например следующие инструкции написать 11 байтов в файл номер 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Запись в файл с помощью `FilePut` функции требуется `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `FilePut` функции для записи данных в файл. Пять записей структуры `Person` записываются в файл.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 и не равно –1.</exception>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Допустимое имя переменной, содержащей данные для записи на диск.</param>
        <param name="RecordNumber">Необязательный параметр. Номер записи (файлы, открытые в режиме <see langword="Random" />) или номер байта (файлы, открытые в режиме <see langword="Binary" />), с которого начинается запись.</param>
        <summary>Записывает значения переменных в файл на диске.  Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FilePutObject" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject` Функции используется вместо `FilePut` во избежание неоднозначности во время компиляции, если тип `Object` передается вместо другого типа, например `Integer`, `Long`, `Short`, и т. д.  
  
 `FilePutObject` Записывает и читает дескрипторы, описывающие объект. Если вы собираетесь записать `Variant` типа, `FilePutObject` является обязательным. Если вы сомневаетесь, если вы используете объект для второго параметра, мы рекомендуем всегда использовать `FilePutObject` и `FileGetObject`.  
  
 `FilePutObject` допустимо только в `Random` и `Binary` режим.  
  
 Данные, записанные с использованием `FilePutObject`, обычно считываются с помощью `FileGetObject`.  
  
 Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если опустить `RecordNumber`, `FilePutObject` записывает Далее записи или единственного байта после последнего `FileGetObject` или `FilePutObject` функция (или записи или единственного байта, на которые указывают последнего `Seek` функции).  
  
 `StringIsFixedLength` Аргумент контролирует, представляет ли функция строки как фиксированной или переменной длины. `FilePutObject` записывает дескриптор длины, если аргумент является `True`. При использовании `StringIsFixedLength`  =  `True` с `FilePutObject`, что необходимо сделать то же самое с `FileGetObject`, а также необходимо убедиться в том, что строка инициализируется длина ожидалось.  
  
## <a name="random-mode"></a>Режим произвольного доступа  
 Для открытия файлов в `Random` режиме, применяются следующие правила:  
  
-   Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции `FilePutObject` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку невозможно точно определить объем данных, заполнение, рекомендуется обычно длина записи совпадает с длиной записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложении `FileOpen` функции, создается исключение.  
  
-   Если записываемая переменная является объектом, содержащим числовой тип, `FilePutObject` записывает два байта, идентифицирующие `VarType` объекта, а затем записывает переменную. Например, при написании объект, содержащий целое число, `FilePutObject` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(3)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.  
  
-   Если записываемая переменная — это объект, который содержит строку, `FilePutObject` записывает двухбайтовый дескриптор `VarType(8)` объекта, двухбайтовый дескриптор, указывающее длину строки, а затем данные строки. Длина записи, указанная с `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметра и считываются должна быть правильной длины строки.  
  
-   Если записываемая переменная является массивом, а затем записей длину, заданную `RecordLength` предложение в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8, умноженное на количество измерений: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Двоичный режим  
 Для открытия файлов в `Binary` режим, все `Random` применяются правила режиме, за исключением:  
  
-   `RecordLength` Предложение в `FileOpen` функция не имеет эффекта. `FilePutObject` Записывает все переменные на диск последовательно, то есть без заполнения между записями.  
  
   
  
## Examples  
 В этом примере используется `FilePutObject` функцию для записи строки в файл.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="RecordWidth">Обязательный. Числовое выражение в диапазоне от 0 до 255 включительно, которое показывает, сколько знаков появится в строке перед началом новой строки. Если параметр <paramref name="RecordWidth" /> равен 0, ограничения на длину строки не устанавливаются. Значение по умолчанию для <paramref name="RecordWidth" /> равно 0.</param>
        <summary>Присваивает ширину строки вывода в файле, открытом функцией <see langword="FileOpen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере используется `FileWidth` функцию для задания ширины строки вывода для файла.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение типа <see langword="Integer" />, представляющее следующий номер файла, доступный для использования функцией <see langword="FileOpen" />.</summary>
        <returns>Целочисленное значение, представляющее следующий номер файла, доступный для использования функцией <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `FreeFile` для номера файла, который уже не используется.  
  
   
  
## Examples  
 В этом примере используется `FreeFile` функцию для возврата следующего свободного номера файла. Для вывода в цикле открывается пять файлов, и некоторые примеры данных записывается для каждого.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Используется больше 255 файлов.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательный. Строковое выражение, определяющее имя файла, каталога или папки. Выражение <paramref name="PathName" /> может содержать имя каталога или папки и имя диска.</param>
        <summary>Возвращает значение <see langword="FileAttribute" />, представляющее атрибуты файла, каталога или папки. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="FileAttribute" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Значение, возвращаемое функцией <see langword="GetAttr" />, является суммой следующих значений перечисления: 
 <list type="table"><item><term> Значение 
 </term><description> Константа 
 </description><description> Описание 
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Нормальный.  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Только для чтения.  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Скрытый.  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> Системный файл.  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Каталог или папка.  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> Файл был изменен с момента создания последней резервной копии.  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> У файла другое имя.  
  
 </description></item></list><block subset="none" type="note"><para>  
 Эти перечисления определены в языке Visual Basic. Эти имена можно использовать в любом месте кода вместо самих значений.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы определить, какие атрибуты имеют значения, используйте `And` оператор для выполнения побитовое сравнение значения, возвращенного `GetAttr` функции и значения атрибута файла необходимо. Если результат не равен нулю, этот атрибут имеет значение для указанного файла. Например, возвращаемое значение из следующих `And` выражение является нуль, если `Archive` атрибут не задан:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Ненулевое значение возвращается в том случае, если `Archive` атрибут имеет значение.  
  
   
  
## Examples  
 В этом примере используется `GetAttr` функцию, чтобы определить атрибуты файла, каталога или папки.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Параметр <paramref name="Pathname" /> недопустим или содержит подстановочный знак.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Указанный файл не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">Оператор And (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл с несколькими строками данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл с несколькими строками данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Value">Обязательный. Переменная, которой присваиваются значения, считанные из файла. Не может быть массивом или объектной переменной.</param>
        <summary>Читает данные из открытого последовательного файла и присваивает данные переменным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `Input` , обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic 2005.  
  
 При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, как обрабатывается других входных данных.  
  
|Данные|Значение, присваиваемое переменной|  
|-|-|  
|Разделив их запятой или пустую строку|Empty|  
|NULL #|`DBNull`|  
|TRUE # или FALSE #|`True` или `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Значение даты и времени, представленного выражением|  
|#ERROR `errornumber`#|`errornumber` (переменная является объектом, помеченным как ошибка)|  
  
 Если достигнут конец файла при вводе элемента данных, ввод прекращается и происходит ошибка.  
  
> [!NOTE]
>  `Input` Функция не локализован. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая обрабатывается как разделитель переменных вместо как десятичный разделитель.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `Input` функции требуется `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Input` функция для считывания данных из файла в две переменные. В этом примере предполагается, что `TestFile` — это файл, содержащий несколько строк данных, записанных с помощью `Write` функции, каждая строка содержит строку в кавычках, а также числа, разделенные запятыми, например: («Hello», 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="CharCount">Обязательный. Любое допустимое числовое выражение, указывающее число знаков, которые надо прочитать.</param>
        <summary>Возвращает значение <see langword="String" />, содержащее знаки из файла, открытого в режиме <see langword="Input" /> или <see langword="Binary" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="InputString" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Строка, содержащая знаки из файла, открытого в режиме <see langword="Input" /> или <see langword="Binary" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `InputString` функции, обычно записываются в файл с помощью `Print` или `FilePut`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.  
  
 В отличие от `Input` функции `InputString` функция возвращает все символы, которые считывает. Сюда входят запятые, символы возврата каретки, перевода строки, кавычки и пробелы.  
  
 В файлах, открытых для `Binary` получить доступ к, попытка прочитать файл с помощью `InputString` функционировать до `EOF` возвращает `True` приводит к ошибке. Используйте `LOF` и `Loc` функции вместо `EOF` при чтении двоичных файлов с помощью `InputString`, или использовать `FileGet` при использовании `EOF` функции.  
  
> [!NOTE]
>  При считывании из файла решения по обеспечению безопасности содержимое файла, в зависимости от расширения имени файла не следует. Например файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
   
  
## Examples  
 В этом примере используется `InputString` функции считывают один символ за раз из файла и распечатать его, чтобы `Output` окна. В этом примере предполагается, что `MyFile` — это текстовый файл, содержащий несколько строк данных выборки.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> — не существует.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="CharCount" />&lt; 0 или &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательный. Строковое выражение, определяющее файлы, которые должны быть удалены. Выражение <paramref name="PathName" /> может содержать имя каталога или папки и имя диска.</param>
        <summary>Удаляет файлы с диска. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Kill" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` поддерживает использование нескольких знаков (`*`) и одиночные (`?`) можно указать несколько файлов.  
  
 **Примечание по безопасности** для выполнения, `Kill` функции требуется `Read` и `PathDiscovery` флаги из <xref:System.Security.Permissions.FileIOPermission> должны быть предоставлены для исполняемого кода. Дополнительные сведения см. в разделе <xref:System.Security.SecurityException> [разрешений доступа к коду](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 В этом примере используется `Kill` функции, чтобы удалить файл с диска.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Удаляемые файлы открыты.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Удаляемые файлы не найдены.</exception>
        <exception cref="T:System.Security.SecurityException">В разрешении отказано.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <summary>Читает одну строку из открытого последовательного файла и присваивает ее переменной типа <see langword="String" />.</summary>
        <returns>Читает одну строку из открытого последовательного файла и присваивает ее переменной типа <see langword="String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Данные, считанные с `LineInput` , обычно записываются в файл с помощью `Print`.  
  
> [!IMPORTANT]
>  При чтении из файлов, нельзя судить о содержимом файла, в зависимости от расширения имени файла. К примеру файл с именем Form1.vb может не быть исходным файлом Visual Basic.  
  
 `LineInput` Функция считывает из файла одного символа во время, пока встретится символ возврата каретки (`Chr(13)`) или каретки и перевода строки веб-канал (`Chr(13) + Chr(10)`) последовательности. Веб-канала последовательностей каретки и перевода строки, добавляемой в конце символьной строки, вместо пропускаются.  
  
> [!IMPORTANT]
>  Чтение из файла с помощью `LineInput` функции требуется `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess> перечисления.  
  
   
  
## Examples  
 В этом примере используется `LineInput` функция для чтения строки из последовательного файла и присвоить его переменной. В этом примере предполагается, что `TestFile` — это текстовый файл, содержащий несколько строк данных выборки.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Достигнут конец файла.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> — не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла типа <see langword="Integer" />.</param>
        <summary>Возвращает значение, указывающее текущую позицию для ввода-вывода в открытом файле.</summary>
        <returns>Текущая позиция чтения или записи в открытом файле.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc` Функция отсчитываются от нуля, использовании ее для получения первого байта в файле возвратит значение 0.  
  
 `Loc` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Ниже описаны возвращаемое значение для каждого режима доступа к файлу.  
  
|Режим|Возвращаемое значение|  
|-|-|  
|`Random`|Номер последней записи, чтения или записи в файл.|  
|`Sequential`|Текущая позиция байта в файле, деленная на 128. Тем не менее, возвращаются сведения по `Loc` для последовательных файлов не используется и не требуется.|  
|`Binary`|Позиция последнего байта чтения или записи.|  
  
   
  
## Examples  
 В этом примере используется `Loc` функция, возвращающая текущую позицию чтения/записи в файл. В этом примере предполагается, что `MyFile` — это текстовый файл, содержащий несколько строк данных выборки.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где несколько процессов может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функций всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` являются не указан, будет иметь блокировку для всего файла. Если `Record` отдельно указано одну запись будет заблокирована или разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` влияют на весь файл, независимо от того, диапазон, указанный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Record">Необязательный параметр. Номер единственной записи или единственного байта для блокировки или разблокировки.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где несколько процессов может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функций всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` являются не указан, будет иметь блокировку для всего файла. Если `Record` отдельно указано одну запись будет заблокирована или разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` влияют на весь файл, независимо от того, диапазон, указанный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="FromRecord">Необязательный параметр. Номер первой записи или первого байта, начиная с которого файл открывается или закрывается для доступа.</param>
        <param name="ToRecord">Необязательный параметр. Номер последней записи или последнего байта, которыми заканчивается часть файла, открытая или закрытая для доступа.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где несколько процессов может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функций всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` являются не указан, будет иметь блокировку для всего файла. Если `Record` отдельно указано одну запись будет заблокирована или разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` влияют на весь файл, независимо от того, диапазон, указанный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Целое число, содержащее допустимый номер файла.</param>
        <summary>Возвращает размер (в байтах) файла, открытого функцией <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="LOF" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Размер (в байтах) файла, открытого функцией <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `FileLen` функции для получения длины файла, не являющийся открытым.  
  
   
  
## Examples  
 В этом примере используется `LOF` функцию, чтобы определить размер открытого файла. В этом примере предполагается, что `TestFile` — это текстовый файл, содержащий данные образца.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Обязательный. Строковое выражение, задающее создаваемый каталог. Параметр <paramref name="Path" /> может содержать метку диска. Если диск не указан, <see langword="MkDir" /> создает каталог на текущем диске.</param>
        <summary>Создает каталог. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="MkDir" />. Дополнительные сведения см. в разделе <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта функция создает новый каталог.  
  
   
  
## Examples  
 В этом примере используется `MkDir` функции для создания каталога. Если диск не указан, новый каталог создается на текущем диске.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> не указан или пуст.</exception>
        <exception cref="T:System.Security.SecurityException">В разрешении отказано.</exception>
        <exception cref="T:System.IO.IOException">Каталог уже существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">Практическое руководство. Создание каталога в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Output">Необязательный. Ноль или больше выражений с разделителями-запятыми для записи в файл.  
  
Параметры аргумента <paramref name="Output" />: 
 <see langword="T:System.IO.IOException" />: Недопустимый режим файла.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> не существует.</param>
        <summary>Записывает отформатированные данные в последовательный файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` И `PrintLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` не включает символ перевода строки в конце строки; Тем не менее `PrintLine` содержит символ перевода строки.  
  
 Данные, записанные с помощью `Print` обычно считываются из файла с помощью `LineInput` или `Input`.  
  
 Если опустить `Output` для `PrintLine`, пустая строка выводится в файл; для `Print`, ничего не выводится. Несколько выражений, разделенных запятыми, будут выровнены по границам табуляции, но смешивание запятые и `TAB` может привести к несогласованным результатам.  
  
 Для `Boolean` данных, либо `True` или `False` печати. `True` И `False` ключевые слова не преобразуются, вне зависимости от языкового стандарта.  
  
 Дата данные записываются в файл с помощью стандартных краткий формат, распознаваемого системой. Когда дата или время отсутствует или ноль, только часть условии записывается в файл.  
  
 Ничего не записывается в файл, если `Output` данных пуст. Тем не менее если `Output` данные списка `DBNull`, `Null` записывается в файл.  
  
 Для `Error` данные, выходные данные отображаются как `Error errorcode`. `Error` Ключевое слово не переводится языкового стандарта.  
  
 Все данные, записываемые в файл с помощью `Print` соответствуют региональным международным стандартам; то есть данные правильно отформатирован с помощью соответствующего десятичного разделителя. Если пользователь хочет выходные данные для использования в нескольких языковых стандартов, `Write` следует использовать.  
  
 Запись в файл с помощью `Print` или `PrintLine` функции требуется `Write` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Print` и `PrintLine` функции для записи данных в файл.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Output">Необязательный. Ноль или больше выражений с разделителями-запятыми для записи в файл.  
  
Параметры аргумента <paramref name="Output" />: 
 <see langword="T:System.IO.IOException" />: Недопустимый режим файла.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> не существует.</param>
        <summary>Записывает отформатированные данные в последовательный файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` И `PrintLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` не включает символ перевода строки в конце строки; Тем не менее`PrintLine` содержит символ перевода строки.  
  
 Данные, записанные с помощью `Print` обычно считываются из файла с помощью `LineInput` или `Input`.  
  
 Если опустить `Output` для `PrintLine`, пустая строка выводится в файл; для `Print`, ничего не выводится. Несколько выражений, разделенных запятыми, будут выровнены по границам табуляции, но смешивание запятые и `TAB` может привести к несогласованным результатам.  
  
 Для `Boolean` данных, либо `True` или `False` печати. `True` И `False` ключевые слова не преобразуются, вне зависимости от языкового стандарта.  
  
 Дата данные записываются в файл с помощью стандартных короткого формата даты формата, распознаваемого системой. Когда дата или время отсутствует или ноль, только часть условии записывается в файл.  
  
 Ничего не записывается в файл, если `Output` данных пуст. Тем не менее если `Output` данные списка `DBNull`, `Null` записывается в файл.  
  
 Для `Error` данные, выходные данные отображаются как `Error errorcode`. `Error` Ключевое слово не переводится языкового стандарта.  
  
 Все данные, записываемые в файл с помощью `Print` соответствуют региональным международным стандартам; то есть данные правильно отформатирован с помощью соответствующего десятичного разделителя. Если пользователь хочет выходные данные для использования в нескольких языковых стандартов, `Write` следует использовать.  
  
 Запись в файл с помощью `Print` или `PrintLine` функции требуется `Write` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Print` и `PrintLine` функции для записи данных в файл.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Обязательный. Строковое выражение, указывающее имя и расположение существующего файла. Выражение <paramref name="OldPath" /> может содержать имя каталога и метку диска для файла.</param>
        <param name="NewPath">Обязательный. Строковое выражение, указывающее имя и расположение нового файла. Параметр <paramref name="NewPath" /> может содержать имя каталога и метку диска для нового местонахождения файла. Имя файла, заданного параметром <paramref name="NewPath" /> не может быть именем существующего файла.</param>
        <summary>Переименовывает файл или каталог на диске. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Rename" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename` Функция переименовывает файл и перемещает ее в другой каталог, если это необходимо. `Rename` Функции можно переместить файл на дисках, но его можно только переименовать существующий каталог, если оба `NewPath` и `OldPath` расположены на одном диске. `Rename` не удается создать новый файл или каталог.  
  
 С помощью `Rename` функции к открытому файлу выводит сообщение об ошибке. Необходимо закрыть файл перед его переименованием. `Rename` аргументы не могут содержать знак (*) и подстановочные знаки одного знака (?).  
  
> [!IMPORTANT]
>  При использовании `Rename` чтобы скопировать файл из незащищенное место в защищенном месте, в файле сохраняются менее ограниченные права. Проверьте, чтобы убедиться в том, что вы не представляете возможную угрозу безопасности.  
  
   
  
## Examples  
 В этом примере используется `Rename` функции, чтобы переименовать файл. Для целей этого примера предполагается, что каталоги, которые указаны в уже существуют.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый путь.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="OldPath" /> не существует.</exception>
        <exception cref="T:System.IO.IOException">Нельзя переименовать с указанием другого диска.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Практическое руководство. Переименование файла в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает все файлы на диске, открытые функцией <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Reset" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset` Функция закрывает все активные файлы, открываемые `FileOpen` функцию и делает то же самое `FileClose()` без параметров.  
  
   
  
## Examples  
 В этом примере используется `Reset` функцию, чтобы закрыть все открытые файлы и записи на диск содержимое всех буферов файлов. Обратите внимание на использование `Object` переменной `FileNumber` как строка и номером.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">Оператор End</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Обязательный. Строковое выражение, определяющее удаляемый каталог или папку. Параметр <paramref name="Path" /> может содержать метку диска. Если диск не указан, <see langword="RmDir" /> удаляет каталог на текущем диске.</param>
        <summary>Удаляет существующий каталог. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="RmDir" />. Дополнительные сведения см. в разделе <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Произошла ошибка при попытке использовать `RmDir` на каталог, содержащий файлы. Используйте `Kill` функции, чтобы удалить все файлы, прежде чем пытаться удалить каталог.  
  
   
  
## Examples  
 В этом примере используется `RmDir` функцию для удаления существующего каталога.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> не указан или пуст.</exception>
        <exception cref="T:System.IO.IOException">Удаляемый каталог содержит файлы.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Каталог не существует.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение типа <see langword="Long" />, указывающее текущую позицию ввода-вывода в файле, открытом функцией <see langword="FileOpen" />, или устанавливает позицию для следующей операции ввода-вывода в файле, открытом с помощью функции <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Seek" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Значение <see langword="Integer" />, содержащее допустимый номер файла.</param>
        <summary>Возвращает значение типа <see langword="Long" />, указывающее текущую позицию ввода-вывода в файле, открытом функцией <see langword="FileOpen" />, или устанавливает позицию для следующей операции ввода-вывода в файле, открытом с помощью функции <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Seek" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Значение типа <see langword="Long" />, указывающее текущую позицию ввода-вывода в файле, открытом функцией <see langword="FileOpen" />, или устанавливает позицию для следующей операции ввода-вывода в файле, открытом с помощью функции <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Возвращает значение от 1 до 2 147 483 647 (эквивалентно 2 ^ 31 - 1) включительно.  
  
 Ниже описаны возвращаемые значения для каждого режима доступа к файлу.  
  
|Режим|Возвращаемое значение|  
|-|-|  
|`Random`|Номер следующей записи, чтения или записи|  
|`Binary`, `Input`, `Output`, `Append`|Позиция байта, в которой возникает при следующей операции. Первый байт в файле находится в позиции 1, второй байт в позиции 2 и т. д.|  
  
   
  
## Examples  
 В этом примере используется `Seek` функция, возвращающая текущую позицию в файле. В этом примере предполагается `TestFile` — это файл, содержащий записи структуры `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Для открытия файлов в `Random` режиме `Seek` возвращает номер следующей записи.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Для файлов, открытых в режимах, отличных от `Random` режиме `Seek` возвращает позицию байта, в которой возникает при следующей операции. Предположим, `TestFile` — это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 В этом примере используется `Seek` функции для установки позиции следующего чтения или записи в файл.  
  
 Для файлов, открытых в режимах, отличных от `Random` режиме `Seek` устанавливает позицию байта, в которой возникает при следующей операции. Предположим, `TestFile` — это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Значение <see langword="Integer" />, содержащее допустимый номер файла.</param>
        <param name="Position">Обязательный. Число в диапазоне от 1 до 2 147 483 647 включительно, определяющее место следующей операции чтения/записи.</param>
        <summary>Возвращает значение типа <see langword="Long" />, указывающее текущую позицию ввода-вывода в файле, открытом функцией <see langword="FileOpen" />, или устанавливает позицию для следующей операции ввода-вывода в файле, открытом с помощью функции <see langword="FileOpen" />. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="Seek" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Возвращает значение от 1 до 2 147 483 647 (эквивалентно 2 ^ 31 - 1) включительно.  
  
 Ниже описаны возвращаемые значения для каждого режима доступа к файлу.  
  
|Режим|Возвращаемое значение|  
|-|-|  
|`Random`|Номер следующей записи, чтения или записи|  
|`Binary`, `Input`, `Output`, `Append`|Позиция байта, в которой возникает при следующей операции. Первый байт в файле находится в позиции 1, второй байт в позиции 2 и т. д.|  
  
   
  
## Examples  
 В этом примере используется `Seek` функция, возвращающая текущую позицию в файле. В этом примере предполагается `TestFile` — это файл, содержащий записи структуры `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Для открытия файлов в `Random` режиме `Seek` возвращает номер следующей записи.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Для файлов, открытых в режимах, отличных от `Random` режиме `Seek` возвращает позицию байта, в которой возникает при следующей операции. Предположим, `TestFile` — это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 В этом примере используется `Seek` функции для установки позиции следующего чтения или записи в файл.  
  
 Для файлов, открытых в режимах, отличных от `Random` режиме `Seek` устанавливает позицию байта, в которой возникает при следующей операции. Предположим, `TestFile` — это файл, содержащий несколько строк текста.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Чтение из файлов в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Запись в файлы в Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Обязательный. Строковое выражение, определяющее имя файла. <paramref name="PathName" /> может включать каталог или папку, а также диск.</param>
        <param name="Attributes">Обязательный. Константа или числовое выражение, сумма которого определяет атрибуты файла.</param>
        <summary>Устанавливает атрибуты файла. Функция <see langword="My" /> обеспечивает более высокие показатели производительности и быстродействия в операциях файлового ввода-вывода в сравнении с <see langword="SetAttr" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ошибка времени выполнения возникает при попытке установить атрибуты для открытого файла.  
  
 `Attributes` Используются значения перечисления аргументов следующим образом:  
  
|Значение|Константа|Описание|  
|-|-|-|  
|`Normal`|`vbNormal`|Обычный (по умолчанию).|  
|`ReadOnly`|`vbReadOnly`|Только для чтения.|  
|`Hidden`|`vbHidden`|Скрытый.|  
|`System`|`vbSystem`|Системный файл.|  
|`Volume`|`vbVolume`|Метка тома|  
|`Directory`|`vbDirectory`|Каталог или папка.|  
|`Archive`|`vbArchive`|Файл был изменен с момента создания последней резервной копии.|  
|`Alias`|`vbAlias`|У файла другое имя.|  
  
> [!NOTE]
>  Эти перечисления определены в языке Visual Basic. Имена можно использовать в любом месте в коде вместо фактических значений.  
  
   
  
## Examples  
 В этом примере используется `SetAttr` функцию для задания атрибутов файла.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый тип <paramref name="Attribute" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Обязательный. Число пробелов, вставляемых перед отображением или печатью очередного выражения в списке.</param>
        <summary>Используется с функцией <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</summary>
        <returns>Используется с функцией <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `Count` меньше ширины строки вывода, следующая позиция печати непосредственно следует за количество напечатанных пробелов. Если`Count` больше, чем выводимой строки `SPC` вычисляет следующую позицию печати с помощью формулы:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Например, если текущая позиция печати равна 24, выводимой строки — 80, а `SPC(90)`, печать начнется с позиции 34 (текущая позиция печати + остаток от 90/80). Если разница между текущей позицией печати и ширину строки вывода меньше, чем `Count` (или `Count` `Mod` *ширины*), `SPC` функция переходит в начало следующей строки и создает пробелы, равные `Count` -(*ширины* - *текущая_позиция_печати*).  
  
> [!NOTE]
>  Убедитесь, что столбцы таблицы достаточно широки разрешить длинные записи.  
  
   
  
## Examples  
 В этом примере используется `SPC` функции для установки позиции вывода в файле и в **вывода** окна.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Оператор Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Используется с функциями <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Используется с функциями <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</summary>
        <returns>Используется с функциями <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущая позиция печати в текущей строке больше, чем `Column`, `TAB` пропускает равным значению столбца `Column` на следующую строку. Если `Column` меньше 1, `TAB` перемещает позицию печати в столбец 1. Если `Column` больше, чем выводимой строки `TAB` вычисляет следующую позицию печати с помощью формулы:  
  
 Mod ширина столбца  
  
 Например если *ширины* 80 и указать `TAB(90)`, печать начнется со столбца 10 (остаток от 90/80). Если `Column` меньше, чем текущая позиция печати, печать начинается на следующей строке в позиции вычисляемой печати. Если рассчитанная позиция печати больше, чем текущая позиция печати, печать начинается в рассчитанной позиции печати в той же строке.  
  
 Самая левая позиция печати строки вывода всегда равно 1. При использовании `Print` или `PrintLine` функции для печати в файлы, позиция равна ширине выходного файла, который можно задать с помощью `FileWidth` функции.  
  
 `TAB` Функция также может использоваться с `WriteLine` функции. Он не может использоваться с <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> или <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Убедитесь, что столбцы таблицы достаточно широки вместить длинные записи.  
  
   
  
## Examples  
 В этом примере используется `TAB` функции для установки позиции вывода в файле и в **вывода** окна.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Оператор Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Необязательный параметр. Номер столбца, в который помещается курсор перед отображением или печатью следующего выражения из списка. Если этот параметр опущен, <see langword="TAB" /> перемещает положение курсора в начало следующей зоны печати.</param>
        <summary>Используется с функциями <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</summary>
        <returns>Используется с функциями <see langword="Print" /> или <see langword="PrintLine" /> для установки позиции вывода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущая позиция печати в текущей строке больше, чем `Column`, `TAB` пропускает равным значению столбца `Column` на следующую строку. Если `Column` меньше 1, `TAB` перемещает позицию печати в столбец 1. Если `Column` больше, чем выводимой строки `TAB` вычисляет следующую позицию печати с помощью формулы:  
  
 Mod ширина столбца  
  
 Например если *ширины* 80 и указать `TAB(90)`, печать начнется со столбца 10 (остаток от 90/80). Если `Column` меньше, чем текущая позиция печати, печать начинается на следующей строке в позиции вычисляемой печати. Если рассчитанная позиция печати больше, чем текущая позиция печати, печать начинается в рассчитанной позиции печати в той же строке.  
  
 Самая левая позиция печати строки вывода всегда равно 1. При использовании `Print` или `PrintLine` функции для печати в файлы, позиция равна ширине выходного файла, который можно задать с помощью `FileWidth` функции.  
  
 `TAB` Функция также может использоваться с `WriteLine` функции. Он не может использоваться с <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> или <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Убедитесь, что столбцы таблицы достаточно широки вместить длинные записи.  
  
   
  
## Examples  
 В этом примере используется `TAB` функции для установки позиции вывода в файле и в **вывода** окна.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Оператор Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где несколько процессов может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функций всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` являются не указан, будет иметь блокировку для всего файла. Если `Record` отдельно указано одну запись будет заблокирована или разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` влияют на весь файл, независимо от того, диапазон, указанный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="Record">Необязательный параметр. Номер единственной записи или единственного байта для блокировки или разблокировки.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где несколько процессов может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функций всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` являются не указан, будет иметь блокировку для всего файла. Если `Record` отдельно указано одну запись будет заблокирована или разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` влияют на весь файл, независимо от того, диапазон, указанный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Любой допустимый номер файла.</param>
        <param name="FromRecord">Необязательный параметр. Номер первой записи или первого байта, начиная с которого файл открывается или закрывается для доступа.</param>
        <param name="ToRecord">Необязательный параметр. Номер последней записи или последнего байта, которыми заканчивается часть файла, открытая или закрытая для доступа.</param>
        <summary>Управляет доступом других процессов ко всему файлу, открытому с помощью функции <see langword="Open" />, или к его части. Средства из пространства имен <see langword="My" /> обеспечивают большую производительность и быстродействие операций файлового ввода-вывода, чем методы <see langword="Lock" /> и <see langword="Unlock" />. Дополнительные сведения см. в разделе <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` И `Unlock` функции используются в средах, где несколько процессов может понадобиться доступ к тому же файлу.  
  
 `Lock` и `Unlock` функций всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.  
  
 Если `Record`, или `FromRecord` и `ToRecord` являются не указан, будет иметь блокировку для всего файла. Если `Record` отдельно указано одну запись будет заблокирована или разблокирована.  
  
 Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` влияют на весь файл, независимо от того, диапазон, указанный `FromRecord` и`ToRecord`.  
  
   
  
## Examples  
 В этом примере показано использование `Lock` и `Unlock` функции. В этом примере предполагается, что `People.txt` — это файл, содержащий записи структуры `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Выражение <see langword="Integer" />, содержащее любой допустимый номер файла.</param>
        <param name="Output">Необязательный параметр. Одно или несколько выражений с разделителями-запятыми, которые нужно записать в файл.</param>
        <summary>Записывает данные в последовательный файл. Данные, записанные с использованием <see langword="Write" />, обычно считываются с помощью <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` И `WriteLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Если опустить `Output`, пустая строка выводится в файл. Несколько выражений могут быть разделены запятыми.  
  
 В отличие от `Print` функции `Write` функция вставляет запятые между элементами и кавычки вокруг строки, так как они записаны в файл. Необходимо поместить явные разделители в списке. Когда `Write` используется для записи данных в файл, только числовые `Boolean`, даты, значения null, и `Error` поддерживаются форматы данных. Следующие универсальные предположения соблюдать, данные всегда могут быть прочитаны и правильно интерпретированы с помощью `Input`, независимо от языкового стандарта:  
  
-   Числовые данные всегда записываются с использованием точки в качестве десятичного разделителя.  
  
-   Для `Boolean` данных, либо `#TRUE#` или `#FALSE#` печати. `True` И `False` ключевые слова не преобразуются, вне зависимости от языкового стандарта.  
  
-   Дата записывается в файл, используя универсальный формат даты. Когда дата или время отсутствует или ноль, только часть условии записывается в файл.  
  
-   Ничего не записывается в файл, если `Output` данных пуст. Тем не менее для пустых данных `#NULL#` записывается.  
  
-   Для `Error` данные, выходные данные отображаются как `#ERROR errorcode#`. `Error` Ключевого слова не преобразуются, вне зависимости от языкового стандарта.  
  
 `WriteLine` Вставляет символ новой строки (то есть перевода каретки и перевода строки, или `Chr(13) + Chr(10)`), после записи последнего символа `Output` к файлу.  
  
 Можно вставить кавычки в строке с помощью двойных кавычек, или «». Например, примененная к объекту директива  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Возвращает строку со значением `Double quotation marks aren't "difficult" to handle`.  
  
 Запись в файл с помощью `Write` или `WriteLine` функции требуется `Append` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Write` функции для записи необработанных данных в последовательный файл.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Недопустимый режим файла.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Обязательный. Выражение <see langword="Integer" />, содержащее любой допустимый номер файла.</param>
        <param name="Output">Необязательный параметр. Одно или несколько выражений с разделителями-запятыми, которые нужно записать в файл.</param>
        <summary>Записывает данные в последовательный файл. Данные, записанные с использованием <see langword="Write" />, обычно считываются с помощью <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` И `WriteLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объект обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Если опустить `Output`, пустая строка выводится в файл. Несколько выражений могут быть разделены запятыми.  
  
 В отличие от `Print` функции `Write` функция вставляет запятые между элементами и кавычки вокруг строки, так как они записаны в файл. Необходимо поместить явные разделители в списке. Когда `Write` используется для записи данных в файл, только числовые `Boolean`, даты, значения null, и `Error` поддерживаются форматы данных. Следующие универсальные предположения соблюдать, данные всегда могут быть прочитаны и правильно интерпретированы с помощью `Input`, независимо от языкового стандарта:  
  
-   Числовые данные всегда записываются с использованием точки в качестве десятичного разделителя.  
  
-   Для `Boolean` данных, либо `#TRUE#` или `#FALSE#` печати. `True` И `False` ключевые слова не преобразуются, вне зависимости от языкового стандарта.  
  
-   Дата записывается в файл, используя универсальный формат даты. Когда дата или время отсутствует или ноль, только часть условии записывается в файл.  
  
-   Ничего не записывается в файл, если `Output` данных пуст. Тем не менее для пустых данных `#NULL#` записывается.  
  
-   Для `Error` данные, выходные данные отображаются как `#ERROR errorcode#`. `Error` Ключевого слова не преобразуются, вне зависимости от языкового стандарта.  
  
 `WriteLine` Вставляет символ новой строки (то есть перевода каретки и перевода строки, или `Chr(13) + Chr(10)`), после записи последнего символа `Output` к файлу.  
  
 Можно вставить кавычки в строке с помощью двойных кавычек, или «». Например, примененная к объекту директива  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Возвращает строку со значением `Double quotation marks aren't "difficult" to handle`.  
  
 Запись в файл с помощью `Write` или `WriteLine` функции требуется `Append` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 В этом примере используется `Write` функции для записи необработанных данных в последовательный файл.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Доступ к файлам с помощью Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Практическое руководство. Запись текста в файлы в Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Практическое руководство. Запись текста в файл с помощью Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>