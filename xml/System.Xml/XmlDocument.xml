<Type Name="XmlDocument" FullName="System.Xml.XmlDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c56bc51e3721ee6938993785c4e5fb8a5e1016f6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36436442" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlDocument : System.Xml.XmlNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDocument extends System.Xml.XmlNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlDocument&#xA;Inherits XmlNode" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlDocument : System::Xml::XmlNode" />
  <TypeSignature Language="F#" Value="type XmlDocument = class&#xA;    inherit XmlNode" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlDocument</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет XML-документ. Этот класс можно использовать для загрузки, проверки, изменения, добавления и размещения XML-кода в документе.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="Remarks"></a> <xref:System.Xml.XmlDocument> Класс представляет собой в памяти представление XML-документа. Он реализует W3C [XML объекта модели (DOM)](~/docs/standard/data/xml/xml-document-object-model-dom.md) базового уровня 1 и базового уровня 2.  
  
 *DOM* расшифровывается *объектной модели документов*. Дополнительные сведения, см. [XML объекта модели (DOM)](~/docs/standard/data/xml/xml-document-object-model-dom.md).  
  
 Можно загрузить в модель DOM XML с помощью <xref:System.Xml.XmlDocument> класса и затем программными средствами чтения, изменения и удаления XML в документе.  
  
 Если вы хотите извлечь откройте <xref:System.Xml.XmlDocument> класса и его реализация см [ссылки на источник](https://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Dom/XmlDocument.cs#f82a4c1bd1f0ee12).  
  
<a name="Common"></a>   
## <a name="tasks"></a>Задачи  
  
-   [Загрузка XML в объектной модели документов](#Load)  
  
-   [Его проверки по схеме](#Validation)  
  
-   [Перемещаться по дереву документов](#Navigate)  
  
-   [Поиск узлов](#Find)  
  
-   [Изменение узлов](#Edit)  
  
-   [Добавление узлов](#Add)  
  
-   [Удаление узлов](#Remove)  
  
-   [Положение узлов](#Position)  
  
<a name="Load"></a>   
## <a name="load-xml-into-the-document-object-model"></a>Загрузка XML в объектной модели документов  
 Начните с XML-документа, похожее на следующее. Это просто несколько книг в коллекции. Но он содержит основные возможности, которые можно найти в любой XML-документа. пространство имен, элементы, представляющие данные и атрибуты, описывающие данные.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<books xmlns="http://www.contoso.com/books">  
  <book genre="novel" ISBN="1-861001-57-8" publicationdate="1823-01-28">  
    <title>Pride And Prejudice</title>  
    <price>24.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861002-30-1" publicationdate="1985-01-01">  
    <title>The Handmaid's Tale</title>  
    <price>29.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861001-45-3" publicationdate="1811-01-01">  
    <title>Sense and Sensibility</title>  
    <price>19.95</price>  
  </book>  
</books>  
```  
  
 Затем загрузите эти данные в модель DOM, чтобы вы могли работать с ним в памяти. Чаще всего для этого будет ссылаться на файл на локальном компьютере или в сети.  
  
 В этом примере показана загрузка XML из файла. Если файл не существует, он просто создает XML- и загружает.  
  
 [!code-cpp[XMLProcessingApp#1](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#1)]
 [!code-csharp[XMLProcessingApp#1](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#1)]
 [!code-vb[XMLProcessingApp#1](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#1)]  
  
 **Полный пример:** [работы с XML в памяти с помощью класса XmlDocument и других связанных типов](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Дополнительные сведения:** [считывание XML-документа в DOM](~/docs/standard/data/xml/reading-an-xml-document-into-the-dom.md)  
  
<a name="Validation"></a>   
## <a name="validate-it-against-a-schema"></a>Его проверки по схеме  
 Начните с XML-схемы такого рода. Эта схема определяет типы данных в XML и какие атрибуты не требуются.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"  
  attributeFormDefault="unqualified"   
  elementFormDefault="qualified"  
  targetNamespace="http://www.contoso.com/books">   
  <xs:element name="books">  
    <xs:complexType>  
      <xs:sequence>  
        <xs:element maxOccurs="unbounded" name="book">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="title" type="xs:string" />  
              <xs:element name="price" type="xs:decimal" />  
            </xs:sequence>  
            <xs:attribute name="genre" type="xs:string" use="required" />  
            <xs:attribute name="ISBN" type="xs:string" use="required" />  
            <xs:attribute name="publicationdate" type="xs:date" use="required" />  
          </xs:complexType>  
        </xs:element>  
      </xs:sequence>  
    </xs:complexType>  
  </xs:element>  
</xs:schema>  
```  
  
 Создание <xref:System.Xml.XmlReader> объекта с помощью схемы, а затем загрузите этот объект в модель DOM. Создайте обработчик событий, которое выполняется, когда код пытается изменить XML-файл таким образом, чтобы не нарушает схему.  
  
 Эти блоки кода показывают вспомогательные методы, которые выполняют все это.  
  
 [!code-cpp[XMLProcessingApp#2](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#2)]
 [!code-csharp[XMLProcessingApp#2](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#2)]
 [!code-vb[XMLProcessingApp#2](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#2)]  
  
 **Полный пример:** [работы с XML в памяти с помощью класса XmlDocument и других связанных типов](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Дополнительные сведения:** [проверки XML-документа в DOM](~/docs/standard/data/xml/validating-an-xml-document-in-the-dom.md)  
  
<a name="Navigate"></a>   
## <a name="navigate-the-document-tree"></a>Перемещаться по дереву документов  
 Свойства можно использовать для навигации по XML-документа. Но прежде чем использовать любой из них, давайте ознакомимся несколько терминов. Документ состоит из узлов. Каждый узел совпадает с одним *родительского* узел, непосредственно над ним. Единственным узлом, не имеет родительского узла — корневой узел документа, как он представляет узел верхнего уровня. Большинства узлов может быть *дочерних* узлы, которые являются узлами непосредственно под ними. Узлы, которые находятся на одном уровне — *одноуровневых элементов*.  
  
 Следующие примеры демонстрируют получения корневого узла перехода к первым дочерним узлом корневого узла, доступ к любым из его дочерних узлов, вернуться родительскому узлу, и перейдите по узлам того же уровня.  
  
 **Запуск с корневого узла**  
  
 В этом примере возвращает корневой узел, а затем использует этот узел для вывода содержимого документа в консоль.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Получить дочерние узлы**  
  
 В этом примере выполняется переход к первым дочерним узлом корневого узла и затем перебор дочерних узлов данного узла, если они существуют.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 **Вернуться к родительским узлом**  
  
 Используйте свойство <xref:System.Xml.XmlDocument.ParentNode%2A>.  
  
 **Указывают на последний дочерний узел**  
  
 Этот пример записывает цены книги на консоль (это последний дочерний узел узла книги).  
  
 [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/VB/source.vb#1)]  
  
 **Переход вперед по одноуровневых элементов**  
  
 Этот пример выполняет переход из книги к книге. Узлы книг имеют общего родителя друг с другом.  
  
 [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/VB/source.vb#1)]  
  
 **Переход вперед через одноуровневых элементов**  
  
 В этом примере перемещается вперед из книги к книге.  
  
 [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/VB/source.vb#1)]  
  
<a name="Find"></a>   
## <a name="find-nodes"></a>Поиск узлов  
 Чаще всего для поиска одного или нескольких узлов данных является использование строку запроса XPath, но существуют также методы, которые не требуются.  
  
 **Получить один узел**  
  
 Этот пример находит книги с помощью номера ISBN.  
  
 [!code-cpp[XMLProcessingApp#3](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#3)]
 [!code-csharp[XMLProcessingApp#3](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#3)]
 [!code-vb[XMLProcessingApp#3](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#3)]  
  
 Строка, используемая в этом примере приводится запроса Xpath. Можно найти здесь дополнительные примеры: [примеров XPath](https://msdn.microsoft.com/library/ms256086.aspx).  
  
 Можно также использовать <xref:System.Xml.XmlDocument.GetElementById%2A> для извлечения узлов. Чтобы использовать этот подход, необходимо определить идентификаторы в объявления определения типа документа в XML-файл.  
  
 После получения узла можно получить значение атрибутов или дочерних узлов. Этот пример делает это с узла книги.  
  
 [!code-cpp[XMLProcessingApp#4](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#4)]
 [!code-csharp[XMLProcessingApp#4](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#4)]
 [!code-vb[XMLProcessingApp#4](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#4)]  
  
 **Возвращает коллекцию узлов**  
  
 В этом примере выделяются все книги, где Фамилия автора **Остин**и затем изменяет цену этих книг.  
  
 [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/VB/source.vb#1)]  
  
 Можно также получить коллекцию узлов, используя имя узла. Например в этом примере возвращает коллекцию всех заголовков книг.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 **Полный пример:** [работы с XML в памяти с помощью класса XmlDocument и других связанных типов](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Дополнительные сведения:** [Выбор узлов с помощью XPath-навигации](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md)  
  
<a name="Edit"></a>   
## <a name="edit-nodes"></a>Изменение узлов  
 Этот пример изменяет узел книги и его атрибуты.  
  
 [!code-cpp[XMLProcessingApp#7](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#7)]
 [!code-csharp[XMLProcessingApp#7](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#7)]
 [!code-vb[XMLProcessingApp#7](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#7)]  
  
 **Дополнительные сведения:** [изменение узлов, содержимого и значений в XML-документа](~/docs/standard/data/xml/modifying-nodes-content-and-values-in-an-xml-document.md)  
  
 **Полный пример:** [работы с XML в памяти с помощью класса XmlDocument и других связанных типов](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
<a name="Add"></a>   
## <a name="add-nodes"></a>Добавление узлов  
 Чтобы добавить узел, используйте <xref:System.Xml.XmlDocument.CreateElement%2A> метода или <xref:System.Xml.XmlDocument.CreateNode%2A> метод.  
  
 Чтобы добавить узел данных, такие как книги, используйте <xref:System.Xml.XmlDocument.CreateElement%2A> метод.  
  
 Для любого другого типа узла, например комментария, пробела или узел CDATA, используйте <xref:System.Xml.XmlDocument.CreateNode%2A> метод.  
  
 В этом примере создает узел книги, добавляет к данному узлу attrubutes и затем добавляет этот узел в документ.  
  
 [!code-cpp[XMLProcessingApp#5](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#5)]
 [!code-csharp[XMLProcessingApp#5](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#5)]
 [!code-vb[XMLProcessingApp#5](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#5)]  
  
 **Полный пример:** [работы с XML в памяти с помощью класса XmlDocument и других связанных типов](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Дополнительные сведения:** [Вставка узлов в XML-документа](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md)  
  
<a name="Remove"></a>   
## <a name="remove-nodes"></a>Удаление узлов  
 Чтобы удалить узел, используйте <xref:System.Xml.XmlNode.RemoveChild%2A> метод.  
  
 Этот пример удаляет книгу из документа и пробелов, который отображается перед узлом книги.  
  
 [!code-cpp[XMLProcessingApp#6](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#6)]
 [!code-csharp[XMLProcessingApp#6](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#6)]
 [!code-vb[XMLProcessingApp#6](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#6)]  
  
 **Полный пример:** [работы с XML в памяти с помощью класса XmlDocument и других связанных типов](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Дополнительные сведения:** [удаление узлов, содержимого и значений из XML-документа](~/docs/standard/data/xml/removing-nodes-content-and-values-from-an-xml-document.md)  
  
<a name="Position"></a>   
## <a name="position-nodes"></a>Положение узлов  
 Можно выбрать место узел, чтобы отобразился в документе с помощью <xref:System.Xml.XmlNode.InsertBefore%2A> и <xref:System.Xml.XmlNode.InsertAfter%2A> методы.  
  
 В этом примере показано два вспомогательных метода. Один из них перемещает узел выше в списке. Другой способ перемещает ниже узла.  
  
 Эти методы могут использоваться в приложении, которое дает пользователям возможность перемещать книги вверх и вниз в списке книг. Когда пользователь выбирает книги и нажимает вверх или вниз, код может вызывать методы подобные разместить соответствующий узел книги до или после других узлов книги.  
  
 [!code-cpp[XMLProcessingApp#8](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#8)]
 [!code-csharp[XMLProcessingApp#8](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#8)]
 [!code-vb[XMLProcessingApp#8](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#8)]  
  
 **Полный пример:** [работы с XML в памяти с помощью класса XmlDocument и других связанных типов](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.XmlNodeChangedEventHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlDocument" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlDocument" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ниже приведен пример проверки во время загрузки. Определения DTD типа документа проверяющего <xref:System.Xml.XmlReader> передается <xref:System.Xml.XmlDocument.Load%2A> метод и <xref:System.Xml.Schema.ValidationEventHandler> предоставляется для уведомления пользователей об ошибках проверки. В этом примере обнаружена ошибка проверки, но по-прежнему загружается документ. Кроме того, можно определить проверяющего <xref:System.Xml.XmlReader> для создания исключения и остановки процесса загрузки при обнаружении ошибки проверки, не указывая <xref:System.Xml.Schema.ValidationEventHandler>. Дополнительные сведения о проверке данных XML см. в подразделе примечаний на справочной странице <xref:System.Xml.XmlReader>.  
  
 [!code-cpp[XmlDocument.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.cctor/CPP/docload.cpp#1)]
 [!code-csharp[XmlDocument.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.cctor/CS/docload.cs#1)]
 [!code-vb[XmlDocument.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.cctor/VB/docload.vb#1)]  
  
 В примере в качестве входных данных используется файл `bookDTD.xml`.  
  
 [!code-xml[XmlDocument.cctor#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.cctor/XML/bookdtd.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlDocument.Load(System.String)" />
        <altmember cref="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal XmlDocument (System.Xml.XmlImplementation imp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlImplementation imp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub New (imp As XmlImplementation)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; XmlDocument(System::Xml::XmlImplementation ^ imp);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDocument : System.Xml.XmlImplementation -&gt; System.Xml.XmlDocument" Usage="new System.Xml.XmlDocument imp" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="imp" Type="System.Xml.XmlImplementation" />
      </Parameters>
      <Docs>
        <param name="imp">Используемый <see langword="XmlImplementation" />.</param>
        <summary>Инициализирует новый экземпляр класса <see langword="XmlDocument" /> указанным значением <see cref="T:System.Xml.XmlImplementation" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument(System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDocument : System.Xml.XmlNameTable -&gt; System.Xml.XmlDocument" Usage="new System.Xml.XmlDocument nt" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">Используемый <see langword="XmlNameTable" />.</param>
        <summary>Инициализирует новый экземпляр класса <see langword="XmlDocument" /> указанным значением <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlDocument.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает базовый URI текущего узла.</summary>
        <value>Расположение, из которого загружен узел.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сетевой XML-документ состоит из фрагментов данных, объединяемых с помощью различных механизмов включения стандарта W3C и поэтому содержит узлы, полученные из различных мест. `BaseURI` Сообщает, откуда получены эти узлы.  
  
 Для узлов документа `BaseURI` возвращает расположение XML-документа. Например если `XmlDocument` был загружен с помощью следующего вызова doc. Загрузка («http://server/mydata.xml»), `BaseURI` для документа узел является http://server/mydata.xml. Однако если <xref:System.Xml.XmlDocument.Load%2A> метод перенаправлен сервером на другой URI `BaseURI` возвращает исходный URI, переданный в `Load` метод.  
  
 Это свойство является расширением Microsoft для объектной модели документа (DOM). Дополнительные сведения о `BaseURI` и ведет себя с другими типами узлов, в разделе <xref:System.Xml.XmlNode.BaseURI%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="override this.CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlDocument.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep">Значение <see langword="true" /> для рекурсивного клонирования поддерева указанного узла; значение <see langword="false" /> для клонирования только самого узла.</param>
        <summary>Создает дубликат этого узла.</summary>
        <returns>Клонированный узел <see langword="XmlDocument" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод служит конструктор копии для узлов. Точная копия узла не имеет родителя (<xref:System.Xml.XmlNode.ParentNode%2A> возвращает `null`).  
  
 Если `deep` — `true`, точная копия узла включает в себя все дочерние узлы, в противном случае только `XmlDocument` узел клонирован. В разделе <xref:System.Xml.XmlNode.CloneNode%2A?displayProperty=nameWithType> метода, чтобы увидеть, как этот метод работает с другими типами узлов.  
  
   
  
## Examples  
 В следующем примере показано различие между полной и неполной копией.  
  
 [!code-cpp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает объект <see cref="T:System.Xml.XmlAttribute" /> с указанным именем.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (name As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateAttribute : string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя атрибута. Если имя содержит двоеточие, свойство <see cref="P:System.Xml.XmlNode.Prefix" /> отражает часть имени, предшествующую ему, а свойство <see cref="P:System.Xml.XmlDocument.LocalName" /> — ту часть, которая следует за первым двоеточием. Свойство <see cref="P:System.Xml.XmlNode.NamespaceURI" /> остается пустым, если префикс не является распознаваемым встроенным префиксом, например xmlns. В этом случае <see langword="NamespaceURI" /> имеет значение http://www.w3.org/2000/xmlns/.</param>
        <summary>Создает объект <see cref="T:System.Xml.XmlAttribute" /> с указанным <see cref="P:System.Xml.XmlDocument.Name" />.</summary>
        <returns>Новый объект <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` Можно добавить <xref:System.Xml.XmlElement> с помощью <xref:System.Xml.XmlElement.SetAttributeNode%2A> метод.  
  
   
  
## Examples  
 Следующие создает атрибут и добавляет его в XML-документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (qualifiedName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="member this.CreateAttribute : string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute (qualifiedName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Полное имя атрибута. Если имя содержит двоеточие, свойство <see cref="P:System.Xml.XmlNode.Prefix" /> отражает часть имени, предшествующую ему, а свойство <see cref="P:System.Xml.XmlDocument.LocalName" /> — ту часть, которая следует за двоеточием.</param>
        <param name="namespaceURI">URI пространства имен атрибута. Если полное имя содержит префикс xmlns, то этот параметр должен иметь значение http://www.w3.org/2000/xmlns/.</param>
        <summary>Создает <see cref="T:System.Xml.XmlAttribute" /> с помощью указанного полного имени и <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Новый объект <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` Можно добавить <xref:System.Xml.XmlElement> с помощью <xref:System.Xml.XmlElement.SetAttributeNode%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlAttribute CreateAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateAttribute : string * string * string -&gt; System.Xml.XmlAttribute&#xA;override this.CreateAttribute : string * string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Префикс атрибута (если имеется). String.Empty равно значению <see langword="null" />.</param>
        <param name="localName">Локальное имя атрибута.</param>
        <param name="namespaceURI">URI пространства имен атрибута (если имеется). String.Empty равно значению <see langword="null" />. Если значение параметра <c>prefix</c> равно xmlns, этот параметр должен иметь значение http://www.w3.org/2000/xmlns/. В противном случае возникает исключение.</param>
        <summary>Создает объект <see cref="T:System.Xml.XmlAttribute" /> с помощью указанных значений <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> и <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Новый объект <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` Можно добавить <xref:System.Xml.XmlElement> с помощью <xref:System.Xml.XmlElement.SetAttributeNode%2A> метод.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCDataSection">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlCDataSection CreateCDataSection (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlCDataSection CreateCDataSection(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateCDataSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateCDataSection (data As String) As XmlCDataSection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlCDataSection ^ CreateCDataSection(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateCDataSection : string -&gt; System.Xml.XmlCDataSection&#xA;override this.CreateCDataSection : string -&gt; System.Xml.XmlCDataSection" Usage="xmlDocument.CreateCDataSection data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlCDataSection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Содержимое нового класса <see langword="XmlCDataSection" />.</param>
        <summary>Создает объект <see cref="T:System.Xml.XmlCDataSection" />, содержащий указанные данные.</summary>
        <returns>Новый объект <see langword="XmlCDataSection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Согласно рекомендации W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) CDataSection узлы разрешены в пределах узлов элементов и узлов EntityReference при узел EntityReference не является потомком узла атрибута .  
  
   
  
## Examples  
 Следующий пример создает узел CDATA и добавляет его в документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlComment CreateComment (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlComment CreateComment(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateComment(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateComment (data As String) As XmlComment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlComment ^ CreateComment(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateComment : string -&gt; System.Xml.XmlComment&#xA;override this.CreateComment : string -&gt; System.Xml.XmlComment" Usage="xmlDocument.CreateComment data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlComment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Содержимое нового класса <see langword="XmlComment" />.</param>
        <summary>Создает объект <see cref="T:System.Xml.XmlComment" />, содержащий указанные данные.</summary>
        <returns>Новый объект <see langword="XmlComment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Согласно рекомендации W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) узлы комментариев, допустимы только в узлы документа, элемента и EntityReference, если узел EntityReference не является дочерним атрибута узел.  
  
   
  
## Examples  
 Следующий пример создает комментарий и добавляет его в XML-документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultAttribute">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XmlAttribute CreateDefaultAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDefaultAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XmlAttribute ^ CreateDefaultAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateDefaultAttribute : string * string * string -&gt; System.Xml.XmlAttribute&#xA;override this.CreateDefaultAttribute : string * string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateDefaultAttribute (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Префикс атрибута (если имеется).</param>
        <param name="localName">Локальное имя атрибута.</param>
        <param name="namespaceURI">URI пространства имен атрибута (если имеется).</param>
        <summary>Создает атрибут по умолчанию с помощью указанного префикса, локального имени и URI пространства имен.</summary>
        <returns>Новый объект <see cref="T:System.Xml.XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentFragment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentFragment CreateDocumentFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentFragment CreateDocumentFragment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentFragment" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentFragment () As XmlDocumentFragment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentFragment ^ CreateDocumentFragment();" />
      <MemberSignature Language="F#" Value="abstract member CreateDocumentFragment : unit -&gt; System.Xml.XmlDocumentFragment&#xA;override this.CreateDocumentFragment : unit -&gt; System.Xml.XmlDocumentFragment" Usage="xmlDocument.CreateDocumentFragment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentFragment</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает <see cref="T:System.Xml.XmlDocumentFragment" />.</summary>
        <returns>Новый объект <see langword="XmlDocumentFragment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Узлы DocumentFragment нельзя вставлять в документ. Однако дочерние узлы фрагмент документа можно вставить в документ.  
  
   
  
## Examples  
 В следующем примере добавляется новых узлов в XML-документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType CreateDocumentType (string name, string publicId, string systemId, string internalSubset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentType CreateDocumentType(string name, string publicId, string systemId, string internalSubset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentType (name As String, publicId As String, systemId As String, internalSubset As String) As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentType ^ CreateDocumentType(System::String ^ name, System::String ^ publicId, System::String ^ systemId, System::String ^ internalSubset);" />
      <MemberSignature Language="F#" Value="abstract member CreateDocumentType : string * string * string * string -&gt; System.Xml.XmlDocumentType&#xA;override this.CreateDocumentType : string * string * string * string -&gt; System.Xml.XmlDocumentType" Usage="xmlDocument.CreateDocumentType (name, publicId, systemId, internalSubset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="publicId" Type="System.String" />
        <Parameter Name="systemId" Type="System.String" />
        <Parameter Name="internalSubset" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя типа документа.</param>
        <param name="publicId">Общий идентификатор типа документа или значение <see langword="null" />. Вы можете указать общий URI и идентификатор системы для определения местоположения внешнего поднабора DTD.</param>
        <param name="systemId">Системный идентификатор типа документа или значение <see langword="null" />. Задает URL-адрес местоположения файла внешнего поднабора DTD.</param>
        <param name="internalSubset">Внутреннее подмножество DTD типа документа или значение <see langword="null" />.</param>
        <summary>Возвращает новый объект <see cref="T:System.Xml.XmlDocumentType" />.</summary>
        <returns>Новый объект <see langword="XmlDocumentType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемый узел будет содержать проанализированные <xref:System.Xml.XmlDocumentType.Entities%2A> и <xref:System.Xml.XmlDocumentType.Notations%2A> коллекции.  
  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Согласно рекомендации W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) узлы DocumentType разрешены только в пределах узлов документа. Каждый <xref:System.Xml.XmlDocument> может иметь только один узел DocumentType. Узел DocumentType должен также быть вставлен перед корневым элементом `XmlDocument` (если документ уже имеет корневой элемент, не может добавить узел DocumentType).  
  
 Если переданные параметры не объединены для построения допустимого `XmlDocumentType`, создается исключение.  
  
   
  
## Examples  
 Следующий пример создает узел DocumentType и добавляет его в XML-документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Этот метод имеет требования наследования. Требуется полное доверие для переопределения <see langword="CreateDocumentType" /> метод.  Этот метод является расширением Microsoft для модели объекта документа (DOM).</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает <see cref="T:System.Xml.XmlElement" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (name As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя элемента. Если имя содержит двоеточие, свойство <see cref="P:System.Xml.XmlNode.Prefix" /> отражает часть имени, предшествующую ему, а свойство <see cref="P:System.Xml.XmlDocument.LocalName" /> — ту часть, которая следует за двоеточием. Полное имя не может содержать префикс "xmlns".</param>
        <summary>Создает элемент с указанным именем.</summary>
        <returns>Новый объект <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что экземпляр возвращается реализует `XmlElement` интерфейс, поэтому атрибуты по умолчанию будет создан непосредственно в возвращаемом объекте.  
  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Согласно рекомендации W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), узлы элемента разрешены внутри узлов документа и элемента и в узлов EntityReference при узел EntityReference, не является потомком Узел атрибута.  
  
   
  
## Examples  
 Следующий пример создает новый элемент и добавляет его в документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (qualifiedName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string * string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement (qualifiedName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Полное имя элемента. Если имя содержит двоеточие, свойство <see cref="P:System.Xml.XmlNode.Prefix" /> отражает часть имени, предшествующую ему, а свойство <see cref="P:System.Xml.XmlDocument.LocalName" /> — ту часть, которая следует за двоеточием. Полное имя не может содержать префикс "xmlns".</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Создает <see cref="T:System.Xml.XmlElement" /> с помощью полного имени и <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Новый объект <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующий код C#  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy:item", "urn:abc");  
```  
  
 Возвращает элемент, эквивалентный следующему тексту XML.  
  
```  
<xy:item  
       xmlns:xy="urn:abc"/>  
```  
  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Согласно рекомендации W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), узлы элемента разрешены внутри узлов документа и элемента и в узлов EntityReference при узел EntityReference, не является потомком Узел атрибута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateElement (prefix As String, localName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ CreateElement(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateElement : string * string * string -&gt; System.Xml.XmlElement&#xA;override this.CreateElement : string * string * string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Префикс нового элемента (если имеется). String.Empty равно значению <see langword="null" />.</param>
        <param name="localName">Локальное имя нового элемента.</param>
        <param name="namespaceURI">URI пространства имен нового элемента (если имеется). String.Empty равно значению <see langword="null" />.</param>
        <summary>Создает элемент с помощью указанных <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> и <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Новый объект <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующий код C#  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy", "item", "urn:abc");  
```  
  
 Создает элемент, эквивалентный следующему тексту XML:  
  
```  
<xy:item xmlns:xy="urn:abc"/>  
```  
  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Согласно рекомендации W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) узлы элемента разрешены внутри узлов документа и элемента и в узлов EntityReference EntityReference находится вне узла атрибута.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 Следующий пример добавляет новый элемент, существующий XML-документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateEntityReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEntityReference (name As String) As XmlEntityReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlEntityReference ^ CreateEntityReference(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member CreateEntityReference : string -&gt; System.Xml.XmlEntityReference&#xA;override this.CreateEntityReference : string -&gt; System.Xml.XmlEntityReference" Usage="xmlDocument.CreateEntityReference name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя ссылки на сущность.</param>
        <summary>Создает объект <see cref="T:System.Xml.XmlEntityReference" /> с указанным именем.</summary>
        <returns>Новый объект <see langword="XmlEntityReference" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если упоминаемая сущность известно, к дочернему списку `XmlEntityReference` становится таким же, как и для соответствующего узла <xref:System.Xml.XmlEntity> узла.  
  
 Пространства имен, используемые при замене текста для ссылки на сущность, привязываются к моменту изначально устанавливается родительского узла ссылки на сущность (например, при вставке узла ссылки на сущность в документ). Рассмотрим следующие сущности:  
  
```  
<!ENTITY a "<b>test</b>">  
```  
  
 При вызове метода `CreateEntityReference("a")` возвращается один узел с типом EntityReference без дочерних узлов. Если добавить этот узел как дочерний следующий узел:  
  
```  
<item xmlns="urn:1"/>  
```  
  
 Затем, во время вызова метода <xref:System.Xml.XmlNode.AppendChild%2A>, задать родительский узел ссылки на созданную сущность и дочерние элементы будут развернуты в данном контексте пространства имен. Дочерний узел элемента `b` будет иметь NamespaceURI равно `urn:1`. Дочерние узлы ссылки на сущность остаются одинаковыми, даже при перемещении ссылки на сущность в место в документе, который содержит пространство имен по умолчанию другой контекст. Этого не происходит для существующих узлов ссылки сущности при удалении и добавлении или для ссылок на сущности, можно клонировать с <xref:System.Xml.XmlDocument.CloneNode%2A>. Это происходит только для вновь созданных ссылок на сущности.  
  
 Если соответствующая сущность не определен в DocumentType при добавлении узла ссылки на сущность, так как ссылки на сущности не определен, его только дочерний узел будет пустым текстовым узлом.  
  
 Встроенные сущности amp, lt, gt, apos и quot также разрешены, и они будут иметь дочерний текстовый узел с соответствующим развернутым символьным значением.  
  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Согласно рекомендации W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) узлов EntityReference разрешены только в пределах узлов элементов, атрибутов и EntityReference.  
  
   
  
## Examples  
 Следующий пример создает две ссылки на сущности и вставляет их в XML-документа.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимое имя (например, имена, начинающиеся с символа "#", являются недопустимыми.)</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNavigator">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Xml.XPath.XPathNavigator" /> для навигации в данном документе.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public override System.Xml.XPath.XPathNavigator CreateNavigator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateNavigator () As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XPath::XPathNavigator ^ CreateNavigator();" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : unit -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDocument.CreateNavigator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Xml.XPath.XPathNavigator" /> для навигации в данном документе.</summary>
        <returns>Объект <see cref="T:System.Xml.XPath.XPathNavigator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 В разделе <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> пример использования этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateNavigator (node As XmlNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::XmlNode ^ node);" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : System.Xml.XmlNode -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDocument.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="node">Узел <see cref="T:System.Xml.XmlNode" />, который будет служить исходной позицией навигатора.</param>
        <summary>Создает объект <see cref="T:System.Xml.XPath.XPathNavigator" /> для навигации в данном документе, расположенном в указанном узле <see cref="T:System.Xml.XmlNode" />.</summary>
        <returns>Объект <see cref="T:System.Xml.XPath.XPathNavigator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 В разделе <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> пример использования этого метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNode">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает <see cref="T:System.Xml.XmlNode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (string nodeTypeString, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (nodeTypeString As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::String ^ nodeTypeString, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : string * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : string * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (nodeTypeString, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeTypeString" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nodeTypeString">Строковая версия типа <see cref="T:System.Xml.XmlNodeType" /> нового узла. Этот параметр должен принимать одно из значений, перечисленных в следующей таблице.</param>
        <param name="name">Полное имя нового узла. Если имя содержит двоеточие, оно разбивается на компоненты <see cref="P:System.Xml.XmlNode.Prefix" /> и <see cref="P:System.Xml.XmlDocument.LocalName" />.</param>
        <param name="namespaceURI">URI пространства имен нового узла.</param>
        <summary>Создает <see cref="T:System.Xml.XmlNode" /> с помощью указанного типа узла, а также свойств <see cref="P:System.Xml.XmlDocument.Name" /> и <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Новый объект <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `nodeTypeString` Параметр учитывается регистр символов и должен иметь одно из значений в таблице ниже.  
  
|nodeTypeString|Тип узла XML|  
|--------------------|-----------------|  
|Атрибут|Атрибут|  
|cdatasection|CDATA|  
|комментарий|Комментарий|  
|документ|Document|  
|фрагмент документа|DocumentFragment|  
|Тип документа|DocumentType;|  
|элемент|Элемент|  
|EntityReference|EntityReference|  
|ProcessingInstruction|ProcessingInstruction;|  
|SignificantWhitespace|SignificantWhitespace|  
|текст|Text|  
|whitespace|Whitespace|  
  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Следующая таблица показывает, какой тип узла [строка] допускается внутри другой NodeType [столбец] в соответствии с рекомендацией W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||Document|DocumentType;|XmlDeclaration|Элемент|Атрибут|Text|CDATA|Разметка|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|  
|`DocumentType`|да|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|  
|`XmlDeclaration`|Да *|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|  
|`Element`|да|Нет|Нет|да|Нет|Нет|Нет|Нет|Да ***|  
|`Attribute`|Нет|Нет|Нет|Да ***|Нет|Нет|Нет|Нет|Нет|  
|`Text`|Нет|Нет|Нет|да|да|Нет|Нет|Нет|да|  
|`CDATA`|Нет|Нет|Нет|да|Нет|Нет|Нет|Нет|Да ***|  
|`Markup**`|да|Нет|Нет|да|Нет|Нет|Нет|Нет|Нет|  
|`EntityReference`|Нет|Нет|Нет|да|да|Нет|Нет|Нет|да|  
  
 \* Узел XmlDeclaration должен быть первый дочерний узел документа.  
  
 ** Разметки включает узлов ProcessingInstruction и комментарий.  
  
 Узлы элемента и CDATA разрешены только в узлов EntityReference, если узел EntityReference не является дочерним узлом атрибута.  
  
 Атрибуты не являются потомками узла элемента. Они содержатся в коллекции атрибутов, к которому принадлежит узел элемента.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 Следующий пример создает новый элемент и вставляет его в документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя не было указано и <see langword="XmlNodeType" /> требует имени; или <paramref name="nodeTypeString" /> не является одной из перечисленных ниже строк.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : System.Xml.XmlNodeType * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : System.Xml.XmlNodeType * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (type, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see langword="XmlNodeType" /> нового узла.</param>
        <param name="name">Полное имя нового узла. Если имя содержит двоеточие, оно разбивается на компоненты <see cref="P:System.Xml.XmlNode.Prefix" /> и <see cref="P:System.Xml.XmlDocument.LocalName" />.</param>
        <param name="namespaceURI">URI пространства имен нового узла.</param>
        <summary>Создает объект <see cref="T:System.Xml.XmlNode" /> с помощью указанных значений <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlDocument.Name" /> и <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Новый объект <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Следующая таблица показывает, какой тип узла [строка] допускается внутри другой NodeType [столбец] в соответствии с рекомендацией W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||Document|DocumentType;|XmlDeclaration|Элемент|Атрибут|Text|CDATA|Разметка|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|  
|`DocumentType`|да|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|  
|`XmlDeclaration`|Да *|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|  
|`Element`|да|Нет|Нет|да|Нет|Нет|Нет|Нет|Да ***|  
|`Attribute`|Нет|Нет|Нет|Да ***|Нет|Нет|Нет|Нет|Нет|  
|`Text`|Нет|Нет|Нет|да|да|Нет|Нет|Нет|да|  
|`CDATA`|Нет|Нет|Нет|да|Нет|Нет|Нет|Нет|Да ***|  
|`Markup**`|да|Нет|Нет|да|Нет|Нет|Нет|Нет|Нет|  
|`EntityReference`|Нет|Нет|Нет|да|да|Нет|Нет|Нет|да|  
  
 \* Узел XmlDeclaration должен быть первый дочерний узел документа.  
  
 ** Разметки включает узлов ProcessingInstruction и комментарий.  
  
 Узлы элемента и CDATA разрешены только в узлов EntityReference, если узел EntityReference не является дочерним узлом атрибута.  
  
 Атрибуты не являются потомками узла элемента. Они содержатся в коллекции атрибутов, к которому принадлежит узел элемента.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 Следующий пример создает новый элемент и вставляет его в XML-документа.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя не указано, а для <see langword="XmlNodeType" /> требуется имя.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, prefix As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ prefix, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : System.Xml.XmlNodeType * string * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : System.Xml.XmlNodeType * string * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (type, prefix, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип <see langword="XmlNodeType" /> нового узла.</param>
        <param name="prefix">Префикс нового узла.</param>
        <param name="name">Локальное имя нового узла.</param>
        <param name="namespaceURI">URI пространства имен нового узла.</param>
        <summary>Создает объект <see cref="T:System.Xml.XmlNode" /> с помощью указанных типов <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.Name" /> и <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Новый объект <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Следующая таблица показывает, какой тип узла [строка] допускается внутри другой NodeType [столбец] в соответствии с рекомендацией W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||Document|DocumentType;|XmlDeclaration|Элемент|Атрибут|Text|CDATA|Разметка|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|  
|`DocumentType`|да|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|  
|`XmlDeclaration`|Да *|Нет|Нет|Нет|Нет|Нет|Нет|Нет|Нет|  
|`Element`|да|Нет|Нет|да|Нет|Нет|Нет|Нет|Да ***|  
|`Attribute`|Нет|Нет|Нет|Да ***|Нет|Нет|Нет|Нет|Нет|  
|`Text`|Нет|Нет|Нет|да|да|Нет|Нет|Нет|да|  
|`CDATA`|Нет|Нет|Нет|да|Нет|Нет|Нет|Нет|Да ***|  
|`Markup**`|да|Нет|Нет|да|Нет|Нет|Нет|Нет|Нет|  
|`EntityReference`|Нет|Нет|Нет|да|да|Нет|Нет|Нет|да|  
  
 \* Узел XmlDeclaration должен быть первый дочерний узел документа.  
  
 ** Разметки включает узлов ProcessingInstruction и комментарий.  
  
 Узлы элемента и CDATA разрешены только в узлов EntityReference, если узел EntityReference не является дочерним узлом атрибута.  
  
 Атрибуты не являются потомками узла элемента. Они содержатся в коллекции атрибутов, к которому принадлежит узел элемента.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 Следующий пример добавляет новый элемент в документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Имя не указано, а для <see langword="XmlNodeType" /> требуется имя.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProcessingInstruction">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlProcessingInstruction CreateProcessingInstruction (string target, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlProcessingInstruction CreateProcessingInstruction(string target, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateProcessingInstruction (target As String, data As String) As XmlProcessingInstruction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlProcessingInstruction ^ CreateProcessingInstruction(System::String ^ target, System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateProcessingInstruction : string * string -&gt; System.Xml.XmlProcessingInstruction&#xA;override this.CreateProcessingInstruction : string * string -&gt; System.Xml.XmlProcessingInstruction" Usage="xmlDocument.CreateProcessingInstruction (target, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlProcessingInstruction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Имя инструкции по обработке.</param>
        <param name="data">Данные для инструкции обработки.</param>
        <summary>Создает <see cref="T:System.Xml.XmlProcessingInstruction" /> с помощью указанного имени и данных.</summary>
        <returns>Новый объект <see langword="XmlProcessingInstruction" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Согласно рекомендации W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) узлов ProcessingInstruction допустимы только в узлы документа, элемента и EntityReference, если узел EntityReference не является дочерним узла атрибута.  
  
   
  
## Examples  
 Следующий пример создает узел ProcessingInstruction и добавляет его в документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSignificantWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSignificantWhitespace (text As String) As XmlSignificantWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlSignificantWhitespace ^ CreateSignificantWhitespace(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateSignificantWhitespace : string -&gt; System.Xml.XmlSignificantWhitespace&#xA;override this.CreateSignificantWhitespace : string -&gt; System.Xml.XmlSignificantWhitespace" Usage="xmlDocument.CreateSignificantWhitespace text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSignificantWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Строка должна содержать только следующие символы: &amp;#20; &amp;#10; &amp;#13; и &amp;#9;</param>
        <summary>Создает узел <see cref="T:System.Xml.XmlSignificantWhitespace" />.</summary>
        <returns>Новый узел <see langword="XmlSignificantWhitespace" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является расширением Microsoft для модели объекта документа (DOM). Он используется для форматирования документа вручную.  
  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
   
  
## Examples  
 В следующем примере добавляется значимые пробелы в документе.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTextNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlText CreateTextNode (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlText CreateTextNode(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateTextNode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTextNode (text As String) As XmlText" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlText ^ CreateTextNode(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateTextNode : string -&gt; System.Xml.XmlText&#xA;override this.CreateTextNode : string -&gt; System.Xml.XmlText" Usage="xmlDocument.CreateTextNode text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlText</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Текст для узла Text.</param>
        <summary>Создает объект <see cref="T:System.Xml.XmlText" /> с указанным текстом.</summary>
        <returns>Новый узел <see langword="XmlText" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 Согласно рекомендации W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) текстовые узлы разрешены только в пределах узлов элементов, атрибутов и EntityReference.  
  
   
  
## Examples  
 Следующий пример создает новый элемент и добавляет его в документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlWhitespace CreateWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlWhitespace CreateWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateWhitespace (text As String) As XmlWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlWhitespace ^ CreateWhitespace(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateWhitespace : string -&gt; System.Xml.XmlWhitespace&#xA;override this.CreateWhitespace : string -&gt; System.Xml.XmlWhitespace" Usage="xmlDocument.CreateWhitespace text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Строка должна содержать только следующие символы: &amp;#20; &amp;#10; &amp;#13; и &amp;#9;</param>
        <summary>Создает узел <see cref="T:System.Xml.XmlWhitespace" />.</summary>
        <returns>Новый узел <see langword="XmlWhitespace" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является расширением Microsoft для модели объекта документа (DOM). Он используется для форматирования документа вручную.  
  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
   
  
## Examples  
 В следующем примере добавляется пробел в документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXmlDeclaration">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDeclaration CreateXmlDeclaration (string version, string encoding, string standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateXmlDeclaration (version As String, encoding As String, standalone As String) As XmlDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDeclaration ^ CreateXmlDeclaration(System::String ^ version, System::String ^ encoding, System::String ^ standalone);" />
      <MemberSignature Language="F#" Value="abstract member CreateXmlDeclaration : string * string * string -&gt; System.Xml.XmlDeclaration&#xA;override this.CreateXmlDeclaration : string * string * string -&gt; System.Xml.XmlDeclaration" Usage="xmlDocument.CreateXmlDeclaration (version, encoding, standalone)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDeclaration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.String" />
        <Parameter Name="encoding" Type="System.String" />
        <Parameter Name="standalone" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="version">Номер версии должен быть равен 1.0.</param>
        <param name="encoding">Значение атрибута кодировки. Эта кодировка используется при сохранении <see cref="T:System.Xml.XmlDocument" /> в файле или потоке, поэтому она должна быть задана как строка, поддерживаемая классом <see cref="T:System.Text.Encoding" />. В противном случае в работе <see cref="M:System.Xml.XmlDocument.Save(System.String)" /> возникает сбой. Если она имеет значение <see langword="null" /> или String.Empty, метод <see langword="Save" /> не записывает атрибут кодировки в объявление XML и используется кодировка UTF-8, заданная по умолчанию.  Примечание. Если <see langword="XmlDocument" /> сохранен в <see cref="T:System.IO.TextWriter" /> или <see cref="T:System.Xml.XmlTextWriter" />, это значение кодировки не учитывается. Вместо нее используется кодировка <see langword="TextWriter" /> или <see langword="XmlTextWriter" />. Таким образом обеспечивается возможность чтения записанного XML в правильной кодировке.</param>
        <param name="standalone">Значение должно быть равно "yes" или "no". Если значение равно <see langword="null" /> или String.Empty, метод <see langword="Save" /> не записывает в объявление XML отдельный атрибут.</param>
        <summary>Создает узел <see cref="T:System.Xml.XmlDeclaration" /> с указанными значениями.</summary>
        <returns>Новый узел <see langword="XmlDeclaration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Атрибуты отображаются как специальные свойства на `XmlDeclaration` узла, а не как <xref:System.Xml.XmlAttribute> узлов.  
  
 Несмотря на то, что этот метод создает новый объект в контексте документа, он не добавляет автоматически новый объект в дереве документа. Чтобы добавить новый объект, необходимо явно вызвать один из методов вставки узла.  
  
 В соответствии с рекомендацией W3C языка (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210) `XmlDeclaration` узел должен быть первым узлом в документе.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 Следующий пример создает объявление XML и добавляет его в документ.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значения <paramref name="version" /> или <paramref name="standalone" /> отличаются от указанных выше.</exception>
        <altmember cref="T:System.Xml.XmlDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="DocumentElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement DocumentElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement DocumentElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentElement As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlElement ^ DocumentElement { System::Xml::XmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentElement : System.Xml.XmlElement" Usage="System.Xml.XmlDocument.DocumentElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает корень <see cref="T:System.Xml.XmlElement" /> для документа.</summary>
        <value>Объект <see langword="XmlElement" />, представляющий корень дерева XML-документов. Если корень не существует, возвращается значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример отображает корневой элемент XML-документа.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Выходные данные:**  
  
```  
<book genre="novel" ISBN="1-861001-57-5"><title>Pride And Prejudice</title></book>   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DocumentType As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocumentType ^ DocumentType { System::Xml::XmlDocumentType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentType : System.Xml.XmlDocumentType" Usage="System.Xml.XmlDocument.DocumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает узел, содержащий объявление DOCTYPE.</summary>
        <value>Класс <see cref="T:System.Xml.XmlNode" />, содержащий DocumentType (объявление DOCTYPE).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument` Может иметь только один дочерний элемент с <xref:System.Xml.XmlNodeType> равным DocumentType.  
  
> [!NOTE]
>  Это свойство доступно только для чтения. Чтобы изменить узел DocumentType, удалите существующий узел, создать новую один, используя <xref:System.Xml.XmlDocument.CreateDocumentType%2A> метода и добавить новый узел в документе.  
  
   
  
## Examples  
 Следующий пример получает и отображает объявление DOCTYPE для документа.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlDocumentType" />
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement GetElementById (string elementId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement GetElementById(string elementId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementById (elementId As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ GetElementById(System::String ^ elementId);" />
      <MemberSignature Language="F#" Value="abstract member GetElementById : string -&gt; System.Xml.XmlElement&#xA;override this.GetElementById : string -&gt; System.Xml.XmlElement" Usage="xmlDocument.GetElementById elementId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementId">Идентификатор атрибута для сопоставления.</param>
        <summary>Возвращает элемент <see cref="T:System.Xml.XmlElement" /> с указанным идентификатором.</summary>
        <returns>Элемент <see langword="XmlElement" /> с соответствующим кодом или значение <see langword="null" />, если соответствующий элемент не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если документ имеет несколько элементов с соответствующим кодом, этот метод возвращает первый соответствующий элемент в документе.  
  
> [!NOTE]
>  Реализация DOM должна содержать информацию, которая определяет, какие атрибуты имеют тип ID. Несмотря на то, что атрибуты типа ID могут определяться в XSD-схемы или DTD, данная версия продукта поддерживает только определенные в DTD. Атрибуты с именем «ID» не имеют идентификатор типа, если это не определено в DTD. Реализации, где неизвестно, являются ли атрибуты типа ID должны возвращать `null`.  
  
   
  
## Examples  
 В следующем примере используется метод `GetElementById`.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/VB/source.vb#1)]  
  
 В примере используется файл `ids.xml`, в качестве входных данных.  
  
```xml  
<!DOCTYPE root [  
  <!ELEMENT root ANY>   
  <!ELEMENT Person ANY>   
  <!ELEMENT Customer EMPTY>  
  <!ELEMENT Team EMPTY>  
  <!ATTLIST Person SSN ID #REQUIRED>  
  <!ATTLIST Customer id IDREF #REQUIRED >  
  <!ATTLIST Team members IDREFS #REQUIRED]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetElementsByTagName">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение <see cref="T:System.Xml.XmlNodeList" />, содержащее список всех элементов потомков, соответствующих указанному имени.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (name As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string -&gt; System.Xml.XmlNodeList" Usage="xmlDocument.GetElementsByTagName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Сопоставляемое полное имя. Оно противопоставляется свойству <see langword="Name" /> соответствующего узла. Специальное значение "*" соответствует всем тегам.</param>
        <summary>Возвращает значение <see cref="T:System.Xml.XmlNodeList" />, содержащее список всех элементов-потомков, соответствующих указанному имени <see cref="P:System.Xml.XmlDocument.Name" />.</summary>
        <returns>Класс <see cref="T:System.Xml.XmlNodeList" />, содержащий список всех соответствующих узлов. Если ни один из узлов не соответствует <paramref name="name" />, возвращаемая коллекция будет пустой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Узлы располагаются в порядке, в котором они будут обнаружены в документе.  
  
> [!NOTE]
>  Рекомендуется использовать <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> или <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> вместо метода <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> метод.  
  
   
  
## Examples  
 В следующем примере создается `XmlDocument` объекта и использует `GetElementsByTagName` метод и итоговый <xref:System.Xml.XmlNodeList> объекта для отображения всех заголовков книг.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 В примере в качестве входных данных используется файл `books.xml`.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (localName As String, namespaceURI As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string * string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string * string -&gt; System.Xml.XmlNodeList" Usage="xmlDocument.GetElementsByTagName (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Сопоставляемый параметр LocalName. Специальное значение "*" соответствует всем тегам.</param>
        <param name="namespaceURI">Сопоставляемый параметр NamespaceURI.</param>
        <summary>Возвращает <see cref="T:System.Xml.XmlNodeList" />, содержащий список всех элементов-потомков, соответствующих указанным значениям <see cref="P:System.Xml.XmlDocument.LocalName" /> и <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Класс <see cref="T:System.Xml.XmlNodeList" />, содержащий список всех соответствующих узлов. Если ни один из узлов не соответствует указанным параметрам <paramref name="localName" /> и <paramref name="namespaceURI" />, возвращаемая коллекция будет пустой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Узлы располагаются в порядке, в котором они будут обнаружены в дереве документа.  
  
> [!NOTE]
>  Рекомендуется использовать <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> или <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> вместо метода <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Implementation">
      <MemberSignature Language="C#" Value="public System.Xml.XmlImplementation Implementation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlImplementation Implementation" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Implementation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Implementation As XmlImplementation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlImplementation ^ Implementation { System::Xml::XmlImplementation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Implementation : System.Xml.XmlImplementation" Usage="System.Xml.XmlDocument.Implementation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlImplementation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Xml.XmlImplementation" /> для текущего документа.</summary>
        <value>Объект <see langword="XmlImplementation" /> для текущего документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument` объекты, созданные из того же `XmlImplementation` одного и того же <xref:System.Xml.XmlNameTable>. Это позволяет сравнивать имена атрибутов и элементов как объекты, а не строк.  
  
 Несмотря на то что `XmlDocument` объекты, совместно используют одну реализацию, для перемещения узлов из одного документа в другой необходимо использовать <xref:System.Xml.XmlDocument.ImportNode%2A> метода.  
  
   
  
## Examples  
 В следующем примере создается новый `XmlDocument` с помощью реализации другого документа.  
  
 [!code-cpp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ImportNode (System.Xml.XmlNode node, bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ImportNode(class System.Xml.XmlNode node, bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportNode (node As XmlNode, deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ImportNode(System::Xml::XmlNode ^ node, bool deep);" />
      <MemberSignature Language="F#" Value="abstract member ImportNode : System.Xml.XmlNode * bool -&gt; System.Xml.XmlNode&#xA;override this.ImportNode : System.Xml.XmlNode * bool -&gt; System.Xml.XmlNode" Usage="xmlDocument.ImportNode (node, deep)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="node">Импортируемый узел.</param>
        <param name="deep">Значение <see langword="true" /> — выполняется полное точное клонирование; в противном случае — <see langword="false" />.</param>
        <summary>Импортирует в текущий документ узел из другого документа.</summary>
        <returns>Импортированный <see cref="T:System.Xml.XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемый узел не имеет родителя. Исходный узел не будет изменен или удален из исходного документа; `ImportNode` создает копию исходного узла.  
  
 Импорт узла создает `XmlNode` объект, принадлежащий пользователю импортирования документа с <xref:System.Xml.XmlNode.Name%2A> и <xref:System.Xml.XmlNode.NodeType%2A> идентична исходный узел. Новый объект также имеет атрибуты, связанные с пространствами имен (<xref:System.Xml.XmlNode.Prefix%2A>, <xref:System.Xml.XmlNode.LocalName%2A>, и <xref:System.Xml.XmlNode.NamespaceURI%2A>).  
  
 В зависимости от типа импортированного узла и значения `deep` параметр дополнительной информацией копируется соответствующим образом. Этот метод пытается отразить ожидаемое поведение, если фрагмент источника XML или HTML копируется из одного документа в другой (распознает, что в случае XML два документа могут иметь различные DTD).  
  
 В следующей таблице описаны определенное поведение для каждого <xref:System.Xml.XmlNodeType>.  
  
|Тип узла XML|ImportNode(true)|ImportNode(false)|  
|-----------------|------------------------|-------------------------|  
|Атрибут|<xref:System.Xml.XmlAttribute.Specified%2A> Свойству `true` в созданных <xref:System.Xml.XmlAttribute>. Потомки исходного `XmlAttribute` рекурсивно импортируются, а результирующие узлы создаются заново и составляют соответствующее поддерево.|`deep` Параметр не применяется к `XmlAttribute` узлы, они всегда импортируются вместе со своими дочерними при импорте.|  
|CData|Копирует узел вместе с данными.|Копирует узел вместе с данными.|  
|Комментарий|Копирует узел вместе с данными.|Копирует узел вместе с данными.|  
|DocumentFragment|Потомки исходного узла рекурсивно импортируются, а результирующие узлы создаются заново и составляют соответствующее поддерево.|Пустой <xref:System.Xml.XmlDocumentFragment> создается.|  
|DocumentType;|Копирует узел вместе с данными.*|Копирует узел вместе с данными.*|  
|Элемент|Потомки исходного элемента и его указанные узлы атрибутов — рекурсивно импортируются, а результирующие узлы создаются заново и составляют соответствующее поддерево.<br /><br /> Примечание: Атрибуты по умолчанию не копируются. Если документ, в который выполняется импорт, определяет атрибуты по умолчанию для данного имени элемента, они назначаются.|Указанный атрибут узлы исходного элемента импортируются, а сформированные `XmlAttribute` узлы присоединяются к созданным <xref:System.Xml.XmlElement>.<br /><br /> Примечание: Атрибуты по умолчанию не копируются. Если документ, в который выполняется импорт, определяет атрибуты по умолчанию для данного имени элемента, они назначаются.|  
|EntityReference|Так как исходный и конечный документы могут иметь по-разному определенные сущности, этот метод копирует только <xref:System.Xml.XmlEntityReference> узла. Текст замены не включается. Если в документе назначения определена сущность, ей назначается значение.|Так как исходный и конечный документы могут иметь по-разному определенные сущности, этот метод копирует только <xref:System.Xml.XmlEntityReference> узла. Текст замены не включается. Если в документе назначения определена сущность, ей назначается значение.|  
|ProcessingInstruction;|Копирует цель и значение данных из импортируемого узла.|Копирует цель и значение данных из импортируемого узла.|  
|Text|Копирует узел вместе с данными.|Копирует узел вместе с данными.|  
|SignificantWhitespace|Копирует узел вместе с данными.|Копирует узел вместе с данными.|  
|Whitespace|Копирует узел вместе с данными.|Копирует узел вместе с данными.|  
|XmlDeclaration|Копирует цель и значение данных из импортируемого узла.|Копирует цель и значение данных из импортируемого узла.|  
|Все прочие типы узлов.|Эти типы узлов импортировать нельзя.|Эти типы узлов импортировать нельзя.|  
  
 * Хотя узлы DocumentType можно импортировать, документ может иметь только один узел DocumentType. Если документ в настоящее время имеет узел DocumenType, его необходимо удалить перед добавлением нового.  
  
   
  
## Examples  
 В следующем примере выполняется импорт узла книги из второго XML-документа в исходный XML-документ.  
  
 [!code-cpp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/VB/source.vb#1)]  
  
 В примере используется файл `books.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Вызов этого метода для типа узла, который не может быть импортирован.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public override string InnerText { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerText {  void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string" Usage="System.Xml.XmlDocument.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Во всех случаях вызывает исключение <see cref="T:System.InvalidOperationException" />.</summary>
        <value>Значения узла и всех его дочерних узлов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство не реализовано.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Во всех случаях.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerXml">
      <MemberSignature Language="C#" Value="public override string InnerXml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerXml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerXml : string with get, set" Usage="System.Xml.XmlDocument.InnerXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает разметку, отражающую дочерние узлы текущего узла.</summary>
        <value>Разметка дочерних узлов текущего узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задание этого свойства дочерние узлы заменяются разобранный содержимым заданной строки. Синтаксический анализ выполняется в контексте текущего пространства имен.  
  
 `InnerXml` Удаляет избыточные объявления пространств имен. В результате после многочисленных операций вырезания и вставки размер документа не будет увеличиваться за счет избыточных деклараций пространств имен. Рассмотрим следующий документ XSL:  
  
```xml  
<xsl:stylesheet version="1.0"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     <xsl:template match="stock">  
         ...  
     </xsl:template>  
    </xsl:stylesheet>  
```  
  
 `InnerXml` Свойства узла таблицы стилей возвращает следующую строку:  
  
```xml  
<xsl:template match="stock"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     ...  
    </xsl:template>  
```  
  
 Обратите внимание, объявление пространства имен xmlns: Дополнительные XSL, которое используется для идентификации узла. При повторной вставке этой внутренней строки XML, можно будет получить исходный документ. Другими словами `InnerXml` распознает, что объявление пространства имен xmlns: XSL является избыточным, учитывая, что родительский элемент xsl: stylesheet уже имеет имен xmlns: XSL и поэтому удаляет его.  
  
 При перемещении `InnerXml` из документа без пространства имен по умолчанию в документ с пространством имен по умолчанию, поведение будет немного отличаться. Рассмотрим следующую строку XML.  
  
```xml  
<test>  
      <item>123</item>  
    </test>  
```  
  
 `InnerXml` Возвращает обычную строку XML без объявлений пространств имен:  
  
```xml  
<item>123</item>  
```  
  
 Если затем вставить эту строку в документ, который имеет пространство имен по умолчанию, например следующие:  
  
```xml  
<test2 xmlns="urn:1">  
    </test>  
```  
  
 `InnerXml` Производит синтаксический анализ строки в контексте и новые узлы получают пространство имен urn: 1. Результат выглядит следующим образом:  
  
```xml  
<test2 xmlns="urn:1">  
      <item>123</item>  
    </test>  
```  
  
 Теперь при запросе `InnerXml` возвращена следующая:  
  
```xml  
<item xmlns="urn:1">123</item>  
```  
  
 Если требуется явным образом вставленного элемента сохранить тот факт, что он поступает из документа, не имеющего пространство имен, потребуется вручную добавить xmlns = «» объявление и вставить результирующую строку:  
  
```xml  
<item xmlns="">123</item>  
```  
  
 В итоге все, что это выглядит следующим образом:  
  
1.  Вырезание и вставка `InnerXml` между документами, которые не используют простой и четкий пространств имен и не создавать избыточность «xmlns» в строках.  
  
2.  `InnerXml` может также использоваться для вырезания и вставки в документах, имеющих несколько пространств имен (то есть таблицы стилей XSL).  
  
3.  объявления xmlns: xsl автоматически появляются в строках и исчезают в иерархиях узлов.  
  
4.  В случае, когда производится обновление `InnerXml` из документа, имеющего пространства имен по умолчанию, документ, который имеет пространство имен по умолчанию, новые узлы получают новое пространство имен по умолчанию.  
  
 Если `InnerXml` устанавливается с текстом, содержащим ссылки на сущности, которые в настоящее время не определены в документе, результирующее дерево будет содержать пустые узлы EntityReference.  
  
 Это свойство является расширением Microsoft для объектной модели документа (DOM).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Формат XML, указанный при задании этого свойства, является неправильным.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xml.XmlDocument.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, доступен ли текущий узел только для чтения.</summary>
        <value>Значение <see langword="true" />, если текущий узел доступен только для чтения; в противном случае — значение <see langword="false" />. Узлы <see langword="XmlDocument" /> всегда возвращают значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Узел, доступный только для чтения — нельзя изменять, свойства, атрибуты или дочерние элементы. Можно удалить только для чтения узел дерева и вставить его в другом месте.  
  
 Это свойство является расширением Microsoft для объектной модели документа (DOM).  
  
   
  
## Examples  
 В следующем примере показано, как использовать свойство `IsReadOnly`.  
  
 [!code-cpp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает указанные XML-данные из <see cref="T:System.IO.Stream" />, URL-адрес, <see cref="T:System.IO.TextReader" /> или <see cref="T:System.Xml.XmlReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (inStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::Stream ^ inStream);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.Stream -&gt; unit&#xA;override this.Load : System.IO.Stream -&gt; unit" Usage="xmlDocument.Load inStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">Поток, содержащий загружаемый документ XML.</param>
        <summary>Загружает XML-документ из указанного потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Метод всегда сохраняет значимые пробелы. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Свойство определяет, сохраняется ли незначащие пробельные символы, пробелы в содержимом элемента. Значение по умолчанию — `false`; пробел в содержимом элемента не сохраняется.  
  
 Если требуется выполнить проверку, можно создать проверяющий <xref:System.Xml.XmlReader> экземпляра с помощью <xref:System.Xml.XmlReaderSettings> класса и <xref:System.Xml.XmlReader.Create%2A> метод. Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
 Этот метод автоматически определяет формат строки входных данных XML (например, UTF-8, ANSI и т. д.). Если приложению необходимо знать, какая кодировка используется для чтения потока, рассмотрите возможность использования <xref:System.Xml.XmlTextReader> для чтения потока, а затем использовать <xref:System.Xml.XmlTextReader.Encoding%2A?displayProperty=nameWithType> свойство, чтобы определить кодировку. Если необходимо использовать <xref:System.Xml.XmlDocument> объекта для работы с XML, можно использовать <xref:System.Xml.XmlTextReader> объекта для ее создания. Дополнительные сведения см. в разделе [чтения XML-данных с помощью XPathDocument и XmlDocument](~/docs/standard/data/xml/reading-xml-data-using-xpathdocument-and-xmldocument.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Ошибка загрузки или синтаксического анализа в XML. В этом случае возникает <see cref="T:System.IO.FileNotFoundException" />.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (txtReader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::TextReader ^ txtReader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.TextReader -&gt; unit&#xA;override this.Load : System.IO.TextReader -&gt; unit" Usage="xmlDocument.Load txtReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">
          <see langword="TextReader" />, используемый для передачи данных XML в документ.</param>
        <summary>Загружает XML-документ из указанного <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Метод всегда сохраняет значимые пробелы. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Свойство определяет, сохраняется ли незначащие пробельные символы, пробелы в содержимом элемента. Значение по умолчанию — `false`; пробел в содержимом элемента не сохраняется.  
  
 Если требуется выполнить проверку, можно создать проверяющий <xref:System.Xml.XmlReader> экземпляра с помощью <xref:System.Xml.XmlReaderSettings> класса и <xref:System.Xml.XmlReader.Create%2A> метод. Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.IO.StringReader> класс загрузить строку XML-данных в `XmlDocument` объекта.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Ошибка загрузки или синтаксического анализа в XML. В этом случае документ остается пустым.</exception>
        <altmember cref="T:System.IO.StreamReader" />
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; unit&#xA;override this.Load : string -&gt; unit" Usage="xmlDocument.Load filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">URL-адрес файла, содержащего загружаемый документ XML. URL-адрес может ссылаться на локальный файл или являться HTTP-ссылкой (веб-адресом).</param>
        <summary>Загружает XML-документ из указанного URL-адреса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Метод всегда сохраняет значимые пробелы. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Свойство определяет, сохраняется ли незначащие пробельные символы, пробелы в содержимом элемента. Значение по умолчанию — `false`; пробел в содержимом элемента не сохраняется.  
  
 Если требуется выполнить проверку, можно создать проверяющий <xref:System.Xml.XmlReader> экземпляра с помощью <xref:System.Xml.XmlReaderSettings> класса и <xref:System.Xml.XmlReader.Create%2A> метод. Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Ошибка загрузки или синтаксического анализа в XML. В этом случае возникает <see cref="T:System.IO.FileNotFoundException" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="filename" /> представляет собой строку нулевой длины, содержащую только пробелы или один или несколько недопустимых символов, заданных методом <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="filename" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Указанный путь, имя файла или оба значения превышают максимальную длину, заданную в системе.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Указан недопустимый путь (например, он ведет на несопоставленный диск).</exception>
        <exception cref="T:System.IO.IOException">При открытии файла произошла ошибка ввода-вывода.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Параметр <paramref name="filename" /> указывает файл, доступный только для чтения.  -или- Эта операция не поддерживается на текущей платформе.  -или- <paramref name="filename" /> задает каталог.  -или- У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл, заданный параметром <paramref name="filename" />, не найден.</exception>
        <exception cref="T:System.NotSupportedException">Параметр <paramref name="filename" /> задан в недопустимом формате.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Xml.XmlReader -&gt; unit&#xA;override this.Load : System.Xml.XmlReader -&gt; unit" Usage="xmlDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="XmlReader" />, используемый для передачи данных XML в документ.</param>
        <summary>Загружает XML-документ из указанного <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` Метод всегда сохраняет значимые пробелы. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> Свойство определяет, сохраняется ли незначащие пробельные символы, пробелы в содержимом элемента. Значение по умолчанию — `false`; пробел в содержимом элемента не сохраняется.  
  
 Если средство чтения находится в начальном состоянии (<xref:System.Xml.XmlReader.ReadState%2A> = ReadState.Initial), `Load` использует все содержимое средства чтения и строит модель DOM он находит.  
  
 Если средство чтения уже позиционирован на некотором узле с глубиной «n», этот метод загружает этот узел и все дочерние области вплоть до закрывающего тега, закрывающего глубину «n». Это дает следующие результаты.  
  
 Если текущий узел и дочерние области выглядят следующим образом:  
  
```xml  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load` создает исключение, так как документ не может иметь два элемента корневого уровня. Если текущий узел и дочерние области выглядят следующим образом:  
  
```xml  
<!--comment--><?process instruction?><!--comment--></endtag>  
```  
  
 `Load` завершается успешно, но неполное дерево DOM, поскольку отсутствует элемент корневого уровня. Прежде чем сохранять документ, необходимо добавить элемент корневого уровня, в противном случае <xref:System.Xml.XmlDocument.Save%2A> вызовет исключение.  
  
 Если средство чтения находится на конечном узле, недопустимом для корневого уровня документа, например, пробел или узел атрибута, средство чтения продолжает считывание до размещения на узле, который может использоваться в качестве корневого. Документ начинает загружаться в этой точке.  
  
 Если требуется выполнить проверку, можно создать проверяющий <xref:System.Xml.XmlReader> экземпляра с помощью <xref:System.Xml.XmlReaderSettings> класса и <xref:System.Xml.XmlReader.Create%2A> метод. Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 В следующем примере загружаются последнего узла книги из `books.xml` файла в XML-документ.  
  
 [!code-cpp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/VB/source.vb#1)]  
  
 В примере используется файл `books.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Ошибка загрузки или синтаксического анализа в XML. В этом случае документ остается пустым.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="LoadXml">
      <MemberSignature Language="C#" Value="public virtual void LoadXml (string xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadXml(string xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadXml (xml As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadXml(System::String ^ xml);" />
      <MemberSignature Language="F#" Value="abstract member LoadXml : string -&gt; unit&#xA;override this.LoadXml : string -&gt; unit" Usage="xmlDocument.LoadXml xml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">Строка, содержащая загружаемый XML-документ.</param>
        <summary>Загружает XML-документ из указанной строки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию `LoadXml` метод не сохраняет пробелы или значимые пробелы.  
  
 Этот метод выполняет синтаксический анализ определения DTD, но не выполняет проверку DTD или схемы. Если требуется выполнить проверку, можно создать проверяющий <xref:System.Xml.XmlReader> экземпляра с помощью <xref:System.Xml.XmlReaderSettings> класса и <xref:System.Xml.XmlReader.Create%2A> метод. Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 Если вы хотите загрузить из <xref:System.IO.Stream>, <xref:System.String>, <xref:System.IO.TextReader>, или <xref:System.Xml.XmlReader>, используйте метод загрузки, вместо этого метода.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 В следующем примере загружается XML-документ в `XmlDocument` объекта и его сохранение в файл.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Ошибка загрузки или синтаксического анализа в XML. В этом случае документ остается пустым.</exception>
        <altmember cref="P:System.Xml.XmlDocument.PreserveWhitespace" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlDocument.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает локальное имя узла.</summary>
        <value>Для узлов <see langword="XmlDocument" /> локальное имя равно #document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Локальное имя, возвращаемое зависит <xref:System.Xml.XmlDocument.NodeType%2A> узла. Таблицу, описывающую локальное имя, возвращаемое для каждого типа узла см. в разделе <xref:System.Xml.XmlNode.LocalName%2A> свойства <xref:System.Xml.XmlNode> класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlDocument.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает полное имя узла.</summary>
        <value>Для узлов <see langword="XmlDocument" /> имя равно #document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое имя зависит <xref:System.Xml.XmlDocument.NodeType%2A> узла. Таблицу, описывающую имя, возвращаемое для каждого из типов узлов см. в разделе <xref:System.Xml.XmlNode.Name%2A> свойства <xref:System.Xml.XmlNode> класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlDocument.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает класс <see cref="T:System.Xml.XmlNameTable" />, связанный с данной реализацией.</summary>
        <value>Класс <see langword="XmlNameTable" />, позволяющий получить атомизированную версию строки в документе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый `XmlDocument` объект имеет <xref:System.Xml.NameTable> объекта. Имена элементов и атрибутов хранятся в `NameTable` виде разделенных строк. Это означает, что даже если имя упоминается в документе несколько раз сохраняется только один раз в `NameTable`. Например, если документ имеет несколько элементов с именем «Customer» `NameTable` возвращает тот же объект всякий раз, когда он получает запрос на это имя. В результате пользователи можно написать код, используя сравнения объектов для этих строк, а не более ресурсоемкие сравнения строк.  
  
 Дополнительные сведения об атомизированных строках см. в разделе <xref:System.Xml.XmlNameTable>.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanged">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanged As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanged;" />
      <MemberSignature Language="F#" Value="member this.NodeChanged : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeChanged : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает при изменении свойства <see cref="P:System.Xml.XmlNode.Value" /> узла, принадлежащего данному документу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие применяется только к узлам, имеющим значение.  
  
 В этом случае включаются все узлы, созданные этим документом, независимо от того, имеется ли они были вставлены в документ.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanging">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanging As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanging;" />
      <MemberSignature Language="F#" Value="member this.NodeChanging : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeChanging : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает при намерении изменить свойство <see cref="P:System.Xml.XmlNode.Value" /> узла, принадлежащего данному документу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие позволяет пользователю выполнить дополнительную проверку и при необходимости создать исключение для остановки операции. Если исключение создается `XmlDocument` возвращает в исходное состояние. Это событие применяется только к узлам, имеющим значение.  
  
 В этом случае включаются все узлы, созданные этим документом, независимо от того, имеется ли они были вставлены в документ.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserted">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserted" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserted As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserted;" />
      <MemberSignature Language="F#" Value="member this.NodeInserted : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeInserted : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает после вставки узла, принадлежащего данному документу, в другой узел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этом случае включаются все узлы, созданные этим документом, независимо от того, имеется ли они были вставлены в документ.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserting">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserting" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserting As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserting;" />
      <MemberSignature Language="F#" Value="member this.NodeInserting : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeInserting : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает перед вставкой узла, принадлежащего данному документу, в другой узел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие позволяет пользователю выполнить дополнительную проверку и при необходимости создать исключение для остановки операции. Если исключение создается `XmlDocument` возвращает в исходное состояние.  
  
 В этом случае включаются все узлы, созданные этим документом, независимо от того, имеется ли они были вставлены в документ.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoved">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoved As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoved;" />
      <MemberSignature Language="F#" Value="member this.NodeRemoved : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeRemoved : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает после удаления узла, принадлежащего данному документу, из родительского узла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этом случае включаются все узлы, созданные этим документом, независимо от того, имеется ли они были вставлены в документ.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoving">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoving" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoving As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoving;" />
      <MemberSignature Language="F#" Value="member this.NodeRemoving : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeRemoving : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает перед удалением узла из документа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие позволяет пользователю выполнить дополнительную проверку и при необходимости создать исключение для остановки операции. Если исключение создается `XmlDocument` возвращает в исходное состояние.  
  
 В этом случае включаются все узлы, созданные этим документом, независимо от того, имеется ли они были вставлены в документ.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlDocument.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип текущего узла.</summary>
        <value>Тип узла. Для узлов <see langword="XmlDocument" /> это значение равно XmlNodeType.Document.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="OwnerDocument">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlDocument OwnerDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocument OwnerDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.OwnerDocument" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property OwnerDocument As XmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocument ^ OwnerDocument { System::Xml::XmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDocument : System.Xml.XmlDocument" Usage="System.Xml.XmlDocument.OwnerDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.Xml.XmlDocument" />, к которому принадлежит текущий узел.</summary>
        <value>Для узлов <see langword="XmlDocument" /> (<see cref="P:System.Xml.XmlDocument.NodeType" /> имеет значение XmlNodeType.Document) это свойство всегда возвращает значение <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode ParentNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode ParentNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.ParentNode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ParentNode As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ ParentNode { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentNode : System.Xml.XmlNode" Usage="System.Xml.XmlDocument.ParentNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает родительский узел для данного узла (только узлов, у которых они могут быть).</summary>
        <value>Всегда возвращает значение <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveWhitespace">
      <MemberSignature Language="C#" Value="public bool PreserveWhitespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public Property PreserveWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveWhitespace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreserveWhitespace : bool with get, set" Usage="System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, будут ли сохранены знаки-разделители в содержимом элемента.</summary>
        <value>Значение <see langword="true" />, если знак-разделитель будет сохранен; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство определяет способ обработки пробелов во время загрузки и сохранения процесса.  
  
 Если `PreserveWhitespace` — `true` перед <xref:System.Xml.XmlDocument.Load%2A> или <xref:System.Xml.XmlDocument.LoadXml%2A> — вызывается, узлы пробелов сохраняются; в противном случае, если это свойство имеет `false`, значимые пробелы сохраняются, пробел.  
  
 Если `PreserveWhitespace` — `true` перед <xref:System.Xml.XmlDocument.Save%2A> является именем, пробелы в документе сохраняются в выходных данных; в противном случае, если это свойство имеет `false`, `XmlDocument` автоматический отступ выходные данные.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
   
  
## Examples  
 В следующем примере показано, как удалить пробелы из файла.  
  
 [!code-cpp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/VB/source.vb#1)]  
  
 В примере используется файл `book.xml` в качестве входного.  
  
 [!code-xml[Classic WebData XmlDocument.PreserveWhitespace Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ReadNode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ReadNode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadNode (reader As XmlReader) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ReadNode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadNode : System.Xml.XmlReader -&gt; System.Xml.XmlNode&#xA;override this.ReadNode : System.Xml.XmlReader -&gt; System.Xml.XmlNode" Usage="xmlDocument.ReadNode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Источник XML</param>
        <summary>Создает объект <see cref="T:System.Xml.XmlNode" /> на основе данных из <see cref="T:System.Xml.XmlReader" />. Средство чтения должно быть позиционировано на узел или атрибут.</summary>
        <returns>Новый <see langword="XmlNode" /> или значение <see langword="null" />, если больше узлов не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Считывает один `XmlNode` из заданного средства чтения и перемещает средство чтения на следующий узел. Этот метод создает тип `XmlNode` сопоставления <xref:System.Xml.XmlNode.NodeType%2A> , на котором расположено средство чтения. (Если средство чтения находится в начальном состоянии `ReadNode` Перемещает модуль чтения на первый узел и затем работает на этом узле.)  
  
 Если средство чтения расположено в начале элемента, `ReadNode` считывает все атрибуты и дочерние узлы до и включая закрывающий тег текущего узла. `XmlNode` Вернул содержит поддерево, отражающее все считанные. Модуль чтения располагается сразу после закрывающего тега.  
  
 `ReadNode` может также считывать атрибуты, но в этом случае он перемещает средство чтения к следующему атрибуту. Это позволяет написать следующий код C#:  
  
```csharp  
XmlDocument doc = new XmlDocument();  
while (reader.MoveToNextAttribute())  
{  
  XmlNode a = doc.ReadNode(reader);  
  // Do some more processing.  
}  
```  
  
 `ReadNode` использует значение атрибута, то есть после вызова `ReadNode` на атрибуте, <xref:System.Xml.XmlReader.ReadAttributeValue%2A?displayProperty=nameWithType> возвращает `false`.  
  
   
  
## Examples  
 В следующем примере используется `ReadNode` , чтобы создать новый узел, а затем вставляет новый узел в документе.  
  
 [!code-cpp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/VB/source.vb#1)]  
  
 В примере используется файл `cd.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlDocument.ReadNode Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Средство чтения расположено на узле, тип которого не преобразуется в допустимый узел DOM (например, EndElement или EndEntity).</exception>
        <block subset="none" type="overrides">
          <para>Этот метод имеет требования наследования. Требуется полное доверие для переопределения <see langword="ReadNode" /> метод.  Этот метод является расширением Microsoft для модели объекта документа (DOM).</para>
        </block>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сохраняет XML-документ в указанном месте.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.Stream outStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.Stream outStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (outStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::Stream ^ outStream);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.IO.Stream -&gt; unit&#xA;override this.Save : System.IO.Stream -&gt; unit" Usage="xmlDocument.Save outStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="outStream">Поток, в который будет выполняться сохранение.</param>
        <summary>Сохраняет XML-документ в указанном потоке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пробелы сохраняются только в том случае, если <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> равно `true`.  
  
 XmlDeclaration текущего `XmlDocument` определяет атрибут кодировки в сохраненный документ. Значение атрибута кодировки берется из <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> свойство. Если `XmlDocument` does имеет XmlDeclaration или если XmlDeclaration не имеет атрибута кодировки, сохраненный документ не будет иметь одно либо.  
  
 При сохранении документа атрибуты xmlns создаются для правильного сохранения удостоверения узла (локальное имя + URI пространства имен). Например, следующий код C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 создает этот атрибут XML-файлы `<item xmls="urn:1"/>`.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
 Обратите внимание, что только <xref:System.Xml.XmlDocument.Save%2A> метод обеспечивает правильность XML-документа. Все остальные `Save` обеспечивают только правильный фрагмент.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Операция не приведет к созданию XML-документа с правильным форматом (например, в документе не будет элемента документа или будут повторяющиеся XML-объявления).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.IO.TextWriter -&gt; unit&#xA;override this.Save : System.IO.TextWriter -&gt; unit" Usage="xmlDocument.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see langword="TextWriter" />, в котором необходимо выполнить сохранение.</param>
        <summary>Сохраняет XML-документ в указанном <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка `TextWriter` определяет кодировку, записываемого (кодировка записываемую заменяется кодировку `TextWriter`). Если произошел кодировка не указана `TextWriter`, `XmlDocument` сохраняется без атрибута кодировки.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
 Обратите внимание, что только <xref:System.Xml.XmlDocument.Save%2A> метод обеспечивает правильность XML-документа. Все остальные `Save` обеспечивают только правильный фрагмент.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Операция не приведет к созданию XML-документа с правильным форматом (например, в документе не будет элемента документа или будут повторяющиеся XML-объявления).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Save : string -&gt; unit&#xA;override this.Save : string -&gt; unit" Usage="xmlDocument.Save filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Место в файле, где нужно сохранить документ.</param>
        <summary>Сохраняет XML-документ в указанном файле. Если указанный файл существует, метод перезаписывает его.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пробелы сохраняются в файл вывода, только если <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> равно `true`.  
  
 XmlDeclaration текущего `XmlDocument` определяет атрибут кодировки в сохраненный документ. Значение атрибута кодировки берется из <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> свойство. Если `XmlDocument` does имеет XmlDeclaration или если XmlDeclaration не имеет атрибута кодировки, сохраненный документ не будет иметь одно либо.  
  
 При сохранении документа атрибуты xmlns создаются для правильного сохранения удостоверения узла (локальное имя + URI пространства имен). Например, следующий код C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 создает этот атрибут XML-файлы `<item xmls="urn:1"/>`.  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
 Обратите внимание, что только <xref:System.Xml.XmlDocument.Save%2A> метод обеспечивает правильность XML-документа. Все остальные `Save` обеспечивают только правильный фрагмент.  
  
   
  
## Examples  
 Приведенный ниже показана загрузка XML в объект XmlDocument, его изменение и сохраняет его в файл с именем data.xml.  
  
 [!code-cpp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/VB/source.vb#1)]  
  
 Data.xml файл будет содержать следующий XML: `<item><name>wrench</name><price>10.95</price></item>`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Операция не приведет к созданию XML-документа с правильным форматом (например, в документе не будет элемента документа или будут повторяющиеся XML-объявления).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.Xml.XmlWriter -&gt; unit&#xA;override this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.Save w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">Объект <see langword="XmlWriter" />, в котором необходимо выполнить сохранение.</param>
        <summary>Сохраняет XML-документ в указанном <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пробелы сохраняются только в том случае, если <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> равно `true`.  
  
 Кодировка `XmlWriter` определяет кодировку, записываемого (кодировка записываемую заменяется кодировку `XmlWriter`). Если произошел кодировка не указана `XmlWriter`, `XmlDocument` сохраняется без атрибута кодировки.  
  
 При сохранении документа атрибуты xmlns создаются для правильного сохранения удостоверения узла (локальное имя + URI пространства имен). Например, следующий код C#  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 создает этот атрибут XML-файлы:  
  
```xml  
<item  
    xmls="urn:1"/>  
```  
  
 Этот метод является расширением Microsoft для модели объекта документа (DOM).  
  
 Обратите внимание, что только <xref:System.Xml.XmlDocument.Save%2A> метод обеспечивает правильность XML-документа. Все остальные `Save` обеспечивают только правильный фрагмент.  
  
   
  
## Examples  
 В следующем примере загружается XML-документ в `XmlDocument` объекта и его сохранение в файл.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Операция не приведет к созданию XML-документа с правильным форматом (например, в документе не будет элемента документа или будут повторяющиеся XML-объявления).</exception>
        <altmember cref="P:System.Xml.XmlTextWriter.Formatting" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public override System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlDocument.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает информационный набор после проверки схемы (PSVI) для этого узла.</summary>
        <value>Объект <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />, представляющий набор сведений после проверки схемы этого узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Содержимое этого свойства PSVI устанавливаются после проверки узла.  
  
 Это свойство является расширением Microsoft для объектной модели документа (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaSet Schemas" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Schemas" />
      <MemberSignature Language="VB.NET" Value="Public Property Schemas As XmlSchemaSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaSet ^ Schemas { System::Xml::Schema::XmlSchemaSet ^ get(); void set(System::Xml::Schema::XmlSchemaSet ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Schemas : System.Xml.Schema.XmlSchemaSet with get, set" Usage="System.Xml.XmlDocument.Schemas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Xml.Schema.XmlSchemaSet" />, связанный с данным объектом <see cref="T:System.Xml.XmlDocument" />.</summary>
        <value>Объект <see cref="T:System.Xml.Schema.XmlSchemaSet" />, который содержит схемы языка определения схемы XML, связанные с этим <see cref="T:System.Xml.XmlDocument" />; в противном случае — пустой объект <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Схемы, содержащиеся в <xref:System.Xml.Schema.XmlSchemaSet> объекта, связанного с <xref:System.Xml.XmlDocument> объекта используются для проверки при <xref:System.Xml.XmlDocument.Validate%2A> метод <xref:System.Xml.XmlDocument> выполняется.  
  
 При <xref:System.Xml.XmlDocument> объект инициализируется с XML-данных из <xref:System.Xml.XmlReader> объекта, <xref:System.Xml.Schema.XmlSchemaSet> из которого загружается объект <xref:System.Xml.XmlReaderSettings.Schemas%2A> свойство <xref:System.Xml.XmlReader> объекта.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.XmlDocument.Validate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Проверяет <see cref="T:System.Xml.XmlDocument" /> по схемам языка XSD, содержащимся в свойстве <see cref="P:System.Xml.XmlDocument.Schemas" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="member this.Validate : System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="xmlDocument.Validate validationEventHandler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">Объект <see cref="T:System.Xml.Schema.ValidationEventHandler" />, который получает сведения о предупреждениях и ошибках, возникающих при проверке схемы.</param>
        <summary>Проверяет <see cref="T:System.Xml.XmlDocument" /> по схемам языка XSD, содержащимся в свойстве <see cref="P:System.Xml.XmlDocument.Schemas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlDocument.Validate%2A> Метод проверяет XML-данных в <xref:System.Xml.XmlDocument> по схемам, содержащимся в <xref:System.Xml.XmlDocument.Schemas%2A> свойство. <xref:System.Xml.XmlDocument.Validate%2A> Метод выполняет приращение информационного набора. В частности после успешной проверки применяются настройки схемы по умолчанию, текстовые значения преобразуются в атомарные значения, и сведения о типах ассоциируются с проверенными информационными элементами. Результатом является ранее нетипизированного XML поддерева в <xref:System.Xml.XmlDocument> заменены типизированное поддерево.  
  
 Ниже перечислены важные замечания, которые необходимо учитывать при использовании <xref:System.Xml.XmlDocument.Validate%2A> метода.  
  
-   Указания по расположению схемы, например `xsi:schemaLocation` или `xsi:noNamespaceSchemaLocation` учитываются.  
  
-   Встроенные схемы игнорируются.  
  
-   Если ошибки проверки схемы возникают во время проверки <xref:System.Xml.XmlDocument> становится частичной проверке некоторые узлы с информацией в правильный тип и без.  
  
-   Процесс проверки включает проверку ограничений уникальности и ссылок (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, и `xs:unique`).  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Xml.XmlDocument.Validate%2A>. В примере создается <xref:System.Xml.XmlDocument> , содержащий связанной схемы XSD с помощью <xref:System.Xml.XmlReaderSettings> и <xref:System.Xml.XmlReader> объектов. Затем в примере используется <xref:System.Xml.XPath.XPathNavigator> класса для неправильного изменения типизированного значения элемента в XML-документе, формирования ошибки проверки схемы.  
  
 [!code-cpp[XPathValidation#1](~/samples/snippets/cpp/VS_Snippets_Data/XPathValidation/CPP/XPathValidation.cpp#1)]
 [!code-csharp[XPathValidation#1](~/samples/snippets/csharp/VS_Snippets_Data/XPathValidation/CS/XPathValidation.cs#1)]
 [!code-vb[XPathValidation#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XPathValidation/VB/XPathValidation.vb#1)]  
  
 В примере `contosoBooks.xml` и `contosoBooks.xsd` файлы в качестве входных данных.  
  
 [!code-xml[XPathXMLExamples#2](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xml#2)]  
  
 [!code-xml[XPathXMLExamples#3](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Возникло событие проверки схемы, и не задан объект <see cref="T:System.Xml.Schema.ValidationEventHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler, System.Xml.XmlNode nodeToValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler, class System.Xml.XmlNode nodeToValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, System::Xml::XmlNode ^ nodeToValidate);" />
      <MemberSignature Language="F#" Value="member this.Validate : System.Xml.Schema.ValidationEventHandler * System.Xml.XmlNode -&gt; unit" Usage="xmlDocument.Validate (validationEventHandler, nodeToValidate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="nodeToValidate" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">Объект <see cref="T:System.Xml.Schema.ValidationEventHandler" />, который получает сведения о предупреждениях и ошибках, возникающих при проверке схемы.</param>
        <param name="nodeToValidate">Объект <see cref="T:System.Xml.XmlNode" />, созданный из <see cref="T:System.Xml.XmlDocument" /> в целях проверки.</param>
        <summary>Проверяет указанный объект <see cref="T:System.Xml.XmlNode" /> по схемам языка XSD, содержащимся в свойстве <see cref="P:System.Xml.XmlDocument.Schemas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlDocument.Validate%2A> Метод проверяет XML-данных в <xref:System.Xml.XmlNode> объекта по схемам, содержащимся в <xref:System.Xml.XmlDocument.Schemas%2A> свойство. <xref:System.Xml.XmlDocument.Validate%2A> Метод выполняет приращение информационного набора. В частности после успешной проверки применяются настройки схемы по умолчанию, текстовые значения преобразуются в атомарные значения, и сведения о типах ассоциируются с проверенными информационными элементами. Результатом является ранее нетипизированного XML поддерева в <xref:System.Xml.XmlDocument> заменены типизированное поддерево.  
  
 Ниже перечислены важные замечания, которые необходимо учитывать при использовании <xref:System.Xml.XmlDocument.Validate%2A> метода.  
  
-   Указания по расположению схемы, например `xsi:schemaLocation` или `xsi:noNamespaceSchemaLocation` учитываются.  
  
-   Встроенные схемы игнорируются.  
  
-   Если ошибки проверки схемы возникают во время проверки <xref:System.Xml.XmlDocument> становится частичной проверке некоторые узлы с информацией в правильный тип и без.  
  
 Если проверяемый узел является корневым узлом, процесс проверки включает проверку ограничений уникальности и ссылок (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, и `xs:unique`); в противном случае уникальности и ссылок ограничения, опущены.  
  
   
  
## Examples  
 Пример <xref:System.Xml.XmlDocument.Validate%2A> метода, в разделе <xref:System.Xml.XmlDocument.Validate%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр объекта <see cref="T:System.Xml.XmlNode" /> не был создан из <see cref="T:System.Xml.XmlDocument" />.</exception>
        <exception cref="T:System.InvalidOperationException">Параметр объекта <see cref="T:System.Xml.XmlNode" /> не является элементом, атрибутом, фрагментом документа или корневым узлом.</exception>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Возникло событие проверки схемы, и не задан объект <see cref="T:System.Xml.Schema.ValidationEventHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteContentTo">
      <MemberSignature Language="C#" Value="public override void WriteContentTo (System.Xml.XmlWriter xw);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteContentTo(class System.Xml.XmlWriter xw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteContentTo (xw As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteContentTo(System::Xml::XmlWriter ^ xw);" />
      <MemberSignature Language="F#" Value="override this.WriteContentTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.WriteContentTo xw" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xw" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="xw">Объект <see langword="XmlWriter" />, в котором необходимо выполнить сохранение.</param>
        <summary>Сохраняет все дочерние узлы узла <see langword="XmlDocument" /> в заданном <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является расширением Microsoft для модели объекта документа (DOM). Это функционально эквивалентно <xref:System.Xml.XmlDocument.InnerXml%2A> свойство.  
  
 <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> Свойство определяет кодировку, которая записывается. Если `Encoding` свойство не имеет значения, `XmlDocument` записывается без атрибута кодировки.  
  
   
  
## Examples  
 В следующем примере отображается на экране документ.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="override this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.WriteTo w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">Объект <see langword="XmlWriter" />, в котором необходимо выполнить сохранение.</param>
        <summary>Сохраняет узел <see langword="XmlDocument" /> в заданном <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является расширением Microsoft для модели объекта документа (DOM). Это функционально эквивалентно <xref:System.Xml.XmlNode.OuterXml%2A> свойство.  
  
 <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> Свойство определяет кодировку, которая записывается. Если `Encoding` свойство не имеет значения, `XmlDocument` записывается без атрибута кодировки.  
  
   
  
## Examples  
 В следующем примере отображается на экране документ.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.XmlDocument.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает <see cref="T:System.Xml.XmlResolver" />, используемый для разрешения внешних ресурсов.</summary>
        <value>Используемый <see langword="XmlResolver" />.  Чтобы указать <see langword="XmlResolver" /> в .NET Framework версии 1.1, вызывающий объект должен быть надежным.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlResolver` Можно использовать для загрузки DTD или развертывания ссылок на сущности. С помощью <xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=nameWithType> свойства, можно задать учетные данные на `XmlResolver` для доступа к ресурсам, хранящейся на ресурсе безопасности сети.  
  
-   Если документ не был загружен с помощью <xref:System.Xml.XmlReader> (то есть, если он был загружен с помощью потока, файлов и так далее) `XmlResolver` на `XmlDocument` всегда используется.  
  
-   Если документ был загружен с <xref:System.Xml.XmlTextReader>, средство разрешения `XmlTextReader` используется для разрешения ссылок DTD в узел DocumentType. Средство разрешения `XmlDocument` используется для расширения ссылок на сущности.  
  
-   Если документ был загружен с <xref:System.Xml.XmlValidatingReader>, средство разрешения `XmlDocument` никогда не используется.  
  
-   Если документ был загружен с классом, который расширяет `XmlReader` и `XmlReader` не может разрешать сущности (<xref:System.Xml.XmlReader.CanResolveEntity%2A> возвращает `false`), `XmlResolver` на `XmlDocument` используется для разрешения ссылок в узел DocumentType и расширения ссылок на сущности.  
  
> [!NOTE]
>  Если `XmlDocument` загружается с помощью <xref:System.Xml.XmlReader> которого было `XmlResolver` , равным `XmlResolver` на `XmlReader` не кэшируется `XmlDocument` после <xref:System.Xml.XmlDocument.Load%2A> завершения.  
  
 В.NET Framework версии 1.1, если это свойство не задано, уровень доверия приложения определяет поведение по умолчанию.  
  
 `Fully trusted code:` В документе используется значение по умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных пользователя. Если для доступа к сетевому ресурсу требуется проверка подлинности, используйте `XmlResolver` свойство, чтобы указать `XmlResolver` необходимые учетные данные.  
  
 `Semi-trusted code:` `XmlResolver` Свойству `null`. Внешние ресурсы не разрешаются.  
  
 Дополнительные сведения о безопасности и `XmlResolver` свойство, в разделе [разрешении внешних ресурсов](~/docs/standard/data/xml/resolving-external-resources.md).  
  
 Это свойство является расширением Microsoft для объектной модели документа (DOM).  
  
   
  
## Examples  
 В следующем примере загружается XML-документ, который включает ссылку на файл DTD. `XmlResolver` Свойство используется для задания учетных данных для доступа к сетевому ресурсу.  
  
 [!code-cpp[XmlDocument.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.XmlResolver/CPP/docresolver.cpp#1)]
 [!code-csharp[XmlDocument.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.XmlResolver/CS/docresolver.cs#1)]
 [!code-vb[XmlDocument.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.XmlResolver/VB/docresolver.vb#1)]  
  
 В примере следующие файлы данных в качестве входного.  
  
 `book5.xml`  
  
 [!code-xml[XmlDocument.XmlResolver#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/book5.xml#2)]  
  
 `books.dtd`  
  
 [!code-xml[XmlDocument.XmlResolver#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/books.dtd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Этому свойству задается значение <see langword="null" />, и обнаружено внешнее определение DTD или сущность.</exception>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
      </Docs>
    </Member>
  </Members>
</Type>