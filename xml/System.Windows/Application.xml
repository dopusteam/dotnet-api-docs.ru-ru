<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7dfbbc42aa1abd5672a8c1c362365d56d7d2df38" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57928871" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Инкапсулирует приложение Windows Presentation Foundation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> — Это класс, который инкапсулирует [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] функции для конкретных приложений, включая следующие:  
  
-   **Время существования приложения**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.  
  
-   **Окно области определения приложения, свойства и управление ресурсами**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>.  
  
-   **Параметр командной строки и выхода кода обработки**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.  
  
-   **Навигации**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.  
  
 <xref:System.Windows.Application> реализует шаблон с одним элементом для предоставления общего доступа к его окна и свойств службы области ресурсов. Следовательно, только один экземпляр <xref:System.Windows.Application> класс можно создать на <xref:System.AppDomain>.  
  
 Вы можете реализовать <xref:System.Windows.Application> с помощью разметки, разметки и кода или кода. Если <xref:System.Windows.Application> реализуется с помощью разметки, ли разметки или разметки и кода, размеченный файл должен быть настроен как [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` элемента.  
  
> [!NOTE]
>  Автономное приложение не требует <xref:System.Windows.Application> объекта; это можно реализовать пользовательский `static` метод точки входа (`Main`), открывает окно без создания экземпляра <xref:System.Windows.Application>. Тем не менее [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] требуют <xref:System.Windows.Application> объекта.  
  
   
  
## Examples  
 В следующем примере показано, как стандартное приложение — с использованием одной разметки:  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 В следующем примере показан как стандартное приложение определяется с использованием только кода:  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 В следующем примере показано, как стандартное приложение — с использованием комбинации разметки и кода.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Открытый <see langword="static" /> (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными. Кроме того <see cref="M:System.Windows.Application.FindResource(System.Object)" /> и <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> методы и <see cref="P:System.Windows.Application.Properties" /> и <see cref="P:System.Windows.Application.Resources" /> свойства являются потокобезопасными.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только один экземпляр <xref:System.Windows.Application> можно создать класс <xref:System.AppDomain>, чтобы обеспечить общий доступ к один набор данных окна и свойств ресурсов области определения приложения. Следовательно, конструктор по умолчанию для <xref:System.Windows.Application> класс определяет, является ли экземпляр инициализируемого первый экземпляр в <xref:System.AppDomain>; если он недопустим, <xref:System.InvalidOperationException> возникает исключение.  
  
 <xref:System.Windows.Application> Объект для текущего <xref:System.AppDomain> предоставляется из статического <xref:System.Windows.Application.Current%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Для каждого <see cref="T:System.Windows.Application" /> создается больше одного экземпляра класса <see cref="T:System.AppDomain" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение становиться активным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение Windows Presentation Foundation, который имеет один или несколько открытых окон активируется (становится активным) при одном из окон активации в первый раз с момента запуска приложения, или когда один из windows активируется во время приложение неактивно: В частности, активация происходит при:  
  
-   Приложение создает первое окно.  
  
-   Пользователь переключается в приложение с помощью клавиши ALT + TAB или с помощью диспетчера задач.  
  
-   Пользователь щелкает кнопку панели задач для одного из окон в приложении.  
  
 Приложения, которые необходимо обнаружить, когда они активировать может обрабатывать <xref:System.Windows.Application.Activated> событий.  
  
 После активации приложения он может деактивировать и повторно много раз во время его существования. Если поведение или состояние приложения зависит от состояния его активации, он может обрабатывать оба <xref:System.Windows.Application.Activated> и <xref:System.Windows.Application.Deactivated> событий, чтобы определить, какие активации сформулируем в.  
  
 Когда приложение становится активным, <xref:System.Windows.Application.Activated> не будет вызываться снова до деактивации приложения, независимо от того, сколько windows в приложении активируются в том случае, пока приложение активно.  
  
 <xref:System.Windows.Application.Activated> не вызывается для [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 В следующем примере показано, как обнаружить, когда это автономное приложение активирует и деактивирует.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Windows.Application" /> текущего <see cref="T:System.AppDomain" />.</summary>
        <value>Объект <see cref="T:System.Windows.Application" /> для текущего <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> — на-<xref:System.AppDomain> одноэлементный тип, реализующий статическое <xref:System.Windows.Application.Current%2A> свойство, чтобы предоставить общий доступ к <xref:System.Windows.Application> экземпляра для текущего <xref:System.AppDomain>. Это гарантирует, это состояние управляется <xref:System.Windows.Application>, включая общие ресурсы и состояние, доступен из одного общего расположения.  
  
 Это свойство является поточно-ориентированным и доступен из любого потока.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда приложение перестает быть активным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение Windows Presentation Foundation, которое имеет один или несколько открытых окон деактивирует (перестает быть активным) когда пользователь выполняет следующее:  
  
-   Переход к другому приложению, с помощью клавиши ALT + TAB или с помощью диспетчера задач.  
  
-   Нажимает кнопку в панели задач окна в другое приложение.  
  
 Приложения, которые необходимо обнаружить деактивации может обрабатывать <xref:System.Windows.Application.Deactivated> событий.  
  
 После активации приложения он может деактивировать и повторно много раз во время его существования. Если поведение или состояние приложения зависит от состояния его активации, он может обрабатывать оба <xref:System.Windows.Application.Deactivated> и <xref:System.Windows.Application.Activated> событий, чтобы определить, которые гласят, что он,.  
  
 <xref:System.Windows.Application.Deactivated> не вызывается для [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 В следующем примере показано, как обнаружить, когда это автономное приложение деактивируется и активирует.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при генерации приложением исключения, которое не обрабатывается.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию Windows Presentation Foundation перехватывает необработанные исключения, уведомляет пользователей о исключение из диалогового окна (из которой они могут сообщить об исключении) и автоматически завершает работу приложения.  
  
 Тем не менее, если приложению для обработки необработанных исключений из централизованного расположения, необходимо обработать <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> вызывается <xref:System.Windows.Application> для каждого исключения, которое не было обработано код, выполняемый в основном потоке пользовательского интерфейса.  
  
 Если исключение не обработано в одном фоновый поток пользовательского интерфейса (потока с собственным <xref:System.Windows.Threading.Dispatcher>) или фоновом рабочем потоке (поток без <xref:System.Windows.Threading.Dispatcher>), исключение не пересылается в основной поток пользовательского интерфейса. Следовательно <xref:System.Windows.Application.DispatcherUnhandledException> не возникает. В этих случаях необходимо написать код, выполнив следующие действия:  
  
1.  Обработка исключений в фоновом потоке.  
  
2.  Отправка данных исключений в основной поток пользовательского интерфейса.  
  
3.  Rethrow их в основном потоке пользовательского интерфейса без обработки его разрешить <xref:System.Windows.Application.DispatcherUnhandledException> вызываемого.  
  
 Дополнительные сведения см. в разделе [потоковая модель](~/docs/framework/wpf/advanced/threading-model.md) Обзор.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> Обработчику события передаются <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> аргумент, содержащий контекстные сведения об этом исключении, включая:  
  
-   Исключение (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   <xref:System.Windows.Threading.Dispatcher> Из которого она была создана (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).  
  
 Эти сведения можно использовать для определения, является ли исключение восстановимые. Исправимое исключение может быть <xref:System.IO.FileNotFoundException>, например, может быть неустранимое исключение <xref:System.StackOverflowException>, например.  
  
 При обработке необработанное исключение из <xref:System.Windows.Application.DispatcherUnhandledException>, и вы не хотите [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] чтобы продолжить их обработку, вам потребуется задать <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> свойства `true`.  
  
 В отличие от других событий, <xref:System.Windows.Application> вызывает, <xref:System.Windows.Application.DispatcherUnhandledException> имеют соответствующего незащищенные виртуальной реализацией (OnDispatcherUnhandledException). Следовательно, классы, производные от <xref:System.Windows.Application> всегда необходимо зарегистрировать обработчик событий с <xref:System.Windows.Application.DispatcherUnhandledException> для обработки необработанных исключений.  
  
   
  
## Examples  
 В следующем примере показано, как для обработки необработанных исключений путем обработки <xref:System.Windows.Application.DispatcherUnhandledException> событий.  
  
 [!code-csharp[handling-unhandled-exceptions](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs)]
 [!code-vb[handling-unhandled-exceptions](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Генерируется непосредственно перед завершением работы приложения и не может быть отменено.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложение может завершить работу в какой-либо из следующих причин:  
  
-   <xref:System.Windows.Application.Shutdown%2A> Метод <xref:System.Windows.Application> объекта вызывается, либо явно, либо как определено <xref:System.Windows.Application.ShutdownMode%2A> свойство.  
  
-   Пользователь завершает сеанс выходом или завершение работы.  
  
 Можно обнаружить путем обработки при завершении работы приложения <xref:System.Windows.Application.Exit> событий и выполнять дополнительную обработку при необходимости.  
  
 Также можно обрабатывать <xref:System.Windows.Application.Exit> проверить или изменить код выхода приложения в том случае, когда не нужно вызывать <xref:System.Windows.Application.Shutdown%2A> явным образом. Код выхода предоставляется из <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> свойство <xref:System.Windows.ExitEventArgs> аргумент, передаваемый <xref:System.Windows.Application.Exit> обработчик событий. При остановке выполнения приложения, код завершения передается операционной системы для последующей обработки.  
  
 Если приложение обрабатывает <xref:System.Windows.Application.SessionEnding> событий и впоследствии его отменяет, <xref:System.Windows.Application.Exit> не происходит, и приложение будет работать в соответствии с режимом завершения работы.  
  
 Код выхода можно задать из [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], несмотря на то, что значение учитывается.  
  
 Для [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], <xref:System.Windows.Application.Exit> возникает в следующих случаях:  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] Переходе.  
  
-   В [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)], когда вкладке, на котором размещается [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] закрыт.  
  
-   Закрывается браузер.  
  
 Во всех случаях значение <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> свойство учитывается.  
  
   
  
## Examples  
 В следующем примере показано, как:  
  
-   Обрабатывать <xref:System.Windows.Application.Exit> событий.  
  
-   Проверьте и обновите <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> свойство <xref:System.Windows.ExitEventArgs>.  
  
-   Записи в журнал приложения в изолированном хранилище.  
  
-   Сохранить состояние приложения в изолированном хранилище.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Имя искомого ресурса.</param>
        <summary>Осуществляет поиск ресурса [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], например <see cref="T:System.Windows.Style" /> или <see cref="T:System.Windows.Media.Brush" />, с указанным ключом и генерирует исключение, если запрошенный ресурс не найден (см. [Ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md)).</summary>
        <returns>Запрошенный объект ресурса. Если ресурс не найден, генерируется <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> сначала просматривает ресурсов области приложения для указанного ресурса. Ресурсы области приложения управляются <xref:System.Windows.Application>и предоставляются из <xref:System.Windows.Application.Resources%2A> свойство. Если указанный ресурс не найден в наборе ресурсов области определения приложения, <xref:System.Windows.Application.FindResource%2A> затем выполняет поиск системных ресурсов. Системные ресурсы ресурсы оболочки, определяемый пользователем и добавляя цвета, шрифты и конфигурации оболочки. Они предоставляются из <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, и <xref:System.Windows.SystemParameters> соответственно, в виде статических свойств. Чтобы использовать <xref:System.Windows.Application.FindResource%2A> получить их, эти типы также предоставлять ключевые свойства ресурсов, которые призваны передается <xref:System.Windows.Application.FindResource%2A>, например <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Так как <xref:System.Windows.Application.FindResource%2A> возвращает объект, необходимо привести возвращаемое значение к соответствующему типу, если найти ресурс.  
  
> [!IMPORTANT]
>  Если этот метод вызывается для ключа, который не удается найти, создается исключение. Если вы не хотите обрабатывать исключения, возникающие в результате вызова метода <xref:System.Windows.Application.FindResource%2A>, вызовите <xref:System.Windows.Application.TryFindResource%2A> вместо; <xref:System.Windows.Application.TryFindResource%2A> возвращает `null` ссылаться, если запрошенный ресурс не найден и создает исключение.  
  
 Этот метод является поточно-ориентированным и могут вызываться из любого потока.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Application.FindResource%2A> для поиска ресурса и для обработки <xref:System.Windows.ResourceReferenceKeyNotFoundException> Если ресурс не найден.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Не удалось найти данный ресурс.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда начинается переход к фрагменту содержимого, Переход происходит сразу же, если желаемый фрагмент находится в текущем содержимом, или после загрузки исходного содержимого [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], если желаемый фрагмент находится в другом содержимом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор может быть либо <xref:System.Windows.Navigation.NavigationWindow> или <xref:System.Windows.Controls.Frame>.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">Относительный <see cref="T:System.Uri" />, указывающий на неприсоединенный ресурс.</param>
        <summary>Возвращает поток ресурса для файла данных содержания, расположенного в указанном <see cref="T:System.Uri" /> (см. [Ресурсы, содержимое и файлы данных WPF-приложения](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns><see cref="T:System.Windows.Resources.StreamResourceInfo" />, содержащий файла данных содержания, расположенного в указанном <see cref="T:System.Uri" />. Если неприсоединенный ресурс не найден, тогда возвращается значение null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" />, передаваемый <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> является нулевым.</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" />, передаваемый <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> является абсолютным <see cref="T:System.Uri" />.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" />, определяющий положение, для которого был создан файл cookie.</param>
        <summary>Возвращает файл cookie для расположения, указанного <see cref="T:System.Uri" />.</summary>
        <returns><see cref="T:System.String" />, в случае, если файл cookie существует; в противном случае — если клавиша ALT нажата, в противном случае генерируется <see cref="T:System.ComponentModel.Win32Exception" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> Возвращает файл cookie для указанного <xref:System.Uri>. Если не удается получить файл cookie, <xref:System.ComponentModel.Win32Exception> возникает исключение. Необходимо написать код для разбора строки файла cookie в список пар "имя значение".  
  
 Обзор файлов cookie в [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], см. в разделе [Общие сведения о переходах](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Если при попытке извлечь указанный файл cookie возникла проблема, функция <see langword="InternetGetCookie" /> (вызванная <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />), генерирует ошибку [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)].</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Для получения файла cookie для файла <see cref="T:System.Uri" />. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Для получения файла cookie для не являющихся файловыми <see cref="T:System.Uri" />. Связанное перечисление: <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote"><see cref="T:System.Uri" />, указывающий на неприсоединенный ресурс в источнике.</param>
        <summary>Возвращает поток ресурса для исходного файла данных ресурса, расположенного в указанном <see cref="T:System.Uri" /> (см. [Ресурсы, содержимое и файлы данных WPF-приложения](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns><see cref="T:System.Windows.Resources.StreamResourceInfo" />, содержащий поток ресурса для исходного файла данных ресурса, расположенного в указанном <see cref="T:System.Uri" />. Если неприсоединенный ресурс не найден, тогда возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" />, передаваемый <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> является нулевым.</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" />, передаваемый в <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />, является неотносительным, абсолютным, но не задан в форме <c>pack://siteoforigin:,,,/</c>.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource"><see cref="T:System.Uri" />, указующий на внедренный ресурс.</param>
        <summary>Возвращает поток ресурса для файла данных ресурса, расположенного в указанном <see cref="T:System.Uri" /> (см. [Ресурсы, содержимое и файлы данных WPF-приложения](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns><see cref="T:System.Windows.Resources.StreamResourceInfo" />, содержащий поток ресурса для файла данных ресурса, расположенного в указанном <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" />, передаваемый <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> является нулевым.</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" />, передаваемый в <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />, является неотносительным, абсолютным, но не задан в форме <c>pack://application:,,,/</c>.</exception>
        <exception cref="T:System.IO.IOException">Не удается найти <see cref="T:System.Uri" />, передаваемый в <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после того, как содержимое, переданное приложению, было загружено, проанализировано и отрисовывается.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор может быть либо <xref:System.Windows.Navigation.NavigationWindow> или <xref:System.Windows.Controls.Frame>.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Прослушивать события перехода содержимого, такие как <xref:System.Windows.FrameworkElement.Loaded> событий на <xref:System.Windows.Controls.Page> перед обращением к свойства перехода содержимого.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Подгружает файл [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], расположенный по указанному [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Файл может быть файлом кода приложения (настроен в качестве [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] элемент страницы) или файл данных приложения (файл ресурсов, содержимого файла или сайта исходного файла; см. в разделе [ресурса приложения WPF, содержимое и файлы данных](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">Объект <see cref="T:System.Uri" />, сопоставляемый с относительным файлом [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</param>
        <summary>Подгружает файл [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], располагающийся по указанному [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)], и преобразует его в экземпляр объекта, определенного корневым элементом файла [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</summary>
        <returns>Экземпляр корневого элемента, заданный загруженным файлом XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо явным образом преобразовать возвращаемое значение в тот же тип, что корневой элемент [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] файла.  
  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Файл может быть файлом кода приложения (настроен в качестве [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] элемент страницы) или файл данных приложения (файл ресурсов, содержимого файла или сайта исходного файла; см. в разделе [ресурса приложения WPF, содержимое и файлы данных](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="resourceLocator" /> имеет значение null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> — это абсолютный [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.Exception">Файл не является файлом [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">Объект того же типа, что и корневой элемент файла [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</param>
        <param name="resourceLocator">Объект <see cref="T:System.Uri" />, сопоставляемый с относительным файлом [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</param>
        <summary>Загружает файл [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], расположенный в указанном [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)], и преобразует его в экземпляр объекта, заданного корневым элементом файла [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Файл может быть файлом кода приложения (настроен в качестве [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] элемент страницы) или файл данных приложения (файл ресурсов, содержимого файла или сайта исходного файла; см. в разделе [ресурса приложения WPF, содержимое и файлы данных](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Этот метод не является потокобезопасным.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="resourceLocator" /> имеет значение null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> — это абсолютный [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.Exception">Тип элемента <paramref name="component" /> не соответствует корневому элементу файла [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает главное окно приложения.</summary>
        <value><see cref="T:System.Windows.Window" />, определяющееся, как лавное окно приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> автоматически устанавливается со ссылкой на первый <xref:System.Windows.Window> объекта в <xref:System.AppDomain>.  
  
 Можно указать различные главное окно, задав <xref:System.Windows.Application.MainWindow%2A> назначение другой <xref:System.Windows.Application.Windows%2A> объект <xref:System.Windows.Application.MainWindow%2A> свойство.  
  
 Если <xref:System.Windows.Application.ShutdownMode%2A> свойство <xref:System.Windows.Application> имеет значение <xref:System.Windows.ShutdownMode.OnMainWindowClose>, закрытие главного окна приводит завершения работы приложения.  
  
 Можно задать <xref:System.Windows.Application.MainWindow%2A> свойства из [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], если главное окно приложения не является окном, создаваемое путем установки <xref:System.Windows.Application.StartupUri%2A> свойство в [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]. Два ограничения [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] являются подход:  
  
-   Можно указать либо [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-только <xref:System.Windows.Window> или [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-только <xref:System.Windows.Navigation.NavigationWindow> что и главное окно.  
  
-   Необходимо задать <xref:System.Windows.UIElement.Visibility%2A> задается свойство окна, в противном случае оно не будет отображаться.  
  
 Ссылка на первый <xref:System.Windows.Window> объект для создания экземпляра также добавляется в качестве первого элемента, который <xref:System.Windows.Application.Windows%2A> коллекции. Если <xref:System.Windows.Application.MainWindow%2A> впоследствии назначать со ссылкой на другой <xref:System.Windows.Window>, положение элемента с ссылкой на главном окне изменится при порядок элементов в <xref:System.Windows.Application.Windows%2A> остается неизменным. Следовательно, всегда используйте <xref:System.Windows.Application.MainWindow%2A> для ссылки на главное окно вместо первого элемента в <xref:System.Windows.Application.Windows%2A>.  
  
> [!NOTE]
>  Если главное окно приложения является <xref:System.Windows.Navigation.NavigationWindow>, и требуется отдельный доступ к <xref:System.Windows.Navigation.NavigationWindow> членов, необходимо привести значение <xref:System.Windows.Application.MainWindow%2A> для <xref:System.Windows.Navigation.NavigationWindow>.  
>   
>  Это свойство доступно только из потока, создавшего <xref:System.Windows.Application> объекта.  
  
   
  
## Examples  
 Приведенный ниже показано, как найти главное окно приложения.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 В следующем примере показано, как задать <xref:System.Windows.Application.MainWindow%2A> с помощью [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 В следующем примере показано, как создать экземпляр <xref:System.Windows.Application.MainWindow%2A> в коде во время запуска приложения.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Application.MainWindow" /> устанавливается из приложения, находящегося в браузере, например, [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда содержимое, к которому осуществляется переход, найдено, хотя его загрузка, возможно, еще не завершена.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор может быть либо <xref:System.Windows.Navigation.NavigationWindow> или <xref:System.Windows.Controls.Frame>.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при запросе приложением перехода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор может быть либо <xref:System.Windows.Navigation.NavigationWindow> или <xref:System.Windows.Controls.Frame>.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда происходит ошибка при переходе к указанному содержимому.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор может быть либо <xref:System.Windows.Navigation.NavigationWindow> или <xref:System.Windows.Controls.Frame>.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит время от времени во время загрузки, управляемой приложением для предоставления информации о статусе загрузки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор может быть либо <xref:System.Windows.Navigation.NavigationWindow> или <xref:System.Windows.Controls.Frame>.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Появляется при вызове метода перехода приложения <see langword="StopLoading" />, или когда поступил запрос нового перехода во время выполнения текущего.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Навигатор может быть либо <xref:System.Windows.Navigation.NavigationWindow> или <xref:System.Windows.Controls.Frame>.  
  
 См. раздел <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnActivated%2A> формирует событие <xref:System.Windows.Application.Activated>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnActivated%2A>. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnActivated%2A> в базовом классе Если <xref:System.Windows.Application.Activated> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnDeactivated%2A> формирует событие <xref:System.Windows.Application.Deactivated>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnDeactivated%2A>. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnDeactivated%2A> в базовом классе Если <xref:System.Windows.Application.Deactivated> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.ExitEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.Exit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnExit%2A> формирует событие <xref:System.Windows.Application.Exit>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnExit%2A> метод. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnExit%2A> в базовом классе Если <xref:System.Windows.Application.Exit> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.FragmentNavigation" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnFragmentNavigation%2A> формирует событие <xref:System.Windows.Application.FragmentNavigation>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnFragmentNavigation%2A>. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnFragmentNavigation%2A> в базовом классе Если <xref:System.Windows.Application.FragmentNavigation> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.LoadCompleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnLoadCompleted%2A> формирует событие <xref:System.Windows.Application.LoadCompleted>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnLoadCompleted%2A>. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnLoadCompleted%2A> в базовом классе Если <xref:System.Windows.Application.LoadCompleted> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.Navigated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnNavigated%2A> формирует событие <xref:System.Windows.Application.Navigated>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnNavigated%2A>. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnNavigated%2A> в базовом классе Если <xref:System.Windows.Application.Navigated> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.Navigating" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnNavigating%2A> формирует событие <xref:System.Windows.Application.Navigating>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnNavigating%2A>. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnNavigating%2A> в базовом классе Если <xref:System.Windows.Application.Navigating> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.NavigationFailed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnNavigationFailed%2A> формирует событие <xref:System.Windows.Application.NavigationFailed>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnNavigationFailed%2A>. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnNavigationFailed%2A> в базовом классе Если <xref:System.Windows.Application.NavigationFailed> должен вызываться.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.NavigationProgress" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnNavigationProgress%2A> формирует событие <xref:System.Windows.Application.NavigationProgress>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnNavigationProgress%2A>. Необходимо явно вызывать переопределенный метод <xref:System.Windows.Application.OnNavigationProgress%2A> в базовом классе Если <xref:System.Windows.Application.NavigationProgress> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Navigation.NavigationEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.NavigationStopped" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnNavigationStopped%2A> формирует событие <xref:System.Windows.Application.NavigationStopped>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnNavigationStopped%2A>. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnNavigationStopped%2A> в базовом классе Если <xref:System.Windows.Application.NavigationStopped> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.SessionEndingCancelEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.SessionEnding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnSessionEnding%2A> формирует событие <xref:System.Windows.Application.SessionEnding>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnSessionEnding%2A>. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnSessionEnding%2A> в базовом классе Если <xref:System.Windows.Application.SessionEnding> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.StartupEventArgs" />, содержащий данные события.</param>
        <summary>Создает событие <see cref="E:System.Windows.Application.Startup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Application.OnStartup%2A> формирует событие <xref:System.Windows.Application.Startup>.  
  
 Тип, который является производным от <xref:System.Windows.Application> может переопределить <xref:System.Windows.Application.OnStartup%2A>. Переопределенный метод должен вызвать <xref:System.Windows.Application.OnStartup%2A> в базовом классе Если <xref:System.Windows.Application.Startup> событий должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию свойств области приложения.</summary>
        <value><see cref="T:System.Collections.IDictionary" />, который содержит свойства области приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> предоставляет словарь с помощью <xref:System.Windows.Application.Properties%2A> который можно использовать для хранения свойств области приложения. Это позволяет совместно использовать состояние всем кодом в <xref:System.AppDomain> образом поточно ориентированными, без необходимости писать свой собственный код состояния.  
  
 Свойств, хранящихся в <xref:System.Windows.Application.Properties%2A> необходимо преобразовать в соответствующий тип, возвращаемый.  
  
 <xref:System.Windows.Application.Properties%2A> Свойство является поточно-ориентированным и доступен из любого потока.  
  
   
  
## Examples  
 В следующем примере показан как создать и использовать свойство области приложения с помощью <xref:System.Windows.Application.Properties%2A>.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает <see cref="T:System.Reflection.Assembly" />, обеспечивающий набор [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] для ресурсов приложения [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].</summary>
        <value>Ссылка на <see cref="T:System.Reflection.Assembly" />, обеспечивающий набор [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] для ресурсов приложения [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ресурсы разрешаются во время выполнения по отношению к сборке записей, который определяется значение, возвращаемое из <xref:System.Reflection.Assembly.GetEntryAssembly%2A> метод.  
  
 Запись сборки — сборка, которая возвращается методом <xref:System.Reflection.Assembly.GetEntryAssembly%2A> и может быть следующее:  
  
-   Исполняемая сборка в домене приложения по умолчанию.  
  
-   Первая сборка выполняться путем вызова <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 В следующих случаях, однако [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] сборку не удается получить ссылку на сборке записей:  
  
-   Узлы неуправляемый (машинный) приложения [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] сборки.  
  
-   Узлы управляемого приложения [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] сборки, загрузив его в новый домен приложения с помощью метода, отличного от <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 В обоих этих случаях <xref:System.Reflection.Assembly.GetEntryAssembly%2A> возвращает `null`и [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ресурсы сборки не может быть разрешена. В этих случаях <xref:System.Windows.Application.ResourceAssembly%2A> можно задать, только со ссылкой на сборку, который должен использоваться для разрешения ресурсов один раз.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> можно задать только один раз, так как маловероятно, что сборка ресурсов изменится после [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] сборка загружается.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> нельзя задать, если [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] сборки может обнаруживать начальной сборки — то есть, когда <xref:System.Reflection.Assembly.GetEntryAssembly%2A> возвращает ссылку на сборку, а не `null`.  
  
 Это свойство является поточно-ориентированным и доступен из любого потока.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> впервые появился в .NET Framework версии 3.5.  Дополнительные сведения см. в статье [Версии и зависимости платформы .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Приложение [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] имеет ассемблированную запись или <see cref="P:System.Windows.Application.ResourceAssembly" /> уже присвоено значение.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает коллекцию ресурсов области приложения, например, стилей и кистей.</summary>
        <value>Объект <see cref="T:System.Windows.ResourceDictionary" />, содержащий ноль или более ресурсов области приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A> Свойство может использоваться для использования общих ресурсов windows и элементы приложения. Кроме того <xref:System.Windows.Application.Resources%2A> свойство включено в путь для поиска ресурсов, который обходится в следующем порядке:  
  
1.  Элементы  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  Система  
  
 Следовательно [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] элементы можно привязать к ресурсов области приложения. Кроме того, если изменения ресурсов, в системе ресурсов гарантирует этого элемента свойства, которые привязаны к этим ресурсам автоматически обновляются в соответствии с изменениями.  
  
 Ресурсы области приложения предоставляют простой способ поддержки единой темы всего приложения. Можно легко создать тему в [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] с помощью `Application.Resources` тега. Тем не менее, если приложение поддерживает несколько тем, которые могут содержать большое количество элементов темы, может быть проще управлять ими с помощью одного <xref:System.Windows.ResourceDictionary> экземпляра для каждой темы. Таким образом, можно применить новую тему, свойства ресурсов в соответствующую <xref:System.Windows.ResourceDictionary>.  
  
 Есть две рекомендации при использовании <xref:System.Windows.Application.Resources%2A>. Во-первых, словарь *ключ* является объектом, поэтому необходимо использовать один и тот же экземпляр объекта, при установке и получении значения свойства (Обратите внимание, что при использовании строки в ключе учитывается регистр). Во-вторых, словарь *значение* является объектом, поэтому необходимо преобразовать значение в требуемый тип при получении значения свойства.  
  
 <xref:System.Windows.Application.Resources%2A> является поточно-ориентированным и доступен из любого потока.  
  
   
  
## Examples  
В этом примере показано, как использовать XAML вместе с ресурсов области приложения для создания согласованного внешнего вида. Первый пример взят из *App.xaml*; во-вторых, из *MainWindow.xaml*. 
  
[!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml?highlight=7)]  
  
 В следующем примере демонстрируется задание ресурса приложения в код и XAML (в файле App.xaml в C# проект WPF или файл Application.xaml файл в проекте WPF Visual Basic).  
  
 [!code-csharp[Setting-an-application-resource-in-code](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[Setting-an-application-resource-in-code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[Setting-an-application-resource-in-XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml?highlight=8-10)]  
  
 В следующем примере показано, как получить ресурс приложения в коде.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Запускает приложение Windows Presentation Foundation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает приложение Windows Presentation Foundation.</summary>
        <returns>Код выхода <see cref="T:System.Int32" />, возвращаемый приложением в операционную систему при завершении работы приложения. По умолчанию, код выхода равен 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> вызывается для запуска [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] приложения. Если вы определяете вашей <xref:System.Windows.Application> с помощью разметки, или разметки и кода программной части, <xref:System.Windows.Application.Run%2A> будет вызываться неявно. Тем не менее если определить ваш <xref:System.Windows.Application> с помощью кода, необходимо явно вызывать <xref:System.Windows.Application.Run%2A>.  
  
 Когда <xref:System.Windows.Application.Run%2A> вызове <xref:System.Windows.Application> присоединяет новый <xref:System.Windows.Threading.Dispatcher> экземпляра в поток пользовательского интерфейса. Далее, <xref:System.Windows.Threading.Dispatcher> объекта <xref:System.Windows.Threading.Dispatcher.Run%2A> вызывается метод, который запускает цикл обработки сообщений для обработки сообщений windows. Наконец <xref:System.Windows.Threading.Dispatcher> вызывает <xref:System.Windows.Application> объекта <xref:System.Windows.Application.OnStartup%2A> метод для вызова <xref:System.Windows.Application.Startup> событий. Следовательно, модель выполнения приложения был установлен обработки <xref:System.Windows.Application.Startup>, после чего приложение считается работать под управлением.  
  
 Приложение перестает работать, если <xref:System.Windows.Application.Shutdown%2A> вызывается; значение <xref:System.Windows.Application.ShutdownMode%2A> определяется свойством <xref:System.Windows.Application.Shutdown%2A> вызывается и это происходит автоматически, или вам нужно явно вызывать его.  
  
 <xref:System.Windows.Application.Run%2A> может вызываться только из потока, который создает <xref:System.Windows.Application> объекта. Кроме того <xref:System.Windows.Application.Run%2A> нельзя вызывать из [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
   
  
## Examples  
 В следующем примере показано приложение, использующее пользовательский <xref:System.Windows.Application> и поэтому явно должна вызывать <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> вызывается из приложения-владельца браузера (например, [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window"><see cref="T:System.Windows.Window" />, открывающееся автоматически при запуске приложения.</param>
        <summary>Запускает приложение Windows Presentation Foundation с открытием указанного окна.</summary>
        <returns>Код выхода <see cref="T:System.Int32" />, возвращаемый приложением в операционную систему при завершении работы приложения. По умолчанию, код выхода равен 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка расширяет <xref:System.Windows.Application.Run%2A> метод для открытия указанного окна после запуска приложения.  
  
 Если задать код <xref:System.Windows.Application> , открывает окно при запуске, явным образом вызвать <xref:System.Windows.Application.Run%2A>.  
  
 При создании вашей <xref:System.Windows.Application> с использованием разметки, разметки и кода, вы можете автоматически открыть окно при использовании одной из следующих способов:  
  
-   Декларативно, задав <xref:System.Windows.Application.StartupUri%2A>.  
  
-   Программно, путем обработки <xref:System.Windows.Application.Startup>.  
  
   
  
## Examples  
 В следующем примере показано приложение с помощью метода статическую запись, созданная точка, создающий экземпляр <xref:System.Windows.Application>, перед вызовом <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> вызывается из приложения-владельца браузера (например, [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь завершает сеанс Windows, выходя из системы или завершая работу операционной системы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию, приложение завершает работу, если завершается сеанс Windows, обычно возникает, когда пользователь выходит из системы или завершает работу. В этом случае Windows запрашивает у каждого откройте приложения, чтобы завершить работу. Тем не менее возможно, что приложения не могут быть готовы завершить работу, когда это происходит. Например приложение может иметь данные длиной в несогласованном состоянии, или в середине длительной операции. В таких ситуациях может возникнуть необходимость предотвратить завершение сеанса она будет гораздо полезнее, чтобы разрешить пользователям выбрать ли завершить текущий сеанс.  
  
 Можно обнаружить при завершении сеанса путем обработки <xref:System.Windows.Application.SessionEnding> событий. Если приложению требуется предотвратить завершение, сеанс <xref:System.Windows.SessionEndingCancelEventArgs> предоставляет аргумент, передаваемый обработчику событий <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> , задаваемый для `true` (значение по умолчанию — `false`).  
  
 Если <xref:System.Windows.Application.SessionEnding> не обрабатывается или обрабатывается без отменяется, <xref:System.Windows.Application.Shutdown%2A> вызывается и <xref:System.Windows.Application.Exit> события.  
  
 Чтобы получить дополнительные сведения о почему сеанс завершается, приложение может проверять <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, которая является одной из <xref:System.Windows.ReasonSessionEnding> значения (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> и <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding> не вызывается элементом консольных приложений.  
  
 <xref:System.Windows.Application.SessionEnding> возникает только в потоке, который создает <xref:System.Windows.Application> объекта.  
  
 <xref:System.Windows.Application.SessionEnding> вызывается для приложения браузера XAML (XBAP).  
  
   
  
## Examples  
 Следующий пример демонстрирует способ обработки <xref:System.Windows.Application.SessionEnding> событие и разрешить пользователю отменить его.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" />, определяющий положение, для которого следует создать файл cookie.</param>
        <param name="value"><see cref="T:System.String" />, содержащий данные о файле cookie.</param>
        <summary>Создает файл cookie для расположения, указанного <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Файл cookie представляет собой произвольной данных, которые могут быть сохранены в приложении на клиентском компьютере во время сеанса приложения (файлы cookie сеанса) или между сеансами приложения (постоянные файлы cookie). Оба типа файлов cookie, которые можно создать путем вызова <xref:System.Windows.Application.SetCookie%2A>.  
  
 Данные файлов cookie обычно принимает форму пары "имя значение" в следующем формате:  
  
 `Name=Value`  
  
 Передать строку этого формата для <xref:System.Windows.Application.SetCookie%2A>, вместе с <xref:System.Uri> расположения, для которого задается файл cookie (как правило, домен приложения).  
  
 Файл cookie является файлом cookie сеанса или постоянный файл cookie зависит от того, является ли файл cookie-строка, передаваемый <xref:System.Windows.Application.SetCookie%2A> включает дату окончания срока действия. Строка для файла cookie сеанса не включает дату окончания действия. Выполняет строку для постоянного файла cookie и должен быть в следующем формате:  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 Постоянные файлы Cookie хранятся в текущем [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] папке временных файлов Интернета для установки до истечения срока действия, в этом случае они удаляются. Постоянный файл cookie можно удалить из приложения, задав ее Дата окончания срока действия в значение даты и времени, который находится в прошлом.  
  
 Обзор файлов cookie в [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], см. в разделе [Общие сведения о переходах](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Если при попытке создать указанный файл cookie возникла проблема, функция <see langword="InternetSetCookie" /> (вызванная <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />) генерирует ошибку [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)].</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Для получения файла cookie для файла <see cref="T:System.Uri" />. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Для получения файла cookie для не являющихся файловыми <see cref="T:System.Uri" />. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершить работу приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершить работу приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.Application.Shutdown%2A> вызывается приложения останавливается. Можно обрабатывать <xref:System.Windows.Application.Exit> событие, чтобы определить, когда приложение должно завершить свою работу, чтобы выполнить необходимые операции.  
  
 <xref:System.Windows.Application.Shutdown%2A> неявно вызывается Windows Presentation Foundation в следующих ситуациях:  
  
-   Когда <xref:System.Windows.Application.ShutdownMode%2A> присваивается <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
-   Когда <xref:System.Windows.Application.ShutdownMode%2A> присваивается <xref:System.Windows.ShutdownMode.OnMainWindowClose>.  
  
-   Когда пользователь завершает сеанс и <xref:System.Windows.Application.SessionEnding> событий является необработанным либо обрабатываются без отмены.  
  
 Вызов <xref:System.Windows.Application.Shutdown%2A> явно заставляет приложение завершить работу, вне зависимости от <xref:System.Windows.Application.ShutdownMode%2A> параметр. Тем не менее если <xref:System.Windows.Application.ShutdownMode%2A> присваивается <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, необходимо вызвать <xref:System.Windows.Application.Shutdown%2A> завершить работу приложения.  
  
> [!IMPORTANT]
>  При <xref:System.Windows.Application.Shutdown%2A> является именем, приложение завершит работу независимо от того, следует ли <xref:System.Windows.Window.Closing> отмене события всех открытых окон.  
  
 Этот метод может вызываться только из потока, создавшего <xref:System.Windows.Application> объекта.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для разрешения использования все окна и события пользовательского ввода без ограничений. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Целочисленный код завершения для приложения. По умолчанию, код выхода равен 0.</param>
        <summary>Завершает работу приложения и передает указанный код завершения операционной системой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно обрабатывать <xref:System.Windows.Application.Exit> событие, чтобы устанавливать код выхода. Тем не менее при явном вызове <xref:System.Windows.Application.Shutdown%2A>, и вы обрабатываете <xref:System.Windows.Application.Exit> только устанавливать код выхода, можно последовательно вызвать методы <xref:System.Windows.Application.Shutdown%2A> вместо этого.  
  
 Этот метод может вызываться только из потока, создавшего <xref:System.Windows.Application> объекта.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для разрешения использования все окна и события пользовательского ввода без ограничений. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает условие, которое является причиной вызова метода <see cref="M:System.Windows.Application.Shutdown" />.</summary>
        <value>Значение перечисления <see cref="T:System.Windows.ShutdownMode" />. Значение по умолчанию — <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения останавливаться только тогда, когда <xref:System.Windows.Application.Shutdown%2A> вызывается метод приложения. Завершение работы может произойти, явно или неявно, как указано по значению <xref:System.Windows.Application.ShutdownMode%2A> свойство.  
  
 Если задать <xref:System.Windows.Application.ShutdownMode%2A> для <xref:System.Windows.ShutdownMode.OnLastWindowClose>, Windows Presentation Foundation (WPF) неявным образом вызывает <xref:System.Windows.Application.Shutdown%2A> при закрытии последнего окна в приложении, даже если какие-либо в настоящее время экземпляра окна задаются в качестве главного окна (см. в разделе <xref:System.Windows.Application.MainWindow%2A>).  
  
 Объект <xref:System.Windows.Application.ShutdownMode%2A> из <xref:System.Windows.ShutdownMode.OnMainWindowClose> в результате WPF неявно вызываете <xref:System.Windows.Application.Shutdown%2A> при <xref:System.Windows.Application.MainWindow%2A> закрывает, даже если другие окна открыты в настоящий момент.  
  
 Время существования некоторых приложений может не зависеть при главное окно или последнего окна закрывается, или может не быть зависимым от windows вообще. В таких случаях необходимо задать <xref:System.Windows.Application.ShutdownMode%2A> свойства <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, требующий явного <xref:System.Windows.Application.Shutdown%2A> вызов метода, чтобы остановить приложение. В противном случае выполнение приложения продолжается в фоновом режиме.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> можно настроить декларативно [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] или программным способом из кода.  
  
 Это свойство доступно только из потока, создавшего <xref:System.Windows.Application> объекта.  
  
   
  
## Examples  
 В следующем примере показано, как настроить <xref:System.Windows.Application.ShutdownMode%2A> для указания, что приложения должны быть закрыты явным образом.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при вызове метода <see cref="M:System.Windows.Application.Run" /> объекта <see cref="T:System.Windows.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типичное приложение Windows Presentation Foundation может выполнять различные задачи инициализации при запуске, включая:  
  
-   Обработка параметров командной строки.  
  
-   Открытие главного окна.  
  
-   Инициализация ресурсов области приложения.  
  
-   Инициализация свойств области приложения.  
  
 Можно задать декларативно главное окно и ресурсов области определения приложения, с помощью [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> и <xref:System.Windows.Application.Resources%2A>, соответственно). Иногда тем не менее, ресурсы или главное окно приложения можно определить только программными средствами во время выполнения. Кроме того свойств области приложения и параметры командной строки может использоваться только программным способом. Программный инициализация может быть выполнена путем обработки <xref:System.Windows.Application.Startup> события, включая следующие:  
  
-   Получать и обрабатывать параметры командной строки, которые доступны из <xref:System.Windows.StartupEventArgs.Args%2A> свойство <xref:System.Windows.StartupEventArgs> класс, который передается <xref:System.Windows.Application.Startup> обработчик событий.  
  
-   Инициализация ресурсов области определения приложения с помощью <xref:System.Windows.Application.Resources%2A> свойство.  
  
-   Инициализация свойств области приложения с помощью <xref:System.Windows.Application.Properties%2A> свойство.  
  
-   Создание экземпляра и отображение один (или более) windows.  
  
> [!NOTE]
>  Параметры командной строки также может быть получено путем вызова статического <xref:System.Environment.GetCommandLineArgs%2A> метод <xref:System.Environment> объекта. Тем не менее <xref:System.Environment.GetCommandLineArgs%2A> требует полного доверия для выполнения.  
  
 Если задать <xref:System.Windows.Application.StartupUri%2A> с помощью [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], главное окно, которое создается недоступен либо из <xref:System.Windows.Application.MainWindow%2A> свойство или <xref:System.Windows.Application.Windows%2A> свойство <xref:System.Windows.Application> объект, пока не после <xref:System.Windows.Application.Startup> событие обрабатывается. Если вам нужен доступ в главное окно во время запуска, необходимо вручную создать новый объект окна из вашей <xref:System.Windows.Application.Startup> обработчик событий.  
  
> [!NOTE]
>  Если приложение использует <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> задание политики учетных данных, необходимо задать <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> после <xref:System.Windows.Application.Startup> вызывается; в противном случае — значение [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] устанавливает его в политику по умолчанию внутренний непосредственно после <xref:System.Windows.Application.Startup> события.  
  
 Аргументы командной строки, передаваемые <xref:System.Windows.Application.Startup> обработчик событий не так же, как [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] параметры строки, передаваемые запроса [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].  
  
   
  
## Examples  
 В следующем примере показано, как получать и обрабатывать параметры командной строки из отдельного приложения. Если **/StartMinimized** командной строки, приложение открывает главное окно в свернутом состоянии.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] не удается получить и обработать аргументы командной строки, так как они запускаются с [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] развертывания (см. в разделе [развертывание приложений WPF (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). Однако они могут извлекать и обрабатывать строковые параметры запроса из URL-адресов, которые используются для их запуска.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает пользовательский интерфейс, отображающееся автоматически при запуске приложения.</summary>
        <value>Объект <see cref="T:System.Uri" /> , ссылающийся на пользовательский Интерфейс, который автоматически открывается при запуске приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Windows.Application.StartupUri%2A> для автоматической загрузки ресурса пользовательского интерфейса при запуске приложения.  
  
 В следующей таблице показаны типы ресурсов пользовательского интерфейса, которые могут быть загружены, тип окна, они открываются и типа приложения, который эти ресурсы можно задать в качестве <xref:System.Windows.Application.StartupUri%2A>.  
  
|Тип|Окно|Тип приложения|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|Только автономный|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|Только автономный|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|Автономный/Браузерные|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|Автономный/Браузерные|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|Автономный/Браузерные|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|Автономный/Браузерные|  
  
 Обычно задается <xref:System.Windows.Application.StartupUri%2A> декларативно в свойство [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]. Тем не менее, можно задать <xref:System.Windows.Application.StartupUri%2A> программным способом, например, в <xref:System.Windows.Application.Startup> обработчик событий, что полезно, если для приложения, необходимые ресурсы пользовательского интерфейса может загружать только во время выполнения. Например приложение может ожидать до времени выполнения для загрузки ресурсов, если имя ресурса пользовательского интерфейса хранится в файле конфигурации.  
  
 Выбран ли <xref:System.Windows.Application.StartupUri%2A> декларативно или программно, соответствующий пользовательский Интерфейс ресурс загружается только после <xref:System.Windows.Application.Startup> событие обрабатывается. Следовательно, не получат доступ к результирующему окну либо из <xref:System.Windows.Application.Windows%2A> свойство или <xref:System.Windows.Application.MainWindow%2A> свойство при обработке <xref:System.Windows.Application.Startup>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Application.StartupUri" /> устанавливается со значением null.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Имя запрошенного внешнего свойства.</param>
        <summary>Запрашивает, доступно ли заданное внешнее свойство в текущей области.</summary>
        <returns>Значение <see langword="true" />, если запрошенное внешнее свойство доступно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Windows.Application> приведен к типу интерфейса <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Имя искомого ресурса.</param>
        <summary>Осуществляет поиск указанного ресурса.</summary>
        <returns>Запрошенный объект ресурса. Если ресурс не найден, возвращается нулевая ссылка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> сначала просматривает ресурсов области приложения для указанного ресурса. Ресурсы области приложения управляются <xref:System.Windows.Application>и предоставляются из <xref:System.Windows.Application.Resources%2A> свойство. Если указанный ресурс не найден в наборе ресурсов области определения приложения, <xref:System.Windows.Application.TryFindResource%2A> затем выполняет поиск системных ресурсов. Системные ресурсы ресурсы оболочки, определяемый пользователем и добавляя цвета, шрифты и конфигурации оболочки. Они предоставляются из <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, и <xref:System.Windows.SystemParameters> соответственно, в виде статических свойств. Чтобы использовать <xref:System.Windows.Application.TryFindResource%2A> получить их, эти типы также предоставлять ключевые свойства ресурсов, которые призваны передается <xref:System.Windows.Application.TryFindResource%2A>, например <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Так как <xref:System.Windows.Application.TryFindResource%2A> возвращает объект, необходимо привести возвращаемое значение к соответствующему типу, если найти ресурс.  
  
 Этот метод является поточно-ориентированным и могут вызываться из любого потока.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Windows.Application.TryFindResource%2A> в получении ресурса.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает созданные окна приложения.</summary>
        <value>Объект <see cref="T:System.Windows.WindowCollection" />, содержащий ссылки на все объекты окна текущего <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Window> автоматически добавляется ссылка <xref:System.Windows.Application.Windows%2A> сразу же после создания экземпляра окна на [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] потока; в windows, созданных рабочих потоков не добавляются. Объект <xref:System.Windows.Window> ссылка автоматически удаляется после его <xref:System.Windows.Window.Closing> событие было обработано и перед его <xref:System.Windows.Window.Closed> события.  
  
 По умолчанию первый элемент добавлен <xref:System.Windows.Application.Windows%2A> свойство становится <xref:System.Windows.Application.MainWindow%2A>.  
  
 Это свойство доступно только из потока, создавшего <xref:System.Windows.Application> объекта.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как перечислить <xref:System.Windows.Application.Windows%2A> свойства для создания меню верхнего уровня Windows, которые являются общими для [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] приложения, например [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], или, например приложениями нескольких экземпляров одного документа интерфейс (SDI) [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>