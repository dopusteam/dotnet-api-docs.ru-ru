<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="708a1ffe3e315f5d8bcff28cce08c73843f9f63b" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56346230" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Содержит информацию о состоянии и данные события, связанные с перенаправленным событием.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Различные <xref:System.Windows.RoutedEventArgs> может использоваться с одним <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Этот класс отвечает за упаковку данных события для <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, предоставляя сведения о состоянии дополнительных событий и используется системой событий для вызова обработчика, связанного с данным перенаправленным событием.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого конструктора без параметров, все открытые свойства нового <xref:System.Windows.RoutedEventArgs> экземпляр предполагают следующие значения по умолчанию:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> по умолчанию используется `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> значение по умолчанию — `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> по умолчанию используется `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> по умолчанию используется `null`.  
  
 Значения NULL для <xref:System.Windows.RoutedEventArgs.Source%2A> и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> только означает, что <xref:System.Windows.RoutedEventArgs> данных не предпринимает попытки для указания источника. При использовании этого экземпляра в вызове <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> значения заполняются на основе элемента, который вызвал событие и передаются в прослушиватели через маршрутизацию.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Идентификатор маршрутизируемого события для данного экземпляра класса <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" /> с помощью переданного идентификатора маршрутизируемого события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого перегруженного конструктора, не указано свойства нового <xref:System.Windows.RoutedEventArgs> экземпляр предполагают следующие значения по умолчанию:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> значение по умолчанию — `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> по умолчанию используется `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> по умолчанию используется `null`.  
  
 Значения NULL для <xref:System.Windows.RoutedEventArgs.Source%2A> и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> только означает, что это <xref:System.Windows.RoutedEventArgs> не предпринимаются попытки для указания источника. При использовании этого экземпляра в вызове <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> значения заполняются на основе элемента, который вызвал событие и передаются в прослушиватели через маршрутизацию.  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Windows.RoutedEventArgs> для использования в вызове <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Идентификатор маршрутизируемого события для данного экземпляра класса <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <param name="source">Альтернативный источник, который будет сообщен при обработке события. Предварительно заполняет свойство <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" /> с помощью переданного идентификатора маршрутизируемого события, предоставляя возможность объявить другой источник события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого перегруженного конструктора, не указано свойства нового <xref:System.Windows.RoutedEventArgs> экземпляр предполагают следующие значения по умолчанию:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> значение по умолчанию — `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> по умолчанию используется `null`.  
  
 Значения NULL для <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> заполняются на основе элемента, вызвавшего событие и передать маршрутизации, но будет считывать `null` до вызова.  
  
 Использовать следующую сигнатуру, при передаче <xref:System.Windows.RoutedEventArgs> для виртуальных функций, таких как <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, где эти аргументы используются для вызова <xref:System.Windows.UIElement.RaiseEvent%2A> внутренним образом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, обозначающее текущее состояние обработки перенаправленного события при перемещении по маршруту.</summary>
        <value>При настройке задайте <see langword="true" /> Если событие помечается как обработанное; в противном случае <see langword="false" />. При считывании данного значения <see langword="true" /> указывает, что обработчик класса или некоторые обработчик экземпляра на маршруте уже пометил это событие как обработанное. Значение <see langword="false" /> указывает, что ни один из обработчиков не пометил событие как обработанное.  
  
Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Маркировка события как обработанного ограничивает видимость перенаправленного события прослушиватели на маршруте события. Событие по-прежнему переместиться в оставшейся части маршрута, но только обработчики специально добавлены с классом `HandledEventsToo` `true` в <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> вызов метода будет вызываться в ответ. По умолчанию обработчики в прослушиватели экземпляров (например, тех, выраженное в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) не будет вызываться. Обработка событий, которые помечены как обработанные не является распространенным сценарием.  
  
 Если вы являетесь автором элемента управления определение собственные события, принятые решения относительно событий обработки на уровне класса повлияет на пользователей вашего элемента управления, а также всех пользователей этой производные элементы управления и потенциально содержатся другие элементы, которые могут быть элементом управления или его содержат. Дополнительные сведения см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 В очень редких случаях он подходит для обработки событий, где <xref:System.Windows.RoutedEventArgs.Handled%2A> помечен `true`и изменять аргументы события изменяя <xref:System.Windows.RoutedEventArgs.Handled%2A> для `false`. Это может потребоваться в некоторых областях входных событий элементов управления, например ключей обработки <xref:System.Windows.UIElement.KeyDown> и <xref:System.Windows.UIElement.TextInput> где низкий уровень и высокого уровня события ввода соревнуются за обработку каждого пытается работать с другую стратегию маршрутизации.  
  
   
  
## Examples  
 Следующий пример реализует обработчик событий, который помечает событие как обработанное.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Универсальная реализация обработчика или делегата для вызова.</param>
        <param name="genericTarget">Целевой объект, для которого нужно вызвать предоставленный обработчик.</param>
        <summary>При переопределении в производном классе предоставляет способ вызова обработчиков событий в зависимости от конкретного типа, что может повысить эффективность по сравнению с базовой реализацией.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация содержит отражение для определения правильного обработчика в любом случае, когда обработчик не буквально <xref:System.Windows.RoutedEventHandler>, и этот шаг отражения не обходится без последствий производительности. Вызовы могут выполняться более эффективно, не полагаясь на отражении. Это сценарий мотивирует доступным для любого класса перенаправленных событий, который сможет его переопределить данный метод. Реализации не должны вызывать базовый этот метод, так как ваша реализация уже должна отвечать за вызов типобезопасных обработчиков.  
  
   
  
## Examples  
 Ниже приведен псевдокод, иллюстрирующий базовый шаблон, который может использоваться для реализации. Здесь `MyRoutedEventHandler` является подклассом <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Этот метод предназначен для переопределения классами данных производного события для обеспечения более эффективного вызова их делегатов. Реализация следует привести предоставленный <paramref name="genericHandler" /> для конкретного типа делегата, а затем вызывать этот обработчик.  
  
Реализация по умолчанию будет пытаться вызвать предоставленный обработчик, попытка приведения его как <see cref="T:System.Windows.RoutedEventHandler" />. Если параметр <paramref name="genericHandler" /> или <paramref name="genericTarget" /> предоставляется в качестве <see langword="null" />, возникает исключения.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Новое значение, которое задается для <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>При переопределении в производном классе предоставляет точку входа обратного вызова для уведомления в случае изменения значения свойства <see cref="P:System.Windows.RoutedEventArgs.Source" /> в экземпляре.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Программное изменение сообщаемого источника события потенциально может потребоваться обновление данных определенного типа в событии. По этой причине <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> защищенный виртуальный метод и предназначен для переопределяться подклассами <see cref="T:System.Windows.RoutedEventArgs" />.  
  
Этот метод не имеет значение по умолчанию реализации.</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает исходный источник отчетов, определяемый чистой проверкой нажатия до какой-либо возможной корректировки <see cref="P:System.Windows.RoutedEventArgs.Source" /> родительским классом.</summary>
        <value>Исходный источник отчетов до какой-либо возможной корректировки <see cref="P:System.Windows.RoutedEventArgs.Source" />, произведенной обработкой классов, например, с целью выравнивания деревьев элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство получает свое значение один раз, до класса вызываются обработчики событий или обработчиков экземпляров и никогда не изменяется после этой точки. Информация об исходном источнике только для чтения к обработчики классов или реализаций класса, так же, как оно будет отмечено в данных события.  
  
 Обычные варианты, где можно менять источник включают элементами содержимого внутри модели содержимого для элемента управления (содержимое элемента списка, к примеру, сообщит элемент списка, как <xref:System.Windows.RoutedEventArgs.Source%2A> и фактический элемент в элементе списка будет <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Корректировка источника различными элементами и моделями содержимого зависит от класса к классу. Каждый класс, который изменяет источники событий пытается предугадать, какой источник наиболее полезен для сообщения в большинстве сценариев ввода и сценариев, для которых предназначен этот класс, а затем наборы, источник как <xref:System.Windows.RoutedEventArgs.Source%2A>. Если этот источник не имеет значения для собственной обработки события, попробуйте проверить <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> вместо этого он сообщает о другого источника, которое больше подходит. Дополнительные сведения о входных событий, см. в разделе [входной Обзор](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />, связанный с этим экземпляром <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <value>Идентификатор вызванного события.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нельзя задать это значение на <xref:System.Windows.RoutedEventArgs> , уже передана по маршруту (например, если вы приобрели аргументы через обработчик). Попытка выполнить такую операцию вызовет исключение. Можно только разместить его в экземпляре, который еще не использовался для генерирования вызова события.  
  
 Значение <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> не может быть `null` в любое время.  
  
   
  
## Examples  
 Следующий пример создает новые данные перенаправленного события с начальной конструктором, а затем задает <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> свойство как последующей выполняемой операции. Необходимо иметь <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> задана до того, перенаправленные события.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка изменить значение <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> во время маршрутизации события.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает ссылку на объект, создавший событие.</summary>
        <value>Объект, создавший событие.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для любой восходящей маршрутизации перенаправленного события, которое фактически прошло маршрут после элемента, вызвавшего его, и для любого туннелирование перенаправленное событие, не имеющий еще туннелируется вниз до элемента, вызвавшего его значение <xref:System.Windows.RoutedEventArgs.Source%2A> будет отличаться от значения `sender` настроек параметр класс аргументов события. Какой из двух элементов, участвующий в событии является наиболее важны в любой заданный обработчик (<xref:System.Windows.RoutedEventArgs.Source%2A>, элемента, вызвавшего его, или `sender`, элемент, который в настоящий момент обрабатывает оно) зависит от логики приложения, которая является обработчиком адресация.  
  
 Задание этого свойства обычно выполняется только при переопределении или при реализации других [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] , настройте источники событий, например, когда обработчик события класса. Сбрасывать видимых источников событий от обработчиков экземпляров не рекомендуется, особенно в том случае, если обработчик не помечает событие как обработанное.  
  
 При сбросе <xref:System.Windows.RoutedEventArgs.Source%2A> сообщить источнику другое событие <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> продолжит создавать отчеты, вызванных источник в виде первой адресом отправителя <xref:System.Windows.UIElement.RaiseEvent%2A> вызова.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>