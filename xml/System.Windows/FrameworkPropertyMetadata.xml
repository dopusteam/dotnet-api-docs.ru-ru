<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FrameworkPropertyMetadata.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c70304d7b52b8f4e76c37fd1e35de0928f9619c7.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c70304d7b52b8f4e76c37fd1e35de0928f9619c7</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Reports or applies metadata for a dependency property, specifically adding framework-specific property system characteristics.</source>
          <target state="translated">Сообщает или применяет метаданные для свойства зависимостей, добавляя характеристики системы свойств, специфичные для платформы.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This class derives from <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> (through <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>) .</source>
          <target state="translated">Этот класс является производным от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> (через <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>For most WPF framework-level application development purposes, <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> is the type used for dependency property metadata, rather than the base metadata types <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>.</source>
          <target state="translated">Для большинства целей разработки приложений уровня платформы WPF <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> является типом, используемым для метаданные свойства зависимостей, а не типы базовых метаданных <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> или <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This is true both for existing dependency properties and for most custom dependency property scenarios.</source>
          <target state="translated">Это верно как для существующих свойств зависимостей, так и для большинства настраиваемых сценариев свойств зависимостей.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The members declared by this class that supplement the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> base class include various Boolean properties that specify or report WPF framework-level property system behavior such as property inheritance, data binding, and layout.</source>
          <target state="translated">Члены, объявленные в этом классе, дополнения <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> базового класса включает множество логических свойств, задающих или поведение системы свойства уровня платформы WPF, таких как наследование, привязка данных и макет отчета.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Several constructor signatures for creating a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instance take a <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> parameter.</source>
          <target state="translated">Несколько сигнатур конструкторов для создания <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> принимают экземпляр <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> enumeration is used only to specify initial behavior in the constructor, and is not otherwise exposed after <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> is constructed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> Перечисления используется только для указания начальной поведения в конструкторе и после не предоставляется <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> создается.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>From a constructed instance, you can get or set the corresponding information through various properties that share the name of the enumeration values used in the constructor call.</source>
          <target state="translated">Созданного экземпляра можно получить или задать соответствующую информацию через различные свойства, которые имеют имена значений перечисления, используемых в вызове конструктора.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This class is not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Этот класс обычно не используется в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The following example gets metadata for a dependency property on a particular owner as the initial base <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type.</source>
          <target state="translated">Следующий пример получает метаданные для свойства зависимостей для определенного владельца как начальный базовый <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> типа.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>That metadata is cast to <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</source>
          <target state="translated">Эти метаданные, приводится к <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>If the cast returned a valid <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>, then various <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> property values are reported through a simple UI (not shown).</source>
          <target state="translated">Если приведение возвращается допустимый <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>, а затем различные <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойство значения передаются через простой пользовательский Интерфейс (не показано).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source>This signature initializes all values of <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A&gt;</ph> to their property defaults.</source>
          <target state="translated">Эта подпись инициализирует все значения <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A&gt;</ph> по умолчанию для свойства.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> will be <ph id="ph2">`null`</ph>, and the various <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> Boolean properties will be <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> будет <ph id="ph2">`null`</ph>и различных <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> логических свойств будет <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified default value.</source>
          <target state="translated">Выполняет инициализацию нового экземпляра класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> с заданным по умолчанию значением.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного для <ph id="ph1">`defaultValue`</ph> должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">В следующем примере вызывается следующую сигнатуру конструктора:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">Параметру <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> задается значение <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> с указанным ответом <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">В следующем примере вызывается следующую сигнатуру конструктора:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Параметры флагов метаданных (комбинация значений <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework-level metadata options.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> с указанным значением по умолчанию и параметрами метаданных уровня платформы.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного для <ph id="ph1">`defaultValue`</ph> должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Значения, помеченных как набор флагов в <ph id="ph1">`flags`</ph> параметр задает логическое значение <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства, которые соответствуют, <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> имя флага <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>You can subsequently change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Впоследствии можно изменить значения свойств в метаданных, при условии, что метаданные не были применены к определенной операции системы.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">В следующем примере вызывается следующую сигнатуру конструктора:</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">Параметру <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> задается значение <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> с заданными значением по умолчанию и ответом <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного для <ph id="ph1">`defaultValue`</ph> должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">В следующем примере вызывается следующую сигнатуру конструктора:</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">Параметру <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> задается значение <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> for this dependency property.</source>
          <target state="translated">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> для данного свойства.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified callbacks.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> с указанными ответами.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>This implementation calls a base initializer and then adds the <ph id="ph1">`coerceValueCallback`</ph> by setting the property on the base instance.</source>
          <target state="translated">Эта реализация вызывает базовый инициализатор, а затем добавляет <ph id="ph1">`coerceValueCallback`</ph> , задав свойство в базовом экземпляре.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">В следующем примере вызывается следующую сигнатуру конструктора:</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Параметры флагов метаданных (комбинация значений <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, and specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> с указанным значением по умолчанию, параметрами метаданных платформы и ответами <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного для <ph id="ph1">`defaultValue`</ph> должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Значения, помеченных как набор флагов в <ph id="ph1">`flags`</ph> параметр задает логическое значение <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства, которые соответствуют, <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> имя флага <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">По-прежнему можно изменить значения свойств в метаданных, при условии, что метаданные не были применены к определенной операции системы.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">В следующем примере вызывается следующую сигнатуру конструктора:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">Параметру <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> задается значение <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> for this dependency property.</source>
          <target state="translated">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> для данного свойства.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and specified callbacks.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> с заданными значением по умолчанию и ответами.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного для <ph id="ph1">`defaultValue`</ph> должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">В следующем примере вызывается следующую сигнатуру конструктора:</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">Параметру <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> задается значение <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Параметры флагов метаданных (комбинация значений <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> against this property.</source>
          <target state="translated">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> против данного свойства.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, and specified callbacks.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> с указанным значением по умолчанию, параметрами метаданных платформы и ответами.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного для <ph id="ph1">`defaultValue`</ph> должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Значения, помеченных как набор флагов в <ph id="ph1">`flags`</ph> параметр задает логическое значение <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства, которые соответствуют, <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> имя флага <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">По-прежнему можно изменить значения свойств в метаданных, при условии, что метаданные не были применены к определенной операции системы.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">В следующем примере вызывается следующую сигнатуру конструктора:</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">Параметру <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> задается значение <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Параметры флагов метаданных (комбинация значений <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> on this dependency property.</source>
          <target state="translated">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> данного свойства.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to prevent the property system from animating the property that this metadata is applied to.</source>
          <target state="translated">Чтобы запретить системе управления свойствами воспроизводить анимацию для свойства, относящегося к данным метаданным, установите <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</source>
          <target state="translated">Подобные свойства вызывают исключения во время выполнения, проистекающие из системы управления свойствами при попытке применения к ним анимаций.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to permit animating the property.</source>
          <target state="translated">Для разрешения анимации свойства следует установить значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, specified callbacks, and a Boolean that can be used to prevent animation of the property.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> с указанным значением по умолчанию и установками метаданных платформы, указанными ответами и логическим значением, которое может быть использовано для предотвращения анимации свойства.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного для <ph id="ph1">`defaultValue`</ph> должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The <ph id="ph1">`isAnimationProhibited`</ph> parameter sets the initial value of the <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> property declared by the immediate base <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">`isAnimationProhibited`</ph> Параметр задает начальное значение <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> свойство объявлено с помощью интерпретации базового <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Значения, помеченных как набор флагов в <ph id="ph1">`flags`</ph> параметр задает логическое значение <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства, которые соответствуют, <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> имя флага <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">По-прежнему можно изменить значения свойств в метаданных, при условии, что метаданные не были применены к определенной операции системы.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">В следующем примере вызывается следующую сигнатуру конструктора:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">Параметру <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> задается значение <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Параметры флагов метаданных (комбинация значений <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> against this property.</source>
          <target state="translated">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> против данного свойства.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to prevent the property system from animating the property that this metadata is applied to.</source>
          <target state="translated">Чтобы запретить системе управления свойствами воспроизводить анимацию для свойства, относящегося к данным метаданным, установите <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</source>
          <target state="translated">Подобные свойства вызывают исключения во время выполнения, проистекающие из системы управления свойствами при попытке применения к ним анимаций.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> to use when bindings for this property are applied that have their <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> для использования, когда привязки, примененные к данному свойству имеют <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> со значением <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, specified callbacks, a Boolean that can be used to prevent animation of the property, and a data-binding update trigger default.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> с указанным значением по умолчанию и установками метаданных платформы, указанными ответами, логическим значением, которое может быть использовано для предотвращения анимации свойства и триггером обновления привязки данных по умолчанию.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">Тип значения, заданного для <ph id="ph1">`defaultValue`</ph> должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The <ph id="ph1">`isAnimationProhibited`</ph> parameter sets the initial value of the <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> property declared by the immediate base <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">`isAnimationProhibited`</ph> Параметр задает начальное значение <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> свойство объявлено с помощью интерпретации базового <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>For more information about the update source behavior for bindings, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об обновлении поведения источника привязки см. в разделе <bpt id="p1">[</bpt>Общие сведения о привязке данных<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Значения, помеченных как набор флагов в <ph id="ph1">`flags`</ph> параметр задает логическое значение <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства, которые соответствуют, <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> имя флага <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">По-прежнему можно изменить значения свойств в метаданных, при условии, что метаданные не были применены к определенной операции системы.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">Параметру <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> задается значение <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass during layout engine operations.</source>
          <target state="translated">Получает или задает значение, указывающее, может ли свойство зависимостей влиять на порядок размещения во время операций обработчика макета.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the arrange pass; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство зависимостей, в котором существуют эти метаданные, может влиять на порядок размещения; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> включает реализацию <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> , отслеживает изменения действующего значения все свойства зависимости, к элементу.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element (a call to <ph id="ph3">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph>).</source>
          <target state="translated">В составе этой логики свойств зависимостей, которые изменяют действующее значение и иметь метаданные с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> значение <ph id="ph2">`true`</ph> инициирует запрос отложенное переводимого визуальных элементов для этого элемента (вызов <ph id="ph3">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Так как эта реализация уровня инфраструктуры WPF уже, обычно не требуется искать свойств зависимостей с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> Если значительно замены или изменения поведения уровня платформы WPF.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Настраиваемый <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> реализации может выбрать возможность аналогичное поведение для изменения свойств зависимостей где <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> — <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства классов, производных от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Members of this class are either not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the measure pass during layout engine operations.</source>
          <target state="translated">Получает или задает значение, указывающее, может ли свойство зависимостей влиять на передачу измерения во время операций обработчика макета.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the measure pass; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство зависимостей, в котором существуют эти метаданные, может влиять на передачу измерения; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> включает реализацию <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> , отслеживает изменения действующего значения все свойства зависимости, к элементу.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element.</source>
          <target state="translated">В составе этой логики свойств зависимостей, которые изменяют действующее значение и иметь метаданные с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> значение <ph id="ph2">`true`</ph> будет инициировать запрос отложенное переводимого визуальных элементов для этого элемента.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Так как эта реализация уровня инфраструктуры WPF уже, обычно не требуется искать свойств зависимостей с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> Если значительно замены или изменения поведения уровня платформы WPF.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Настраиваемый <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> реализации может выбрать возможность аналогичное поведение для изменения свойств зависимостей где <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> — <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства классов, производных от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass of its parent element's layout during layout engine operations.</source>
          <target state="translated">Получает или задает значение, указывающее, может ли свойство зависимостей влиять на передачу размещения разметки родительского элемента во время операций обработчика разметки.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the arrange pass specifically on its parent element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство зависимостей, в котором существуют метаданные, влияет на передачу размещения непосредственно в родительском элементе; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> включает реализацию <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> , отслеживает изменения действующего значения все свойства зависимости, к элементу.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for the parent element.</source>
          <target state="translated">В составе этой логики свойств зависимостей, которые изменяют действующее значение и иметь метаданные с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> значение <ph id="ph2">`true`</ph> будет инициировать запрос отложенное переводимого визуальных элементов для родительского элемента.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Generally, you do not need to report changes of a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> property to a parent element using <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> because the element itself would already have its own <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> as <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Как правило, не требуется для изменения отчета <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> свойство с родительским элементом с помощью <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> поскольку сам элемент должен уже иметь свой собственный <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> как <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>That is usually sufficient, because changes in the child element generally initiate a parent arrange when appropriate.</source>
          <target state="translated">Обычно этого достаточно, поскольку изменения в дочернем элементе инициируют в родительском, когда это необходимо.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is sometimes used for a <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> Иногда используются для <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> производного класса.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>In this case, the child element sets a property, but a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class does not control its own rendering.</source>
          <target state="translated">В этом случае элемент дочерние наборы свойство, но элемент <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> производного класса не контролирует собственное воспроизведение.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The rendering is handled by a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> parent element that serves as the content host.</source>
          <target state="translated">Выполняет отрисовку <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> родительского элемента, который служит в качестве узла содержимого.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>For instance, a change to the value of the <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> attached property by a child element invalidates arrange of the parent, because the position of the child in the parent must be changed.</source>
          <target state="translated">Например, изменение значения из <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> делает недействительными вложенное свойство дочерним элементом упорядочивания родительского элемента, поскольку необходимо изменить позицию дочернего элемента в родительском объекте.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> attached property has metadata where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Таким образом <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> присоединенное свойство имеет метаданных где <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> — <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Another example is <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Padding%2A&gt;</ph>; when this property changes, the parent might change the positioning of the child, depending on available space.</source>
          <target state="translated">Еще один пример — <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Padding%2A&gt;</ph>; при изменении этого свойства, родительский может изменить позицию дочернего элемента, в зависимости от доступного пространства.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Так как эта реализация уровня инфраструктуры WPF уже, обычно не требуется искать свойств зависимостей с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> Если значительно замены или изменения поведения уровня платформы WPF.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Настраиваемый <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> реализации может выбрать возможность аналогичное поведение для изменения свойств зависимостей где <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> — <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства для какого-либо классы, унаследованные от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the measure pass of its parent element's layout during layout engine operations.</source>
          <target state="translated">Возвращает или задает значение, указывающее, может ли свойство зависимостей потенциально влиять на передачу показателей разметки родительского элемента во время операций обработчика разметки.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the measure pass specifically on its parent element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.The default is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство зависимостей, в котором существуют метаданные, влияет на передачу измерений непосредственно на родительском элементе; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>. Значение по умолчанию — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> включает реализацию <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> , отслеживает изменения действующего значения все свойства зависимости, к элементу.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for the parent element.</source>
          <target state="translated">В составе этой логики свойств зависимостей, которые изменяют действующее значение и иметь метаданные с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> значение <ph id="ph2">`true`</ph> будет инициировать запрос отложенное переводимого визуальных элементов для родительского элемента.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Так как эта реализация уровня инфраструктуры WPF уже, обычно не требуется искать свойств зависимостей с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> Если значительно замены или изменения поведения уровня платформы WPF.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Generally, you do not need to report changes of a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> property to a parent element using <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> because the element itself would already have its own <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> as <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Как правило, не требуется для изменения отчета <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> свойство с родительским элементом с помощью <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> поскольку сам элемент должен уже иметь свой собственный <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> как <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>That is usually sufficient, because changes in the child element generally initiate a parent measure pass when appropriate.</source>
          <target state="translated">Это обычно достаточно, поскольку изменения в дочернем элементе инициируют меру передачи в родительском, когда это необходимо.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is sometimes used for a <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> Иногда используются для <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> производного класса.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>In this case, the child element sets a property, but a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class does not control its own rendering.</source>
          <target state="translated">В этом случае элемент дочерние наборы свойство, но элемент <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> производного класса не контролирует собственное воспроизведение.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>The rendering is handled by a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> parent element that serves as the content host.</source>
          <target state="translated">Выполняет отрисовку <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> родительского элемента, который служит в качестве узла содержимого.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>For instance, a change to the value of the <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> property by a child element invalidates measure of the parent, because the relative spacing of paragraphs might change and might increase or decrease the content host size.</source>
          <target state="translated">Например, изменение значения из <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> свойство дочерним элементом делает недействительными измерения родительского элемента, поскольку относительные интервалы абзацев может изменять и может увеличить или уменьшить размер содержимого узла.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> property has metadata where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Таким образом <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> свойство имеет метаданных где <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> — <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Content host elements also frequently look for changes in dependency properties where <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph2">`true`</ph>, as part of content host rendering logic.</source>
          <target state="translated">Элементы содержимого узла также часто поиск изменений в свойствах зависимостей где <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> — <ph id="ph2">`true`</ph>, как часть логики отрисовки содержимого узла.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>For instance, the <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> element must respond to certain changes within text that might require that the bounding box of the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> itself be changed.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> элемент должен отвечать на определенных изменений в текст, который может оказаться необходимым, ограничивающего прямоугольника <ph id="ph2">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> изменить сам.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Настраиваемый <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> реализации может выбрать возможность аналогичное поведение для изменения свойств зависимостей где <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> — <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства для какого-либо классы, унаследованные от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the general layout in some way that does not specifically influence arrangement or measurement, but would require a redraw.</source>
          <target state="translated">Получает или задает значение, указывающее, может ли свойство зависимостей влиять на общий макет таким способом, который не оказывает специального воздействия на расположение или размеры, но требует перерисовку.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists affects rendering; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> если свойство зависимостей, содержащие эти метаданные, влияет на отрисовку; иначе — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> включает реализацию <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> , отслеживает изменения действующего значения все свойства зависимости, к элементу.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element.</source>
          <target state="translated">В составе этой логики свойств зависимостей, которые изменяют действующее значение и иметь метаданные с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> значение <ph id="ph2">`true`</ph> будет инициировать запрос отложенное переводимого визуальных элементов для этого элемента.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Так как эта реализация уровня инфраструктуры WPF уже, обычно не требуется искать свойств зависимостей с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> Если значительно замены или изменения поведения уровня платформы WPF.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Настраиваемый <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> реализации может выбрать возможность аналогичное поведение для изменения свойств зависимостей где <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> — <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства для какого-либо классы, унаследованные от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Gets or sets a value that indicates whether the property binds two-way by default.</source>
          <target state="translated">Получает или задает значение, указывающее, создает ли свойство двухсторонние привязки по умолчанию.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists binds two-way by default; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Если свойство зависимостей, в котором существуют эти метаданные, создает двухсторонние привязки по умолчанию. в противном случае <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>In absence of this property being <ph id="ph1">`true`</ph>, binding updates are one-way by default, based on the default behavior of the <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> constructors or equivalent <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">В отсутствие того, что это свойство <ph id="ph1">`true`</ph>, обновления привязки являются односторонними по умолчанию, в зависимости от поведения по умолчанию <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> конструкторы или аналогичной <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> синтаксиса.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>In existing elements, you will usually find this property set to <ph id="ph1">`true`</ph> in metadata for dependency properties that both report state and are modifiable by user action, for example <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">В существующих элементов, обычно можно найти это свойство установлено в <ph id="ph1">`true`</ph> в метаданных для свойства зависимостей, что отчет состояния и могут быть изменены с помощью пользователя, например <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>This property only reports the default binding update characteristics of the dependency property in general.</source>
          <target state="translated">Это свойство сообщает только об характеристиках обновления привязки по умолчанию для свойства зависимостей в целом.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Any binding set to this property on an instance can locally set the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.Mode%2A&gt;</ph> property of the binding and change this default.</source>
          <target state="translated">Любая привязка, значение этого свойства в экземпляре локально можно задать <ph id="ph1">&lt;xref:System.Windows.Data.Binding.Mode%2A&gt;</ph> свойства привязки и изменить параметры по умолчанию.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства для какого-либо классы, унаследованные от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Gets or sets the default for <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> to use when bindings for the property with this metadata are applied, which have their <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated">Получает или задает значение по умолчанию для <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph>, который используется при привязке свойства к которому применены данные метаданные, с <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> имеющими значение <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>A value of the enumeration, other than <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated">Значение перечисления, кроме как <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства классов, производных от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>This property is set to <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>; the value you set is supposed to become the default when requested by bindings.</source>
          <target state="translated">Данному свойству присвоено значение <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>; указанное значение будет считаться значением по умолчанию при получении запросов от привязок.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Gets or sets a value that indicates whether the value of the dependency property is inheritable.</source>
          <target state="translated">Получает или задает значение, которое указывает, наследуется ли значение свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value is inheritable; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение свойства может быть унаследовано; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Property value inheritance is a feature of the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system at the WPF framework level, whereby certain dependency properties can be locally set on an element at or near the root of a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> element tree and then have their value inherited by all elements within the logical tree of child elements that also possess that property.</source>
          <target state="translated">Наследование значения свойства — это функция <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> системы свойств на уровне framework WPF, при котором некоторые свойства зависимостей можно локально установлены на элементе близка к корневой <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> элемент дерева и их показатель наследуются все элементы в логическом дереве дочерние элементы, которые также обладают этим свойством.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Property value inheritance is not enabled by default, and enabling it does have some performance implications.</source>
          <target state="translated">Наследование значения свойства не включен по умолчанию, и его подключение имеет некоторые последствия для производительности.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>For details, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Подробнее см. в разделе <bpt id="p1">[</bpt>Наследование значения свойства<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain object-object divisions in the runtime tree is undefined.</source>
          <target state="translated">Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимости, поведение наследования для неприсоединенного свойства в определенных разделов объект в дереве среды выполнения не определено.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Всегда используйте <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> для регистрации свойства, где указываются <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> в метаданных.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства классов, производных от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>Gets a value that indicates whether data binding is supported for the dependency property.</source>
          <target state="translated">Возвращает значение, указывающее, поддерживается ли привязка данных для свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data binding is supported on the dependency property to which this metadata applies; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> если привязка данных поддерживается для свойства зависимостей, к которому применяются эти метаданные; иначе — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>This property reports <ph id="ph1">`false`</ph> for one of two possible conditions: either data binding to a dependency property is not allowed because the dependency property is read-only (as reported in the dependency property identifier, not the metadata), or the value of another metadata property, <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>, is set to <ph id="ph3">`true`</ph> in this metadata.</source>
          <target state="translated">Это свойство сообщает <ph id="ph1">`false`</ph> для одного из двух возможных условий: привязка данных к свойству зависимостей запрещено, так как свойство зависимостей является доступным только для чтения (как указано в идентификатор свойства зависимостей не метаданных), либо значение другое свойство метаданных, <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>, равно <ph id="ph3">`true`</ph> в метаданных.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>This property is exposed as a convenience so that callers do not have to check both <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</source>
          <target state="translated">Это свойство предоставляется для удобства, чтобы вызывающие объекты не нужно проверять оба <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>If you are attempting to create metadata that specifies that an otherwise read/write property should not support data binding, specify the flag <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable&gt;</ph> (note the slight naming convention difference versus <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>).</source>
          <target state="translated">Если вы пытаетесь создать метаданные, указывающее, что в противном случае свойство чтения/записи не должны поддерживать привязку данных, укажите флаг <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable&gt;</ph> (Обратите внимание, небольшая разница соглашение об именовании и <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Gets or sets a value that indicates whether the dependency property supports data binding.</source>
          <target state="translated">Получает или задает значение, которое указывает, поддерживает ли свойство зависимостей привязку данных.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property does not support data binding; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство поддерживает привязку данных; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Note that this metadata property is set to <ph id="ph1">`true`</ph> specifically for properties that should not support data binding, despite being read-write properties.</source>
          <target state="translated">Обратите внимание, что это свойство метаданных имеет значение <ph id="ph1">`true`</ph> для свойств, которые не должны поддерживать привязку данных, вне зависимости от свойств чтения и записи.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The expectation is that in most cases where a dependency property is declared, data binding is desired, because data binding is one of the key scenarios where a dependency property is useful.</source>
          <target state="translated">Ожидается, что в большинстве случаев, где объявлен свойство зависимостей привязку данных требуется, так как привязка данных является одним из основных сценариев, когда полезно свойством зависимостей.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Unlike <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A&gt;</ph>, this does not merely change a default that can later be changed on a specific binding.</source>
          <target state="translated">В отличие от <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A&gt;</ph>, при этом не меняется только значение по умолчанию, можно изменить позже на конкретной привязки.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Setting this property <ph id="ph1">`true`</ph> in the metadata for a dependency property metadata will disable all bindings from applying their values through expressions to that dependency property.</source>
          <target state="translated">Задание этого свойства <ph id="ph1">`true`</ph> в метаданных для свойства зависимостей метаданных отключит все привязки применение значений посредством выражений к свойству зависимостей.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Read-only dependency properties do not support data binding (because they have no setter that can apply changed values), but will still report <ph id="ph1">`false`</ph> for <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</source>
          <target state="translated">Свойства зависимости только для чтения не поддерживают привязку данных (из-за наличия нет метода задания свойства, можно применить измененные значения), но отчет будет по-прежнему <ph id="ph1">`false`</ph> для <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>This is because properties that correspond to a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> values will report parity with how the metadata was actually established, rather than always reporting the end result behavior that the naming of the property might imply.</source>
          <target state="translated">Это так, как свойства, которые соответствуют <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> сообщают четность с как метаданные были фактически установлены, вместо того чтобы всегда reporting результирующем поведении, именование свойство может подразумеваться значения.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>To determine whether a given dependency property permits data binding, you should usually check <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> instead.</source>
          <target state="translated">Чтобы определить, допускает ли указанному свойству зависимостей привязку данных, обычно следует проверить <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> вместо него.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> is a convenience for checking both <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph> as a single operation, yielding the expected result.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> — удобный метод для проверки и <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> и <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph> в ходе одной операции, возвращая ожидаемый результат.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства классов, производных от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Gets or sets a value that indicates whether this property contains journaling information that applications can or should store as part of a journaling implementation.</source>
          <target state="translated">Получает или задает значение, указывающее, содержит ли это свойство сведения о ведении журнала, которые приложения могут или должны хранить как часть реализации процесса ведения журнала.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if journaling should be performed on the dependency property that this metadata is applied to; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Если ведение журнала, которые следует выполнить для свойства зависимостей, к которому применяются эти метаданные в противном случае <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства классов, производных от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The base metadata to merge.</source>
          <target state="translated">Базовые метаданные для слияния.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The dependency property this metadata is being applied to.</source>
          <target state="translated">Свойство зависимостей, к которому применяются эти метаданные.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Enables a merge of the source metadata with base metadata.</source>
          <target state="translated">Обеспечивает слияние исходных метаданных с базовыми.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>This method is used internally when metadata is being overridden.</source>
          <target state="translated">Этот метод используется внутренне при переопределении метаданных.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Classes that derive from <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> (or this class particularly) should override this method to account for any metadata properties they have added in their implementations.</source>
          <target state="translated">Классы, производные от <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> (или данный класс в особенности) должны переопределять этот метод для учетной записи для всех свойств метаданных, добавленных в их реализации.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>For instance, your implementation might have added a new flagwise enumeration value, and the <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementation should then be able to combine those flags correctly.</source>
          <target state="translated">Например, для реализации могут быть добавлены новое значение флагового перечисления и <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> реализации должна быть возможность правильно объединить эти флаги.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Always call the base implementation prior to your own implementation, because the base implementation takes care of merging all the properties already defined on previous types in the hierarchy.</source>
          <target state="translated">Всегда вызовите базовую реализацию до свою собственную реализацию, так как базовая реализация берет на себя все свойства, которые уже определены на предыдущих типов в иерархии.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The behavior added by the <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementation in <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> is that specific WPF framework-level properties in the metadata such as <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /&gt;</ph> are combined in a bitwise or operation.</source>
          <target state="translated">Поведение, добавленные <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> реализацию в <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> том, что определенные свойства уровня платформы WPF в метаданных, таких как <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /&gt;</ph> объединяются в побитовой операции или операции.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> behavior also implements the behavior when you override the property metadata on an existing dependency property by calling <ph id="ph2">&lt;see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" /&gt;</ph>., using override metadata that is <ph id="ph3">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> Поведение также реализует поведение при переопределении метаданные свойства для существующего свойства зависимостей, вызвав <ph id="ph2">&lt;see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" /&gt;</ph>., с помощью переопределения метаданных, <ph id="ph3">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">Свойство зависимостей, к которому были применены эти метаданные.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">Тип, связанный с этими метаданными, если это метаданные зависящие от типа.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>If this is default metadata, this value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">В случае с метаданными по умолчанию, значение может быть <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">Вызывается после применения данных метаданных к свойству, указывая на запечатывание метаданных.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Any mutability of the data structure of a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instance should be marked as immutable when this method is invoked.</source>
          <target state="translated">Все изменения структуры данных <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> экземпляр должен быть помечен как неизменяемое при вызове этого метода.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> implementation of this method does nothing beyond calling the base implementation.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> Реализация этого метода не выполняет никаких действий после вызова базовой реализации.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Gets or sets a value that indicates whether the property value inheritance evaluation should span across certain content boundaries in the logical tree of elements.</source>
          <target state="translated">Возвращает или задает значение, указывающее, должно ли вычисление наследования значения свойства охватывать определенные границы содержимого в логическом дереве элементов.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value inheritance should span across certain content boundaries; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> если наследование значения свойства распространяться по определенным вместителям содержимого; иначе — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>This metadata reports a seldom-applied modification to property value inheritance behavior across special parent element-child element boundaries.</source>
          <target state="translated">Эти метаданные сообщают редких изменениях поведения наследования значения свойства через границы элемента специальный родительский элемент потомок.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The canonical example of such a boundary is the contents of a <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, where the <ph id="ph2">&lt;xref:System.Windows.Controls.Frame&gt;</ph> content might get reloaded independently of the existence of the <ph id="ph3">&lt;xref:System.Windows.Controls.Frame&gt;</ph>.</source>
          <target state="translated">Типичный пример таких границы — содержимое <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, где <ph id="ph2">&lt;xref:System.Windows.Controls.Frame&gt;</ph> содержимое может получить перезагружен независимо от наличия <ph id="ph3">&lt;xref:System.Windows.Controls.Frame&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The desired property system behavior is that property value inheritance should not traverse into the contents of the <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, because these contents might be elements that the application hosting the frame does not own or control.</source>
          <target state="translated">Поведение системы нужного свойства заключается в том, что наследование значения свойства следует не передаются в содержимое <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, так как им могут быть элементы, которые размещения фрейма приложения не владеете или управляете.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Specifying metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A&gt;</ph> set to <ph id="ph2">`true`</ph>, as well as specifying <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> as <ph id="ph4">`true`</ph>, will cause the property on which the metadata is applied to be inheritable even across the <ph id="ph5">&lt;xref:System.Windows.Controls.Frame&gt;</ph> boundary or similar boundaries.</source>
          <target state="translated">Указывать метаданные с <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A&gt;</ph> значение <ph id="ph2">`true`</ph>, а также как указание <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> как <ph id="ph4">`true`</ph>, приведет к свойство, к которому применяется метаданные к наследуемому даже через <ph id="ph5">&lt;xref:System.Windows.Controls.Frame&gt;</ph> границ или аналогичные границы.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства классов, производных от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Однако после метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Gets or sets a value that indicates whether sub-properties of the dependency property do not affect the rendering of the containing object.</source>
          <target state="translated">Возвращает или задает значение, указывающее, влияют ли подсвойства свойства зависимостей на отрисовку вмещающего объекта.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if changes to sub-property values do not affect rendering if changed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> в случае, если изменения в подсвойствах не влияют на отрисовку; иначе — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>This metadata option is pertinent for dependency properties that are reference types, where that type has property values of its own.</source>
          <target state="translated">Этот параметр метаданные относятся к свойствам зависимостей, которые являются ссылочными типами, где тип имеет собственные значения свойств.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Typically, the layout system logic is to assume that any dependency property with sub-properties potentially will affect layout, because checking all sub-properties for changes is more time consuming than actually running another render pass.</source>
          <target state="translated">Как правило логика системы структуры — предполагается, что любое свойство зависимостей с подсвойств потенциально влияет на структуру, так как проверка всех подсвойств изменения занимает больше времени чем другой прохода отрисовки.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Setting this option to <ph id="ph1">`true`</ph> is useful for optimizing performance of the WPF framework level layout system implementation.</source>
          <target state="translated">Установка данного параметра равным <ph id="ph1">`true`</ph> полезен для оптимизации производительности реализации системы макета уровня платформы WPF.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Свойства классов, производных от <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> обычно определяются в объектной модели для чтения записи.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Это так, что их можно изменить после инициализации экземпляра.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Тем не менее когда метаданные используются как часть вызова <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Попытка задать это свойство после <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> — <ph id="ph2">`true`</ph> на эти метаданные экземпляра вызовет исключение.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Члены этого класса обычно не используются в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>