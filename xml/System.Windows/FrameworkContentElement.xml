<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a6c8f64cb523baf870330f4332b567df43a0e14" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57929417" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.FrameworkContentElement" /> является реализацией уровня платформы WPF и расширением базового класса <see cref="T:System.Windows.ContentElement" />. <see cref="T:System.Windows.FrameworkContentElement" /> добавляет поддержку дополнительных API входных данных (включая подсказки и контекстные меню), раскадровки, контексты данных для привязки, поддержку стилей и вспомогательные API логического дерева.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> еще не определяет собственное поведение отрисовки; Создание экземпляра реальный <xref:System.Windows.FrameworkContentElement> экземпляра класса в коде или разметке возможна, но не отображает ничего в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] приложения [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Подготовка к просмотру логика должна предоставлять классы, которые принимают <xref:System.Windows.FrameworkContentElement> дочерние элементы как часть их содержимого модели, или в <xref:System.Windows.FrameworkContentElement> производных классов.  
  
 <xref:System.Windows.FrameworkContentElement> намеренно параллельно многие одной и той же [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] как <xref:System.Windows.FrameworkElement>. Обратите внимание что определенные [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] на <xref:System.Windows.FrameworkElement> не будет иметь <xref:System.Windows.FrameworkContentElement> эквивалент. Некоторые из <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] предназначены для функции, такие как представление geometry или макета, которые не являются значимыми для <xref:System.Windows.FrameworkContentElement>.  
  
 Большинство существующих <xref:System.Windows.FrameworkContentElement> производные классы, которые будут находиться в <xref:System.Windows.Documents> пространства имен. Многие из этих производных классов реализуют элементы для модели потокового документа. Некоторых производных классов, таких как <xref:System.Windows.Documents.Hyperlink> имеет некоторых функциональных возможностей схожих с элементами управления, но являются производными от <xref:System.Windows.FrameworkContentElement> таким образом, что элементы схожих с элементами управления по-прежнему могут участвовать в модели потокового документа.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Добавляемый дочерний элемент.</param>
        <summary>Добавляет указанный элемент в качестве дочернего для данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может создавать исключения, если вызывается в момент, когда выполняется итерация логического дерева с помощью другого процесса.  
  
 Большинство <xref:System.Windows.FrameworkContentElement> производные классы предоставляют выделенную коллекций, которые отвечают за вложения (например, <xref:System.Windows.Documents.Span.Inlines%2A> на <xref:System.Windows.Documents.Span> класса; <xref:System.Windows.Documents.Section.Blocks%2A> на <xref:System.Windows.Documents.Section> класса). Обычно необходимость управления логического дерева напрямую в том случае, если вы наследуете от этих классов, вместо этого можно избежать. Работа с логическим деревом для элементов содержимого — расширенный сценарий, который может потребовать специализированное средство синтаксического анализа или специализированный <xref:System.Windows.FrameworkElement> , выступающий в качестве родительского элемента отрисовки (хранилище содержимого).  
  
 Дополнительные сведения об использовании <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> и <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, см. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается перед инициализацией элемента.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Переопределите этот метод для обеспечения специальной обработки, которая будет выполняться перед инициализацией элемента в процессе его загрузки.  
  
Реализация должна вызывать базовую реализацию, так как реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации.  
  
Базовая реализация вызовет исключение, если <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> вызывается несколько раз на один и тот же элемент перед достижением <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для подписей, которые не используют `isControllable`, параметр, или если указан этот параметр `false`, связанными с анимацией часы шкалы времени удаляются сразу же чем наступит время «Заливка». Не анимации может быть перезапущено после однократного запуска. Обратите внимание на то, что управление анимацией также требует раскадровки именованный или уровень доступности, как экземпляр в коде.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <param name="handoffBehavior">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанием действий, которые следует выполнить в случае уже анимированного свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для подписей, которые не используют `isControllable`, параметр, или если указан этот параметр `false`, связанными с анимацией часы шкалы времени удаляются сразу же чем наступит время «Заливка». Не анимации может быть перезапущено после однократного запуска. Обратите внимание на то, что управление анимацией также требует раскадровки именованный или уровень доступности, как экземпляр в коде.  
  
## <a name="using-the-compose-handoffbehavior"></a>С помощью Compose HandoffBehavior  
 При применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>любые <xref:System.Windows.Media.Animation.Clock> ранее связанную с ним объекты по-прежнему потребляют ресурсы системы; система управления временем не не удаляет эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалять составные часы из анимируемого свойства после их завершения. Существует несколько способов удаления часов:  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> метод анимируемого объекта. Укажите в качестве первого параметра анимируемое свойство и `null` как второй. При этом удаляются все часы анимации из свойства.  
  
-   Чтобы удалить определенные <xref:System.Windows.Media.Animation.AnimationClock> из списка часов, используйте <xref:System.Windows.Media.Animation.Clock.Controller%2A> свойство <xref:System.Windows.Media.Animation.AnimationClock> извлекаемого <xref:System.Windows.Media.Animation.ClockController>, затем вызвать <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается <xref:System.Windows.Media.Animation.Clock.Completed> обработчик событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> дочерних часов вернет `null`. Обратите внимание, что <xref:System.Windows.Media.Animation.Clock.Completed> событие не происходит, если эффективная продолжительность часов — forever.  В этом случае пользователь должен определить, когда нужно вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект удаляется сборщиком мусора, его часы также будут отключены, и сборщиком мусора.  
  
 Дополнительные сведения об объектах часов см. в разделе [анимации и общие сведения о характере системы](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <param name="handoffBehavior">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</param>
        <param name="isControllable">Объявляет, является ли анимация управляемой после запуска (можно ли ее приостановить).</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанным состоянием управления анимацией после ее запуска.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для подписей, которые не используют `isControllable`, параметр, или если указан этот параметр `false`, связанными с анимацией часы шкалы времени удаляются сразу же чем наступит время «Заливка». Не анимации может быть перезапущено после однократного запуска. Обратите внимание на то, что управление анимацией также требует раскадровки именованный или уровень доступности, как экземпляр в коде.  
  
## <a name="using-the-compose-handoffbehavior"></a>С помощью Compose HandoffBehavior  
 При применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>любые <xref:System.Windows.Media.Animation.Clock> ранее связанную с ним объекты по-прежнему потребляют ресурсы системы; система управления временем не не удаляет эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большого количества часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, следует удалять составные часы из анимируемого свойства после их завершения. Существует несколько способов удаления часов:  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> метод анимируемого объекта. Укажите в качестве первого параметра анимируемое свойство и `null` как второй. При этом удаляются все часы анимации из свойства.  
  
-   Чтобы удалить определенные <xref:System.Windows.Media.Animation.AnimationClock> из списка часов, используйте <xref:System.Windows.Media.Animation.Clock.Controller%2A> свойство <xref:System.Windows.Media.Animation.AnimationClock> извлекаемого <xref:System.Windows.Media.Animation.ClockController>, затем вызвать <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается <xref:System.Windows.Media.Animation.Clock.Completed> обработчик событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> дочерних часов вернет `null`. Обратите внимание, что <xref:System.Windows.Media.Animation.Clock.Completed> событие не происходит, если эффективная продолжительность часов — forever.  В этом случае пользователь должен определить, когда нужно вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  Если объект удаляется сборщиком мусора, его часы также будут отключены, и сборщиком мусора.  
  
 Дополнительные сведения об объектах часов см. в разделе [анимации и общие сведения о характере системы](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает группу <see cref="T:System.Windows.Data.BindingGroup" />,  которая используется для элемента.</summary>
        <value>Группа <see cref="T:System.Windows.Data.BindingGroup" />, используемая для элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Data.BindingGroup> может использоваться для проверки значений нескольких свойств объекта. Например, предположим, что приложение предлагает пользователю ввести адрес, а затем заполняет объект типа `Address`, который имеет свойства `Street`, `City`, `ZipCode`, и `Country`, со значениями, пользователь предоставляются. Приложение имеет панель, которая содержит четыре <xref:System.Windows.Controls.TextBox> элементов управления, привязанных к одному из свойств объекта. Можно использовать <xref:System.Windows.Controls.ValidationRule> в <xref:System.Windows.Data.BindingGroup> проверяемый `Address` объекта. Например <xref:System.Windows.Controls.ValidationRule> гарантирует, что ZIP-код является допустимым в стране адреса.  
  
 Дочерние элементы наследуют <xref:System.Windows.Data.BindingGroup> от своих родительских элементов, как и в других наследуемое свойство.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода, вы фактически будет вызывать <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> на любой родительский прокручиваемую область, которая содержит элемент (родительский могут оказаться очень <xref:System.Windows.FrameworkElement>, а не <xref:System.Windows.FrameworkContentElement>). Если этот элемент не содержится в прокручиваемой области, по-прежнему вызывается событие, но будет существовать не влияет.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">Практическое руководство. Создание элемента управления ScrollViewer</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает элемент контекстного меню, который должен отображаться каждый раз при запросе контекстного меню через [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] из данного элемента.</summary>
        <value>Контекстное меню, используемое данным элементом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|Значение свойства метаданных `true`|None|  
  
   
  
## Examples  
 В следующих местах пример <xref:System.Windows.Controls.ContextMenu> на <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед закрытием какого-либо контекстного меню в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для подавления закрытия контекстных меню обработчики события следует пометить как обработанное.  
  
 Чтобы использовать это событие как <xref:System.Windows.EventTrigger> в стиле, необходимо сослаться на идентификатор события базовой службы:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Такое использование не требуются, поскольку реализация событий на <xref:System.Windows.FrameworkContentElement> , предоставляет базовые события службы не были сопоставлены правильно <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> идентификатор для использования в триггерах).  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|Стратегия маршрутизации|Восходящая маршрутизация|  
|делегат|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 В следующем примере реализуется обработчик, который изменяет курсор над Именованная область `DisplayArea` (не показано). Указывает комментарий на <xref:System.Windows.UIElement> использования, но на самом деле в этом примере будет совпадать с Если `DisplayArea` были <xref:System.Windows.FrameworkContentElement>.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификатор события, создаваемые при их регистрации (см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем может использоваться для добавления обработчиков классов (см. в разделе <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Идентификатор объекты содержат уникальное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при открытии какого-либо контекстного меню в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вручную открыть контекстные меню, обработчики событий следует помечать соответствующее событие как обработанное. В противном случае существующее значение <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> свойство будет использоваться для автоматического открытия контекстного меню. Маркировка события как обработанного эффективно отменит действие по умолчанию и может быть возможность сбросить значение <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> свойство и откройте новый <xref:System.Windows.Controls.ContextMenu>. Тем не менее есть ошибки синхронизации, которые следует учитывать. Чтобы полностью заменить контекстное меню способом <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> обработчик, начальной контекстное меню не должно быть null или пустым. Кроме того может потребоваться обработать событие и затем вручную открыть новое контекстное меню. Подробную информацию см. в разделе [Практическое руководство. Обработка события ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Чтобы использовать это событие как <xref:System.Windows.EventTrigger> в стиле, необходимо сослаться на идентификатор события базовой службы:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Такое использование не требуются, поскольку реализация событий на <xref:System.Windows.FrameworkContentElement> , предоставляет базовые события службы не были сопоставлены правильно <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> идентификатор для использования в триггерах).  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|Стратегия маршрутизации|Восходящая маршрутизация|  
|делегат|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификатор события, создаваемые при их регистрации (см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем может использоваться для добавления обработчиков классов (см. в разделе <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Идентификатор объекты содержат уникальное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка курсора, который отображается при наведении указателя мыши на этот элемент.</summary>
        <value>Отображаемый курсор. Значение по умолчанию определяется как <see langword="null" /> для данного свойства зависимостей. Однако на практике значение по умолчанию во время выполнения зависит от множества факторов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании этого свойства [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] процессора полагается на преобразования типов для <xref:System.Windows.Input.Cursor> класса для вычисления строки. Должно быть введенная строка <xref:System.Windows.Input.CursorType> значение. Подробные сведения см. в разделе <xref:System.Windows.Input.Cursor>.  
  
 Ли курсор, как установить это свойство будет или не выводится, когда указатель мыши находится над данным элементом зависит также от значения <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> свойство. Кроме того вопросы, связанные с событиями, как активное перетаскивание, захват мыши, режимы редактирования текста в элементы управления и т. д., также влияет на курсор с высоким приоритетом, чем значение, указанное в этом свойстве.  
  
 Чтобы отменить поведение этого свойства к стандартному, установите его в `null` еще раз.  
  
 `null` По умолчанию действительно означает, что определение практического значения курсора здесь отложено и должны быть получены из другого источника. Если отображается без программный значений из любого источника, курсор по умолчанию через [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] приложения будет стрелкой.  
  
 Каждое движение указателя мыши над [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] приложение создает событие <xref:System.Windows.ContentElement.QueryCursor> событий. Событие и любой элемент в маршруте имеет возможность обработать событие и установите для параметра курсора с помощью аргументов этого события. Если это произойдет, тот факт, что событие обрабатывается и имеет измененное значение в аргументах имеет приоритет над значением <xref:System.Windows.FrameworkContentElement.Cursor%2A> свойство на любом уровне, если только не <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> имеет значение.  
  
 Если не создается пользовательский курсор, обычно вы установите это свойство значение статического свойства <xref:System.Windows.Input.Cursors> класса.  
  
 Параметр <xref:System.Windows.Input.Cursor> пользовательское значение не включен в режиме частичного доверия. Дополнительные сведения о пользовательских курсоров, см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|Значение свойства метаданных `true`|None|  
  
   
  
## Examples  
 Следующий пример задает курсор пользовательское значение.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.Cursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст данных для элемента, участвующего в привязке данных.</summary>
        <value>Объект, используемый в качестве контекста данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Контекст данных* — это понятие, позволяет элементам наследовать сведения от своих родительских элементов об источнике привязки, который используется для привязки, а также другие характеристики привязки, например путь.  
  
 Контекст данных можно задать непосредственно в [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] объекта, с привязками, оценки свойств этого объекта. Кроме того, можно задать контекст данных <xref:System.Windows.Data.DataSourceProvider> объекта.  
  
 Это свойство зависимостей наследует значения свойств. Если существуют дочерние элементы, имеющие отсутствует значение для <xref:System.Windows.FrameworkContentElement.DataContext%2A> установленное при помощи локальных значений или стили, система свойств задаст значение должно быть <xref:System.Windows.FrameworkContentElement.DataContext%2A> значение ближайшего родительского элемента с назначенным данным значением.  
  
 Кроме того, можно использовать один из следующих свойств объекта <xref:System.Windows.Data.Binding> класс, чтобы явно указать источник привязки: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, или <xref:System.Windows.Data.Binding.RelativeSource%2A>. Дополнительные сведения см. в разделе [Как Указание источника привязки](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 В [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> чаще всего значение как <xref:System.Windows.Data.Binding> объявления. Можно использовать синтаксис элементов свойств или синтаксиса атрибутов. Синтаксис атрибутов показан в примере на этой странице. Можно также задать <xref:System.Windows.FrameworkContentElement.DataContext%2A> в коде.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *dataContextObject*  
 Непосредственно внедренный объект, который служит в качестве контекста данных для любых привязок внутри родительского элемента. Как правило, этот объект является <xref:System.Windows.Data.Binding> или другой <xref:System.Windows.Data.BindingBase> подкласс. Кроме того необработанные данные любого [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] тип, предназначенный для привязки могут быть помещены здесь, а фактические привязки, определенные позднее объекта.  
  
 *bindingUsage*  
 Использование привязки, результатом вычисления которого в соответствующий контекст данных. Дополнительные сведения см. в разделе [Привязка расширения разметки](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *ResourceExtension*  
 Одно из следующих: `StaticResource`, или `DynamicResource`. Такое использование используется при обращении к необработанным данным объектом, в ресурсах. См. в разделе [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Идентификатор ключа для запрашиваемого изнутри объекта <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 В следующем примере задается привязка на <xref:System.Windows.Documents.Paragraph> элемент, путем создания нового объекта пользовательские данные, установлении объект в качестве <xref:System.Windows.FrameworkContentElement.DataContext%2A>и указав путь привязки к свойству в ней.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении контекста данных настоящего элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Описание контекстов данных и привязки данных, см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Когда элемента <xref:System.Windows.FrameworkContentElement.DataContext%2A> потенциально подвержены изменения, все свойства с привязкой к данным в этом элементе. Это относится к элементов-потомков текущего элемента, которые наследуют контекст данных, все элементы, а также к самому текущему элементу. Все привязки повторно интерпретировать новый <xref:System.Windows.FrameworkContentElement.DataContext%2A> в соответствии с новым значением привязки. Нет никакой гарантии, производимые на порядок этих изменений относительно формирование <xref:System.Windows.FrameworkContentElement.DataContextChanged> событий.  Изменения могут произойти до события, после события или в любом сочетании.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ключ, используемый для поиска шаблона стиля данного элемента управления в темах.</summary>
        <value>Ключ стиля. Для корректной работы этого значения в ходе поиска тематического стиля ожидается, что оно принадлежит к типу <see cref="T:System.Type" /> элемента, к которому применяется стиль. <see langword="null" /> является значением, принятых в некоторых случаях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство обычно не задается через любой из его прямых переключателей. Вместо этого каждый раз при создании нового подкласса переопределить метаданные определенного типа данного свойства зависимостей. Когда вы подкласс, вызов <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> метода по отношению <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> идентификатор в статическом конструкторе подкласса элемента управления.  
  
 Для экземпляра класса встроенной, например <xref:System.Windows.Documents.Bold> фактически имеет очень мало реализацию помимо переопределения <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> метаданные в своем статическом конструкторе и предоставляет несколько конструкторов экземпляра. Тот факт, что элементы заключены в <xref:System.Windows.Documents.Bold> тег прибыль <xref:System.Windows.Documents.TextElement.FontWeight%2A> свойство <xref:System.Windows.FontWeights.Bold%2A> реализуется в тематическом стиле, на который ссылается параметр значение по умолчанию <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> для `typeof(Bold)`.  
  
 Элемент или элемент управления, намеренно не использовать тематические стили, задайте <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> свойства `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается сразу после инициализации элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализуется для обеспечения специальной обработки, которое должно происходить при инициализации элемента в процессе его загрузки.  
  
 Реализация должна вызывать базовую реализацию, так как реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации.  
  
 Если <xref:System.Windows.FrameworkContentElement.BeginInit%2A> ранее был вызван, базовый реализация будет создавать <xref:System.Windows.FrameworkContentElement.Initialized> событий. В противном случае, если <xref:System.Windows.FrameworkContentElement.BeginInit%2A> не был вызван или не удалось определить ли <xref:System.Windows.FrameworkContentElement.BeginInit%2A> был вызван, событие не вызывается.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя искомого элемента.</param>
        <summary>Находит элемент по указанному имени идентификатора.</summary>
        <returns>Запрошенный элемент. Может быть равен <see langword="null" />, если соответствующий элемент не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот элемент имеет дочерние элементы, эти дочерние элементы являются все выполняется рекурсивный поиск запрошенного именованного элемента.  
  
   
  
## Examples  
 В следующем примере задается свойство на элементе найден по имени в ссылке <xref:System.Windows.Documents.FlowDocument> на странице.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Идентификатор ключа искомого ресурса.</param>
        <summary>Ищет ресурс с указанным ключом и вызывает исключение, если запрошенный ресурс не удается найти.</summary>
        <returns>Найденный ресурс или <see langword="null" />, если соответствующий ресурс не найден (но при <see langword="null" /> также будет вызвано исключение).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Если этот метод вызывается для ключа, который не удается найти, создается исключение. Если вы не хотите обрабатывать исключения для этого случая, следует вызвать <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Возвращает `null` при ресурс не найден и выдает исключение.  
  
 Если ресурс не найден в вызывающем элементе, выполняется поиск в дереве родительского, с помощью логического дерева, таким же образом, который бы были запрошены искомая Если ресурс по ключу во время выполнения.  
  
 Обычно вы сразу же привести возвращаемое значение к типу свойства, которое вы пытаетесь значения возвращаемым ресурсом.  
  
   
  
## Examples  
 Следующий пример находит ресурс, определенный в разметке и применяет его к определенному свойству элемента в ответ на перенаправленное событие.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">Запрошенный ключ ресурса не найден.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект, позволяющий настройку внешнего вида, эффектов или других характеристик стиля, применяемых к данному элементу, когда он получает фокус клавиатуры.</summary>
        <value>Требуемый стиль для применения при получении фокуса. Значением по умолчанию, как объявлено в свойстве зависимостей, является пустой статический объект <see cref="T:System.Windows.Style" />. Тем не менее, действительным значением во время выполнения часто (но не всегда) является стиль, представленный поддержкой тем для элементов управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании этого свойства [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], стили, почти всегда определяются как ресурсов, а не встроенного как элемент, и, что это обычно называемое <xref:System.Windows.StaticResourceExtension>.  
  
 Обратите внимание, что это свойство влияет на внешний вид, но не сообщает это в метаданных. Это, поскольку изменение внешнего вида основано на событиях и могут применяться не все время и поэтому не следует сообщать обычно любые сведения о visual или макета в метаданных.  
  
 По существу визуальное поведение фокуса, примененное к элементу управления должно быть согласовано между элементами. Наиболее понятным способом применения согласованности является изменение визуального стиля фокуса только при составлении целой темы. Задание этого свойства отдельных стилей, а не как частью темы не предполагаемое использование этого свойства, так как это может привести к путанице при использовании фокуса клавиатуры. Если планируется поведение отдельных элементов, которое намеренно не согласовано в рамках темы, гораздо лучшим подходом является использование триггеры в стилях для отдельных свойств состояния ввода, таких как <xref:System.Windows.UIElement.IsFocused%2A> или <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>и таким образом способом, который не поддерживает визуально повлиять на работу любого существующего визуального стиля фокуса. Дополнительные сведения о необходимым <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> и альтернативное сосредоточиться свойств, см. в разделе [Стилизация фокуса в элементах управления и FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ResourceExtension*  
 Одно из следующих:, или. См. в разделе [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Ключ, который идентифицирует запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Синтаксис элемента свойства технически возможно, но не рекомендуется. См. в разделе [встроенные стили и шаблоны](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Ссылка на привязку с помощью или <xref:System.Windows.Data.Binding> — также, возможно, но встречается редко.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|Значение свойства метаданных `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должен ли данный <see cref="T:System.Windows.FrameworkContentElement" /> заставлять [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] визуализировать курсор, как объявлено свойством <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> данного экземпляра.</summary>
        <value><see langword="true" /> означает принудительное использование настройки данного экземпляра для презентации курсора, когда он находится над данным элементом (включая все дочерние); в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этому свойству присвоить `true` переопределит настройки курсора, установленные дочерними элементами. Поэтому в общем приложении это [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] может ввести в заблуждение пользователя, особенно в том случае, если дочерние элементы пытаются задавать курсоры. Параметр <xref:System.Windows.FrameworkElement.ForceCursor%2A> больше подходит в сценариях создания подклассов или композиции элемента управления.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|Значение свойства метаданных `true`|None|  
  
   
  
## Examples  
 В следующем примере принудительно курсор над элементом.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Целевое <see cref="T:System.Windows.DependencyProperty" />, из которого следует получить привязку.</param>
        <summary>Возвращает <see cref="T:System.Windows.Data.BindingExpression" /> для привязки указанного свойства.</summary>
        <returns>Возвращает <see cref="T:System.Windows.Data.BindingExpression" />, если цель привязана к данным; в противном случае — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере извлекается привязка, запросив свойство.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает альтернативный логический родительский объект для этого элемента при отсутствии визуального родительского объекта. В данном случае родительский объект <see cref="T:System.Windows.FrameworkContentElement" /> всегда имеет то же значение, что и свойство <see cref="P:System.Windows.FrameworkContentElement.Parent" />.</summary>
        <returns>Возвращает нечто, отличное от <see langword="null" />, каждый раз, когда реализация уровня инфраструктуры WPF этого метода имеет подключение без визуального родительского объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает ожидаемый одного визуального родительского объекта. Пользовательские реализации могут возвращать альтернативные родительские связи.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время инициализации данного <see cref="T:System.Windows.FrameworkContentElement" />. Это совпадает со случаями, когда значение свойства <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> меняется с <see langword="false" /> (или неопределенного) на <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие будет вызывается при изменении <xref:System.Windows.FrameworkContentElement.EndInit%2A> или <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> методы вызываются. Вызовы этих методов могут выполняться с произвольного кода или [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] процесс загрузки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст для входных данных, используемых этим элементом <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <value>Область ввода, которая изменяет интерпретацию ввода с помощью альтернативных методов. Значение по умолчанию — <see langword="null" /> (что приводит к обработке команд по умолчанию).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство зависимостей наследует значения свойств. Если существуют дочерние элементы, имеющие отсутствует значение для <xref:System.Windows.FrameworkElement.InputScope%2A> установленное при помощи локальных значений или стили, система свойств задаст значение должно быть <xref:System.Windows.FrameworkElement.InputScope%2A> значение ближайшего родительского элемента с назначенным данным значением.  
  
 Несмотря на то что [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксис использования указано и синтаксически разрешено, задание этого свойства [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] не часто.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.InputScope" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, был ли инициализирован данный элемент, либо путем загрузки в качестве [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], либо путем явного вызова своего метода <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</summary>
        <value><see langword="true" />, если элемент инициализирован путем вышеупомянутой загрузки или вызовов метода; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство также может быть `true` Если этот элемент был перемещен в дереве элементов таким образом, он имеет новый родительский элемент и снова станет перегруженным.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, загружен ли данный элемент для презентации.</summary>
        <value><see langword="true" />, если текущий элемент прикреплен к дереву элементов и визуализирован; <see langword="false" /> — если элемент никогда не был присоединен к загруженному дереву элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вновь созданного экземпляра это свойство начинается `false`и остается `true` после его установки в `true`, даже если впоследствии удаляется по коду.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> как условного проверку, чтобы убедиться, что функция `displayData` (не показано) будет допустимые элементы загружены на странице, чтобы работать, как часть обработчик по запросу. Что же логика выполняется как обработчик событий для <xref:System.Windows.FrameworkContentElement.Loaded>.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о языке локализации и глобализации, который применяется к отдельному элементу.</summary>
        <value>Сведения о языке и региональных параметрах для этого элемента. Значение по умолчанию — экземпляр <see cref="T:System.Windows.Markup.XmlLanguage" /> со значением <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" />, равным строке "гu-RU".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строковые форматы соответствуют стандарту RFC 3066. Например США Английский — «en US». См. в разделе <xref:System.Windows.Markup.XmlLanguage> Дополнительные сведения о значениях и формате.  
  
 Это свойство зависимостей наследует значения свойств. Если существуют дочерние элементы, имеющие отсутствует значение для <xref:System.Windows.FrameworkElement.Language%2A> установленное при помощи локальных значений или стили, система свойств задаст значение должно быть <xref:System.Windows.FrameworkElement.Language%2A> значение ближайшего родительского элемента с назначенным данным значением.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.Language" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если элемент размещен, отрисован и готов к взаимодействию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События с прямой маршрутизацией не выполняйте маршрут, они обрабатываются только внутри элемента, на котором они вызываются. Прямые перенаправленные события поддерживают другие поведения перенаправленного события: они поддерживают коллекцию доступных обработчиков и могут использоваться в качестве <xref:System.Windows.EventTrigger> в стиле.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификатор события, создаваемые при их регистрации (см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем может использоваться для добавления обработчиков классов (см. в разделе <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Идентификатор объекты содержат уникальное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает перечислитель для логических дочерних элементов данного элемента.</summary>
        <value>Перечислитель для логических дочерних элементов данного элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об использовании <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> и <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, см. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Направление, в котором перемещается фокус, в виде значения перечисления.</param>
        <summary>Перемещает клавиатурный фокус с данного элемента на другой.</summary>
        <returns>Возвращает <see langword="true" />, если фокус перемещен успешно; <see langword="false" />, если целевого элемента в указанном направлении не существует.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя, обозначающее элемент. Имя предоставляет ссылку на экземпляр, чтобы код программной части, например код обработчика событий, мог ссылаться на элемент после создания этого элемента во время синтаксического анализа [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Имя элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенный случай использования этого свойства — при указании [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] имя элемента в разметке.  
  
 По существу, это свойство предоставляет свойство удобства уровня платформы WPF, чтобы установить [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Начало <xref:System.Windows.FrameworkContentElement.Name%2A> из кода не часто, потому что если вы уже соответствующую ссылку в коде, можно просто вызвать методы и свойства в элементе ссылки и не обычно необходимость <xref:System.Windows.FrameworkContentElement.Name%2A>. Исключение — если строка имеет несколько перегруженных значение, например если необходимо отобразить это имя в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Установка <xref:System.Windows.FrameworkContentElement.Name%2A> из кода если исходный <xref:System.Windows.FrameworkContentElement.Name%2A> был набор из разметки, также не рекомендуется, и изменения свойства не изменится ссылка на объект. Ссылки на такие объекты создаются только в том случае, когда основной области видимости имен явно создаются во время [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] загрузки.  
  
 Необходимо явно вызывать <xref:System.Windows.FrameworkContentElement.RegisterName%2A> действующие сделать на <xref:System.Windows.FrameworkContentElement.Name%2A> свойства элемента уже загружен.  
  
 Один заметных случае там, где параметр <xref:System.Windows.FrameworkContentElement.Name%2A> из кода важна для именования элементов, которые раскадровки будет выполняться. Перед регистрацией имени, может также потребоваться создания экземпляров и присваивания <xref:System.Windows.NameScope> экземпляра. См. в разделе "Пример" или [Общие сведения о раскадровках](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Параметр <xref:System.Windows.FrameworkContentElement.Name%2A> из кода имеет ограниченную приложений, но поиск элемента по имени чаще, особенно в том случае, если задействуется модель навигации с перезагрузкой страниц в приложение и код времени выполнения не обязательно является кодом программной части, соответствующую страницу. Служебный метод <xref:System.Windows.FrameworkContentElement.FindName%2A>, который доступен из любого <xref:System.Windows.FrameworkContentElement>, можно найти любой элемент, <xref:System.Windows.FrameworkContentElement.Name%2A> в рекурсивно логического дерева этого элемента. Или можно использовать <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> статический метод <xref:System.Windows.LogicalTreeHelper>, который также принимает <xref:System.Windows.FrameworkContentElement.Name%2A> строку в качестве аргумента.  
  
 Часто используемые корневых элементов (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> для примера) реализовать интерфейс <xref:System.Windows.Markup.INameScope>. Реализации этого интерфейса ожидается обеспечение однозначности имен в их области.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.Name" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет значение по умолчанию реализации. Если промежуточный класс в цепочке наследования реализует данный метод рекомендуется вызывать базовую реализацию.  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является перенаправленное событие. Шаблон реализации методы On * отличается для перенаправленных событий, так как перенаправленное событие может быть вызвано дочерний элемент, не обязательно является элементом, который будет вызывать обработчики. Таким образом реализации необходимо учитывать исходные свойства аргументов события (и не следует пытаться повторно отправить событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkContentElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и пометка события как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные для события.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет значение по умолчанию реализации. Если промежуточный класс в цепочке наследования реализует данный метод рекомендуется вызывать base().  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является перенаправленное событие. Шаблон реализации методы On * отличается для перенаправленных событий, так как перенаправленное событие может быть вызвано дочерний элемент, не обязательно является элементом, который будет вызывать обработчики, реализация придется использовать источник для аргументов событий свойства в учетной записи (и не следует пытаться повторно отправить событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkContentElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и пометка события как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные для события.</param>
        <summary>Обработчик класса для события <see cref="E:System.Windows.ContentElement.GotFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот обработчик класса задает соответствующее поведение фокуса на данном элементе, если событие происходит из этого элемента. Если источником события был другой элемент в дереве, обработчик не выполняет никаких действий.  
  
 Переопределите этот метод, чтобы изменить фокусировки поведение вашего элемента по умолчанию.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные для события.</param>
        <summary>Создает событие <see cref="E:System.Windows.FrameworkContentElement.Initialized" />. Этот метод вызывается при каждой установке для свойства <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> значения <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию данного виртуального метода вызывает событие, как описано ранее в этом разделе. Переопределения должны вызывать base() для сохранения этого поведения.  
  
 Обратите внимание, что <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> свойство доступно только для чтения. Таким образом нельзя задать для него принудительную инициализацию таким образом. Параметр инициализации должен выполняться только в [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, описывающие измененное свойство, а также старое и новое значения.</param>
        <summary>Вызывается каждый раз, когда обновляется действительное значение любого свойства зависимостей для данного <see cref="T:System.Windows.FrameworkContentElement" />. Конкретное измененное свойство зависимостей сообщается в параметре аргументов. Переопределяет <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для обычно обнаружения изменения свойств или недействительности. Он предназначен для изменения общего шаблона недействительности Если известны определенные сведения о классификациях расширенных свойств.  
  
 Этот метод потенциально вызывается много раз в течение жизненного цикла объекта. Таким образом, можно повысить производительность, если переопределить метаданные свойств, а затем подключить <xref:System.Windows.CoerceValueCallback> или <xref:System.Windows.PropertyChangedCallback> функции для отдельных свойств. Тем не менее, можно использовать, этот метод Если <xref:System.Windows.FrameworkContentElement> включает значительное количество свойств зависимостей с взаимосвязанными значение, или если он содержит логику, такие как поведение отрисовки, необходимо повторно для нескольких связанных случаев недействительности свойств.  
  
 Обратите внимание, что таким же именем `OnPropertyChanged` метод с другой сигнатурой (тип параметра является <xref:System.ComponentModel.PropertyChangedEventArgs>), которые могут возникнуть на несколько классов. Что `OnPropertyChanged` используется для уведомления объекта данных, и является частью контракта для <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Всегда вызывайте базовую реализацию, как первую операцию в реализации. Если этого не сделать значительно отключит всего [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств, в результате чего будут сообщены неверные значения.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Старый стиль.</param>
        <param name="newStyle">Новый стиль.</param>
        <summary>Вызывается при изменении стиля, используемого для данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет реализацию по умолчанию, которая устанавливает внутренний флаг, уведомляя об измененном состоянии стиля.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Всегда вызывать базовую реализацию, в противном случае невозможно применить стили. Сценарии для переопределения этого метода может содержать, если в производном классе имеется селектор специализированного стиля или кэшированные значения стиля. Изменения темы потенциально будет вызывать этот метод.</para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет значение по умолчанию реализации. Если промежуточный класс в цепочке наследования реализует данный метод рекомендуется вызывать base().  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является перенаправленное событие. Шаблон реализации методы On * отличается для перенаправленных событий, так как перенаправленное событие может быть вызвано дочерний элемент, не обязательно является элементом, который будет вызывать обработчики, реализация придется использовать источник для аргументов событий свойства в учетной записи (и не следует пытаться повторно отправить событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkContentElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и пометка события как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не имеет значение по умолчанию реализации. Если промежуточный класс в цепочке наследования реализует данный метод рекомендуется вызывать base().  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является перенаправленное событие. Шаблон реализации методы On * отличается для перенаправленных событий, так как перенаправленное событие может быть вызвано дочерний элемент, не обязательно является элементом, который будет вызывать обработчики, поэтому вашей реализации потребуется использовать источник для аргументов событий свойства в учетной записи (и не следует пытаться повторно отправить событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkContentElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и пометка события как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, содержит ли данный элемент свойства стиля из тематических стилей.</summary>
        <value>Значение <see langword="true" />, если этот элемент не использует свойства стиля темы; все свойства, определяющие стиль, получаются из локальных стилей приложения, а свойства стиля темы не применяются. Значение <see langword="false" />, если сначала применяются стили приложения, а затем стили тем для свойств, которые не были явным образом заданы в стилях приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенный случай использования этого свойства является непрямое использование в переключателе стиля, который передает тематический стиль.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает родительский объект в логическом дереве для этого элемента.</summary>
        <value>Логический родительский объект для этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что логический родитель элемента потенциально может меняться в зависимости от функциональности приложения, и сохранение значения этого свойства не отразит это изменение. Обычно нужно получить значение, непосредственно перед он вам нужен.  
  
 См. в разделе [деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) Дополнительные сведения о просмотре логические деревья и сценарии, в которых подходит при таком подходе к элемент обнаружения.  
  
 Система свойств потенциально пересчитывает все значения свойств элемента при изменении его родителя, так как некоторые свойства наследуют значения по логическому дереву. <xref:System.Windows.FrameworkContentElement.DataContext%2A> , Применяемый для привязки также можно изменить при изменении в родителя или элементов.  
  
 Изменение родительского элемента обычно выполняется только через управление коллекциями, с использованием выделенных методов добавления и удаления, или путем задания свойств содержимого элементов.  
  
 Наиболее типичный сценарий использования <xref:System.Windows.FrameworkContentElement.Parent%2A> свойство является получить ссылку, а затем получить различные <xref:System.Windows.FrameworkContentElement> значения свойств из родительского элемента. Для шаблонов <xref:System.Windows.FrameworkContentElement.Parent%2A> шаблона со временем будет `null`. Чтобы преодолеть эту точку и расширить в логическом дереве, где фактически применяется шаблон, используйте <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.  
  
   
  
## Examples  
 В следующем примере проверяется, чтобы увидеть ли <xref:System.Windows.FrameworkContentElement.Parent%2A> из <xref:System.Windows.Documents.TextPointer> является определенного типа.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Направление, в котором следует определить перспективное изменение фокуса.</param>
        <summary>Определяет следующий элемент, который получит фокус, относительно данного элемента для указанного направления движения фокуса, но реально фокус не перемещает. Данный метод запечатан и не может быть переопределен.</summary>
        <returns>Следующий элемент, на который будет перемещен фокус в случае фактического обхода фокуса. Может возвращать значение <see langword="null" />, если фокус нельзя переместить относительно данного элемента в указанном направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> — Это связанный метод, который фактически перемещения фокуса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Одно из следующих направлений, указанное в <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Эти направления недопустимы для метода <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (однако допустимы для метода <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Имя, используемое для сопоставления указанного имени с объектом.</param>
        <param name="scopedElement">Объект для сопоставления.</param>
        <summary>Предоставляет метод доступа, упрощающий доступ к методу регистрации <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод — это удобный метод для вызова <xref:System.Windows.NameScope.RegisterName%2A>. Реализация будет проверять последовательных родительских элементах, пока не найдет применимой <xref:System.Windows.NameScope> реализации, в которой находится путем поиск элемента, который реализует <xref:System.Windows.Markup.INameScope>. Дополнительные сведения об области видимости имен см. в разделе [области видимости имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Вызов <xref:System.Windows.FrameworkContentElement.RegisterName%2A> нужно, чтобы правильно подключить раскадровки анимации для приложений, при создании в коде. Это обусловлено тем, одним из ключевых раскадровка свойства, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, выполняет поиск имен времени выполнения, вместо того использовать ссылку на целевой элемент. Это справедливо, даже если этот элемент доступен по ссылке из кода. Дополнительные сведения о том, почему требуется регистрировать имена целей раскадровки, см. в разделе [Общие сведения о раскадровках](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md). Анимация элементов содержимого применяется реже, чем анимация элементов, [Общие сведения о раскадровках](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Подлежащий удалению элемент.</param>
        <summary>Удаляет указанный элемент из логического дерева данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] основном относится к сценариям, произведения при добавлении поддержки для коллекций дочерних классов.  
  
 Большинство <xref:System.Windows.FrameworkContentElement> производные классы предоставляют выделенную коллекций, которые отвечают за вложения (например, <xref:System.Windows.Documents.Span.Inlines%2A> на <xref:System.Windows.Documents.Span> класса; <xref:System.Windows.Documents.Section.Blocks%2A> на <xref:System.Windows.Documents.Section> класса). Наследование от таких классов обычно можно избежать необходимости обращаться к логическому дереву напрямую.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текущий локально определенный словарь ресурсов.</summary>
        <value>Текущие локально определенные ресурсы. Это словарь ресурсов, доступ к ресурсам которого можно получить по ключу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Словари ресурсов, которые могут быть определены полностью или частично в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] обычно создаются в качестве элемента свойства и обычно находятся на корневой элемент для любой отдельной страницы или приложения. Размещение словаря ресурсов на этом уровне облегчает поиск из отдельных дочерних элементов на странице (или с любой страницы, в случае приложения). В большинстве сценариев приложений, рекомендуется определить эти стили как элементы объекта в словаре ресурсов, или как внешние ресурсы, чтобы весь ресурс стиля могут быть автономными (этот подход помогает отдельный конструктор Ответственность от ответственности разработчика путем разделения физических файлов, которые нужно редактировать).  
  
 Обратите внимание, что это свойство возвращает только словарь ресурсов, объявленные непосредственно в этот элемент. Это отличается от фактического процесса поиска ресурсов, где дочерний элемент можно использовать все ресурсы, определенные в каждом родительском элементе, поиск вверх рекурсивно.  
  
 Ресурсы можно ссылаться с помощью кода из коллекции, но имейте в виду, что ресурсы созданы в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] , определенно не будут доступны до после <xref:System.Windows.FrameworkContentElement.Loaded> элементом, который объявляет словаря. На самом деле, ресурсы обрабатываются асинхронно и даже <xref:System.Windows.FrameworkContentElement.Loaded> событий является гарантией того, вы можете ссылаться на [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] определенных ресурсов. По этой причине следует обычно только обращаться к [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ресурсы, определяемые как часть кода среды выполнения, или через другие [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] методы, такие как стили или ссылки на расширения ресурсов для значений атрибутов. При доступе к ресурсам с помощью кода, это по существу эквивалентно ссылку из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Базовый <xref:System.Windows.ResourceDictionary> поддерживает методы, необходимые для добавления, удаления или запроса ресурсов из коллекции с помощью кода. <xref:System.Windows.FrameworkContentElement.Resources%2A> Свойство является настраиваемым для поддержки сценария полной замены ресурсам коллекцию новый или другой элемент <xref:System.Windows.ResourceDictionary>.  
  
 Обратите внимание, что [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксиса не включает элемент для <xref:System.Windows.ResourceDictionary>. Ниже приведен пример неявного синтаксиса коллекции; можно опустить тег, представляющий элемент коллекции. Вместо этого указываются элементы, которые будут добавлены как элементы в коллекцию. Дополнительные сведения о неявных коллекциях и [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], см. в разделе [XAML подробное описание синтаксиса](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Один случай где <xref:System.Windows.ResourceDictionary> по-прежнему указывается явно как элемент, Представляем объединенный словарь, в этом случае существует обычно нет дочерних элементов для этого <xref:System.Windows.ResourceDictionary>. Дополнительные сведения см. в разделе [объединенные словари ресурсов](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *oneOrMoreResourceElements*  
 Один или несколько объектов элементов, каждый из которых определяет ресурс. В каждом элементе свойства ресурсов в каждом <xref:System.Windows.ResourceDictionary> должен иметь уникальное значение для [директивы x: Key](~/docs/framework/xaml-services/x-key-directive.md), который используется в качестве уникального ключа при получении значений из <xref:System.Windows.ResourceDictionary>.  
  
   
  
## Examples  
 Следующий пример устанавливает <xref:System.Windows.FrameworkContentElement.Resources%2A> коллекции <xref:System.Windows.Documents.FlowDocument> корневого элемента. <xref:System.Windows.Documents.FlowDocument> — Это стандартный вариант, поскольку он является одним из немногих <xref:System.Windows.FrameworkContentElement> с корневой страницы или на даже более высоких уровнях, например приложение, обычно хранятся классы, которые имеют смысл как корневой элемент и ресурсы.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Присоединяет привязку к этому элементу для указанного свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Идентифицирует привязанное свойство.</param>
        <param name="path">Имя исходного свойства или путь к свойству, используемому для привязки.</param>
        <summary>Прикрепляет привязку к данному элементу на основе указанного имени исходного свойства в виде классификационного пути к источнику данных.</summary>
        <returns>Фиксирует состояния привязки. Это возвращаемое значение можно использовать для проверки ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод — это удобный метод для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, который передает текущий экземпляр как <xref:System.Windows.DependencyObject>и создает новый <xref:System.Windows.Data.Binding> на основе предоставленной `path` параметра. Эта подпись является более удобным, если устанавливается простой привязки по умолчанию. Если вам нужно указать любые свойства привязки для условия не по умолчанию, или хотите использовать <xref:System.Windows.Data.MultiBinding> или <xref:System.Windows.Data.PriorityBinding>, следует использовать <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> подписи.  
  
   
  
## Examples  
 В следующем примере задается привязка на <xref:System.Windows.Documents.Paragraph> элемент, путем создания нового объекта пользовательские данные, установлении объект в качестве <xref:System.Windows.FrameworkContentElement.DataContext%2A>и указав путь привязки к свойству в ней.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Идентифицирует привязанное свойство.</param>
        <param name="binding">Представляет привязку данных.</param>
        <summary>Прикрепляет привязку к данному элементу на основе предоставленной привязки объекта.</summary>
        <returns>Фиксирует состояния привязки. Это возвращаемое значение можно использовать для проверки ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод — это удобный метод для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, который передает текущий экземпляр как <xref:System.Windows.DependencyObject>.  
  
   
  
## Examples  
 В следующем примере задается привязка на <xref:System.Windows.Documents.Paragraph> элемент, создавая новый <xref:System.Windows.Data.Binding> и установив источник для вновь созданных `DateTime` объекта.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство, к которому привязан ресурс.</param>
        <param name="name">Имя ресурса.</param>
        <summary>Выполняет поиск ресурса по указанному имени и устанавливает ссылку на этот ресурс для указанного свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ссылка на ресурс похоже на использование [расширение разметки DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) в разметке. Ссылка на ресурс создает внутреннее выражение, содержащий значение заданного свойства на основе отложенного выполнения. Выражение будет повторно вычисляться каждый раз, когда словарь ресурсов указывает измененного значения через внутренние события, или при каждом изменении родителя текущего элемента (родителя изменяется путь для поиска словаря).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkContentElement.Resources" /> в экземплярах данного класса.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkContentElement.Resources" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда возвращает `true` до тех пор, пока есть хотя бы один ресурс с ключом в локальной <xref:System.Windows.FrameworkContentElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkContentElement.Style" /> в экземплярах данного класса.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkContentElement.Style" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта команда возвращает `true` Если <xref:System.Windows.Style> устанавливается локально.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении какого-либо связанного источника данных, участвующего в привязке к данному элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие поверхности <xref:System.Windows.Data.Binding.SourceUpdated> событие, вызванное каким-либо <xref:System.Windows.Data.Binding> связанных с этим элементом.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает стиль, который должен использоваться этим элементом.</summary>
        <value>Примененный стиль не по умолчанию для элемента, если присутствует. В противном случае — значение <see langword="null" />. Значение по умолчанию для созданного по умолчанию <see cref="T:System.Windows.FrameworkContentElement" /> — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текущий стиль часто обеспечивается путем стиль по умолчанию из темы или из стилей, обычно применяемых к объектам этого типа ресурсами на уровне страницы или приложения (неявный стиль). Это свойство не по умолчанию устанавливает и не возвращает стили (темы), но возвращает неявный или явный стиль. В случае явного или неявного стили неважно ли стиль доступен как ресурс, или определен локально.  
  
 Задание стилей имеет некоторые ограничения. Вы можете сбросить всего <xref:System.Windows.FrameworkContentElement.Style%2A> свойство в новый <xref:System.Windows.Style> в любое время, что вынудит рекомпозиции макета. Тем не менее, как можно быстрее, так как этот стиль размещается используется загруженным элементом <xref:System.Windows.Style> должно считаться запечатанный. Попытка внести изменение любого отдельного свойства используемого стиля (такие как любые действия в коллекцию <xref:System.Windows.Style.Setters%2A>) приводит к возникновению исключения, исключение. Стиль, определенный в разметке считается используется как только он загружается из словаря ресурсов (для ресурсов) или загрузке страницы, в которой оно содержится в (для встроенных стилей).  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> является свойством зависимостей с помощью специальных приоритет. Локально заданное стиль обычно действует с наивысшим приоритетом в системе свойств. Если <xref:System.Windows.FrameworkContentElement.Style%2A> имеет значение null на этом этапе во время загрузки, система свойств проверяет наличие неявных стилей как определенных ресурсов этого типа. Если стиль равен null после выполнения этого шага, то стиль поступает из стиля по умолчанию (тема), но стиль по умолчанию не возвращается в <xref:System.Windows.FrameworkContentElement.Style%2A> значение свойства. См. в разделе [приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ResourceExtension*  
 Одно из следующих:, или. См. в разделе [ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Ключ, который идентифицирует запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Синтаксис элемента свойства технически возможно, но не рекомендуется. См. в разделе [встроенные стили и шаблоны](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Ссылка на привязку с помощью или <xref:System.Windows.Data.Binding> — также, возможно, но встречается редко.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Следующий пример устанавливает <xref:System.Windows.FrameworkContentElement.Resources%2A> коллекции <xref:System.Windows.Documents.FlowDocument> корневой элемент и затем ссылается на нее в качестве ресурса, как определенный стиль для <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Имя запрошенного внешнего свойства.</param>
        <summary>Описание этого элемента содержится в методе <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</summary>
        <returns>Значение <see langword="true" />, если свойство с именем в параметре <paramref name="propertyName" /> доступно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный элемент является явной реализацией элемента интерфейса. Он может использоваться только при условии, что экземпляр класса <xref:System.Windows.FrameworkContentElement> приведен к типу интерфейса <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка произвольного значения объекта, которое может использоваться для хранения особых сведений об этом элементе.</summary>
        <value>Целевое значение. Это свойство не имеет значения по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является аналогом свойства тега в других моделях программирования для Microsoft, таких как Visual Basic для приложений или Windows Forms. Он предназначен для предоставления готовых место для хранения базовой пользовательской информации о любом элементе не принуждает разработчиков приложения подкласс.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>Значения XAML  
 Так как это свойство принимает объект, необходимо использовать использование элемента свойства, чтобы задать <xref:System.Windows.FrameworkContentElement.Tag%2A> свойства в XAML только на объект с известным и встроенный тип преобразователя, например строку. Объекты, используемые таким образом, обычно не входят в стандартные пространства имен WPF и поэтому может потребоваться сопоставление пространства имен с внешним пространством имен для новых элементов XAML.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|Значение свойства метаданных `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.Tag" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении любого связанного целевого свойства, участвующего в привязке в этом элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие поверхности <xref:System.Windows.Data.Binding.TargetUpdated> событие, вызванное каким-либо <xref:System.Windows.Data.Binding> связанных с этим элементом. Обычно это означает, что рассматриваемая представляет собой двустороннюю привязку, и что связанного свойства зависимостей подтверждает недействительность предыдущего значения свойства проверку или схеме кеширования, который поддерживает свойство.  
  
 Аргументы события этого события сообщит, что вы какое связанное свойство была изменена.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ссылку на родительский объект шаблона данного элемента. Это свойство не актуально, если элемент не был создан с помощью шаблона.</summary>
        <value>Элемент, свойство <see cref="T:System.Windows.FrameworkTemplate" /> шаблона <see cref="P:System.Windows.FrameworkTemplate.VisualTree" />  которого вызвало создание данного элемента. Это значение часто равно <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблоны являются фактически общих объектов, в которой содержимое шаблона создаются только один раз. Таким образом Если получить ссылку на элемент, который поступил из шаблона, вы обнаружите, что заметно логическое дерево не удалось связаться с корневой страницы. Чтобы подключить такую ссылку шаблона для логического дерева страницы, вы должны получить <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> значение и продолжать переместиться в этом дереве элемент, при необходимости.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> часто оказываются `null` для общих объектов, так как если вы получили ссылку на объект из линейных страницы в приложении обычно средствами, этот элемент, возможно, не был создан из шаблона. Ситуации, когда <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> может оказаться `null` включает операции, такие как события нажатия, обрабатывает определенные низкоуровневые события ввода, или работа с перечислителями, которые могут возвращать элементы, полученные из шаблонов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект подсказки, отображаемый для данного элемента в [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Объект подсказки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение этого свойства имеет тип <xref:System.Windows.Controls.ToolTip>, затем это средство подсказку, которая будет использоваться в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Если значение любого другого типа, то это значение будет использоваться в качестве *содержимого* для <xref:System.Windows.Controls.ToolTip> предоставленные (создан) системой. Дополнительные сведения см. в разделе <xref:System.Windows.Controls.ToolTipService>. Класс службы предоставляет вложенные свойства, которые могут использоваться для дальнейшей настройки всплывающей подсказки.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *toolTipContent*  
 Строка, которая становится отображаемый текст для <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Некоторые объектом, указанным в форме элемента объекта, который должен использоваться как содержимое <xref:System.Windows.FrameworkContentElement> . Обычно это было бы <xref:System.Windows.FrameworkElement> или другой элемент, который создает композиции макета для <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, со временем, содержащий текстовое содержимое в композиции. При таком использовании <xref:System.Windows.Controls.ToolTip> создается элемент неявно из проанализированный [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]и *toolTipObjectContent* содержимое устанавливается в качестве его <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> свойство.  
  
 <`ToolTip` .../>  
 См. раздел <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|Значение свойства метаданных `true`|None|  
  
   
  
## Examples  
 В следующем примере значение <xref:System.Windows.FrameworkElement.ToolTip%2A> свойства непосредственно в строку.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед закрытием какой-либо подсказки в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы подавить закрытие подсказки, обработчики события следует пометить его как обработанное.  
  
 Это событие не может быть <xref:System.Windows.EventTrigger> в стиле. Это потому, что поле идентификатора данного события повторно использует реализацию из службы, не предоставляет методы для добавления/удаления события.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификатор события, создаваемые при их регистрации (см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем может использоваться для добавления обработчиков классов (см. в разделе <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Идентификатор объекты содержат уникальное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при открытии любой всплывающей подсказки к элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вручную открыть всплывающие подсказки, обработчики событий следует помечать соответствующее событие как обработанное. В противном случае — значение <xref:System.Windows.FrameworkContentElement.ToolTip%2A> свойство будет использоваться для автоматического открытия контекстного меню. Маркировка события как обработанного эффективно отменит действие по умолчанию и может быть возможность сбросить значение <xref:System.Windows.FrameworkContentElement.ToolTip%2A> свойство и откройте новый <xref:System.Windows.Controls.ContextMenu>. Обратите внимание, что это событие не будет вызываться, если <xref:System.Windows.FrameworkContentElement.ToolTip%2A> является пустой ссылкой или иным способом не задано.  
  
 Это событие не может быть <xref:System.Windows.EventTrigger> в стиле. Это потому, что поле идентификатора данного события повторно использует реализацию из службы, не предоставляет методы для добавления/удаления события.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификатор события, создаваемые при их регистрации (см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем может использоваться для добавления обработчиков классов (см. в разделе <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Идентификатор объекты содержат уникальное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет свойство зависимостей <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Идентификатор ключа искомого ресурса.</param>
        <summary>Ищет ресурс с указанным ключом и возвращает его, если он найден.</summary>
        <returns>Найденный ресурс. Если не удалось найти ресурс, возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ресурс не найден в вызывающем элементе, родительское дерево выполняется поиск, с помощью логического дерева таким же образом, который бы выполнялся поиск, если ссылка на динамический ресурс был запрошен по ключу во время выполнения.  
  
 Обычно вы сразу же привести возвращаемое значение к типу свойства, которое вы пытаетесь значения возвращаемым ресурсом.  
  
 <xref:System.Windows.FrameworkContentElement.FindResource%2A> Метод имеет аналогичное поведение, за исключением того, что он приведет к возникновению исключения в случае отсутствия ресурса с указанным ключом.  
  
   
  
## Examples  
 Следующий пример находит ресурс, определенный в разметке и применяет его к определенному свойству элемента в ответ на перенаправленное событие.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при удалении элемента из дерева загруженных элементов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События с прямой маршрутизацией не выполняйте маршрут, они обрабатываются только внутри элемента, на котором они вызываются. Прямые перенаправленные события поддерживают другие поведения перенаправленного события: они поддерживают коллекцию доступных обработчиков и могут использоваться в качестве <xref:System.Windows.EventTrigger> в стиле.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Обзор маршрутизированных событий](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объекты идентификатор события, создаваемые при их регистрации (см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем может использоваться для добавления обработчиков классов (см. в разделе <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Идентификатор объекты содержат уникальное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя пары имя-объект, которую необходимо удалить из текущей области видимости.</param>
        <summary>Упрощает доступ к методу отмены регистрации <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Требуется отменять регистрацию имен Если планируется повторно зарегистрировать другой элемент с таким же именем.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Повторно применяет стиль по умолчанию к текущему объекту <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>